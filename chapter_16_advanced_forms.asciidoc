[[chapter_16_advanced_forms]]
== More Advanced Forms

.A Note for Early Release Readers
****
With Early Release ebooks, you get books in their earliest form—the author's
raw and unedited content as they write—so you can take advantage of these
technologies long before the official release of these titles.

This will be the 16th chapter of the final book.
The GitHub repo is available at
https://github.com/hjwp/book-example/tree/chapter_16_advanced_forms

If you have comments about how we might improve the content and/or examples in this book,
or if you notice missing material within this chapter,
please reach out to the author at obeythetestinggoat@gmail.com.
****

Let's look at some more advanced forms usage.
We've helped our users to avoid blank list items,
so now let's help them avoid duplicate items.

Our validation constraint so far has been about preventing blank items,
and as you may remember, it turned out we can enforce that very easily in the frontend.
Avoiding duplicate items is less straightforward to do in the frontend
(although not impossible, of course),
so this chapter will lean more heavily on server-side validation,
and bubbling errors from the backend back up to the UI.

This chapter goes into the more intricate details of Django's forms framework,
so you have my official permission to skim through it
if you already know all about customising Django forms and how to display errors in the UI,
or if you're reading this book for the TDD rather than for the Django.

If you're still learning Django, there's good stuff in here!
If you want to just skim-read, that's OK too.
Make sure you take a quick look at the
<<testing-for-silliness,aside on developer silliness>>,
and the <<what-to-test-in-views,recap on testing views>> at the end.

// DAVID: A general point: I feel like just because we're doing TDD
// doesn't mean we can't occasionally start up the application
// and use it to figure out what's happening.
// It feels like a long time since we've done that!


=== Another FT for Duplicate Items

((("form data validation", "for duplicate items", id="FDVduplicate15")))
((("functional tests (FTs)", "for duplicate items", secondary-sortas="duplicate items", id="FTduplicate15")))
((("duplicate items testing", "functional test for", id="DITfunctional15")))
((("user interactions", "preventing duplicate items", id="UIduplicate15")))
We add a second test method to `ItemValidationTest`,
and tell a little story about what we want to see happen
when a user tries to enter the same item twice into their to-do list:

[role="sourcecode"]
.src/functional_tests/test_list_item_validation.py (ch15l001)
====
[source,python]
----
def test_cannot_add_duplicate_items(self):
    # Edith goes to the home page and starts a new list
    self.browser.get(self.live_server_url)
    self.get_item_input_box().send_keys("Buy wellies")
    self.get_item_input_box().send_keys(Keys.ENTER)
    self.wait_for_row_in_list_table("1: Buy wellies")

    # She accidentally tries to enter a duplicate item
    self.get_item_input_box().send_keys("Buy wellies")
    self.get_item_input_box().send_keys(Keys.ENTER)

    # She sees a helpful error message
    self.wait_for(
        lambda: self.assertEqual(
            self.browser.find_element(By.CSS_SELECTOR, ".invalid-feedback").text,
            "You've already got this in your list",
        )
    )
----
====

Why have two test methods rather than extending one,
or having a new file and class?
It's a judgement call. These two feel closely related;
they're both about validation on the same input field,
so it feels right to keep them in the same file.
On the other hand, they're logically separate enough
that it's practical to keep them in different methods:

// DAVID: This feels a bit hand-wavy. What are we weighing up here?
// For example, does 'signal' matter in functional tests?
// How about speed?

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test functional_tests.test_list_item_validation*]
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: .invalid-feedback; [...]

Ran 2 tests in 9.613s
----

// DAVID: Side note: The favicon 404s are getting pretty distracting by this point, I wonder if it would be
// worth fixing / silencing that somehow earlier in the book?
// HARRY: could do it like this https://stackoverflow.com/a/38917888

OK, so we know the first of the two tests passes now.
Is there a way to run just the failing one, I hear you ask?
Why, yes indeed:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test functional_tests.\
test_list_item_validation.ItemValidationTest.test_cannot_add_duplicate_items*]
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: .invalid-feedback; [...]
----

// TODO; commit ft.

==== Preventing Duplicates at the Model Layer

((("model-layer validation", "preventing duplicate items")))
So, if we want to start to implement our actual objective for the chapter,
let's write a new test that checks that duplicate items in the same list raise an error:

[role="sourcecode"]
.src/lists/tests/test_models.py (ch15l002)
====
[source,python]
----
def test_duplicate_items_are_invalid(self):
    mylist = List.objects.create()
    Item.objects.create(list=mylist, text="bla")
    with self.assertRaises(ValidationError):
        item = Item(list=mylist, text="bla")
        item.full_clean()
----
====

And, while it occurs to us,
we add another test to make sure we don't overdo it on our integrity constraints:


[role="sourcecode"]
.src/lists/tests/test_models.py (ch15l003)
====
[source,python]
----
def test_CAN_save_same_item_to_different_lists(self):
    list1 = List.objects.create()
    list2 = List.objects.create()
    Item.objects.create(list=list1, text="bla")
    item = Item(list=list2, text="bla")
    item.full_clean()  # should not raise
----
====

I always like to put a little comment for tests which are checking
that a particular use case should _not_ raise an error; otherwise,
it can be hard to see what's being tested:

----
AssertionError: ValidationError not raised
----

If we want to get it deliberately wrong, we can do this:


[role="sourcecode"]
.src/lists/models.py (ch15l004)
====
[source,python]
----
class Item(models.Model):
    text = models.TextField(default="", unique=True)
    list = models.ForeignKey(List, default=None, on_delete=models.CASCADE)
----
====

That lets us check that our second test really does pick up on this
problem:

----
ERROR: test_CAN_save_same_item_to_different_lists (lists.tests.test_models.List
AndItemModelsTest.test_CAN_save_same_item_to_different_lists)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "...goat-book/src/lists/tests/test_models.py", line 59, in
test_CAN_save_same_item_to_different_lists
    item.full_clean()  # should not raise
    [...]
django.core.exceptions.ValidationError: {'text': ['Item with this Text already
exists.']}
[...]
----

[role="less_space pagebreak-before"]
[[testing-for-silliness]]
.An Aside on When to Test for Developer Silliness
*******************************************************************************

// TODO: i kinda want to back to "stupidity".  talk to Rita about it.

One of the judgement calls in testing is when you should write tests that sound
like "check that we haven't done something weird".  In general, you should
be wary of these.


In this case, we've written a test to check that you can't save duplicate items
to the same list.  Now, the simplest way to get that test to pass, the way in
which you'd write the fewest lines of code, would be to make it impossible to
save 'any' duplicate items.  That justifies writing another test, despite the
fact that it would be a "silly" or "wrong" thing for us to code.

But you can't be writing tests for every possible way we could have coded
something wrongfootnote:[With that said, you can come pretty close.
Once you get comfortable writing tests manually, take a look at
https://hypothesis.readthedocs.io/en/latest/[Hypothesis].
It lets you automatically generate input for your tests,
covering many more test scenarios than you could realistically type manually.
It's not always easy to see how to use it,
but for the right kind of problem, it can be very powerful;
the very first time I used it, it found a bug!].
If you have a function that adds two numbers,
you can write a couple of tests:

[role="skipme"]
[source,python]
----
assert adder(1, 1) == 2
assert adder(2, 1) == 3
----

But you have the right to assume that the implementation isn't deliberately
screwy or perverse:

[role="skipme"]
[source,python]
----
def adder(a, b):
    # unlikely code!
    if a == 3:
        return 666
    else:
        return a + b
----

One way of putting it is that you should trust yourself not to do something
_deliberately_ silly, but not something _accidentally_ silly.
*******************************************************************************

((("Meta attributes")))
Just like `ModelForm`, models can use an inner class called `Meta`,
and that's where we can implement a constraint
which says that an item must be unique for a particular list,
or in other words, that `text` and `list` must be unique together:


[role="sourcecode"]
.src/lists/models.py (ch15l005)
====
[source,python]
----
class Item(models.Model):
    text = models.TextField(default="")
    list = models.ForeignKey(List, default=None, on_delete=models.CASCADE)

    class Meta:
        unique_together = ("list", "text")
----
====

And that passes:

----
Ran 25 tests in 0.024s

OK
----

You might want to take a quick peek at the
https://docs.djangoproject.com/en/5.2/ref/models/options/[Django docs on model `Meta` attributes]
at this point.



[[rewrite-model-test]]
==== Rewriting the Old Model Test

That long-winded model test did serendipitously help us find unexpected
bugs, but now it's time to rewrite it. I wrote it in a very verbose style to
introduce the Django ORM, but in fact, we can get the same coverage from a
couple of much shorter tests.
Delete `test_saving_and_retrieving_items` and replace it with this:

[role="sourcecode"]
.src/lists/tests/test_models.py (ch15l006)
====
[source,python]
----
class ListAndItemModelsTest(TestCase):
    def test_default_text(self):
        item = Item()
        self.assertEqual(item.text, "")

    def test_item_is_related_to_list(self):
        mylist = List.objects.create()
        item = Item()
        item.list = mylist
        item.save()
        self.assertIn(item, mylist.item_set.all())

    [...]
----
====

That's more than enough really--a check of the default values of attributes
on a freshly initialized model object is enough to sense-check that we've
probably set some fields up in 'models.py'.  The "item is related to list" test
is a real "belt and braces" test to make sure that our foreign key relationship
works.

While we're at it, we can split this file out into tests for `Item` and tests
for `List` (there's only one of the latter, `test_get_absolute_url`):

[role="sourcecode"]
.src/lists/tests/test_models.py (ch15l007)
====
[source,python]
----
class ItemModelTest(TestCase):
    def test_default_text(self):
        [...]


class ListModelTest(TestCase):
    def test_get_absolute_url(self):
        [...]
----
====

That's neater and tidier:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test lists*]
[...]
Ran 26 tests in 0.092s

OK
----


==== Integrity Errors That Show Up on Save

((("data integrity errors")))
A final aside before we move on.
Do you remember the discussion in  mentioned in <<chapter_14_database_layer_validation>>
that some data integrity errors _are_ picked up on save?
It all depends on whether the integrity constraint is actually being enforced by the database.

Try running `makemigrations` and you'll see
that Django wants to add the `unique_together` constraint to the database itself,
rather than just having it as an application-layer constraint:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py makemigrations*]
Migrations for 'lists':
  src/lists/migrations/0005_alter_item_unique_together.py
    ~ Alter unique_together for item (1 constraint(s))
----
//ch15l005-1

Now let's run the migration:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py migrate*]
----

.What to do if you see an IntegrityError when running migrations
*******************************************************************************
When you run the migration, you may encounter the following error:

[role="skipme"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py migrate*]
Operations to perform:
  Apply all migrations: auth, contenttypes, lists, sessions
Running migrations:
  Applying lists.0005_alter_item_unique_together...Traceback (most recent call last):
[...]
sqlite3.IntegrityError: UNIQUE constraint failed: lists_item.list_id, lists_item.text

[...]
django.db.utils.IntegrityError: UNIQUE constraint failed: lists_item.list_id, lists_item.text
----

The problem is that
we have at least one database record which _used_ to be valid
but after introducing our new constraint, the `unique_together`,
it's no longer compatible.

To fix this problem, locally we can just delete `src/db.sqlite3` and run the migration again.
We can do this because the database on our laptop is only used for dev,
so the data in it is not important.

In <<chapter_18_second_deploy>>, we'll deploy our new code to production,
and discuss what to do if we run into migrations and data integrity issues at that point.
*******************************************************************************

Now if we change our duplicates test to do a `.save` instead of a
`.full_clean`...


[role="sourcecode"]
.src/lists/tests/test_models.py (ch15l008)
====
[source,python]
----
    def test_duplicate_items_are_invalid(self):
        mylist = List.objects.create()
        Item.objects.create(list=mylist, text="bla")
        with self.assertRaises(ValidationError):
            item = Item(list=mylist, text="bla")
            # item.full_clean()
            item.save()
----
====

It gives:

----
ERROR: test_duplicate_items_are_invalid
(lists.tests.test_models.ItemModelTest.test_duplicate_items_are_invalid)
[...]
sqlite3.IntegrityError: UNIQUE constraint failed: lists_item.list_id,
lists_item.text
[...]
django.db.utils.IntegrityError: UNIQUE constraint failed: lists_item.list_id,
lists_item.text
----

You can see that the error bubbles up from SQLite, and it's a different
error from the one we want, an `IntegrityError` instead of a `ValidationError`.

Let's revert our changes to the test, and see them all passing again:

[role="dofirst-ch15l008-1"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test lists*]
[...]
Ran 26 tests in 0.092s
OK
----

((("", startref="FTduplicate15")))((("", startref="DITfunctional15")))And
now it's time to commit our model-layer changes:


[role="small-code"]
[subs="specialcharacters,macros"]
----
$ pass:[<strong>git status</strong>] # should show changes to tests + models and new migration
$ pass:[<strong>git add src/lists</strong>]
$ pass:[<strong>git diff --staged</strong>]
$ pass:[<strong>git commit -m "Implement duplicate item validation at model layer"</strong>]
----


=== Experimenting with Duplicate Item Validation at the Views Layer


((("duplicate items testing", "at the views layer", secondary-sortas="views layer")))Let's
try running our FT, just to see where we are:

----
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: .invalid-feedback; [...]

----

In case you didn't see it as it flew past, the site is 500ing.footnote:[It's showing a server error, code 500.]
A quick unit test at the view level ought to clear this up:

// DAVID: You've lost me on what thought process you took from that FT failure to writing this test.
// What I would do is actually spin up the site and walk through things manually, to understand the problem better.
// Also, it's not immediately clear what we're testing in this new test.

[role="sourcecode"]
.src/lists/tests/test_views.py (ch15l009)
====
[source,python]
----
class ListViewTest(TestCase):
    [...]

    def test_for_invalid_input_shows_error_on_page(self):
        [...]

    def test_duplicate_item_validation_errors_end_up_on_lists_page(self):
        list1 = List.objects.create()
        Item.objects.create(list=list1, text="textey")

        response = self.client.post(
            f"/lists/{list1.id}/",
            data={"text": "textey"},
        )

        expected_error = html.escape("You've already got this in your list")
        self.assertContains(response, expected_error)
        self.assertTemplateUsed(response, "list.html")
        self.assertEqual(Item.objects.all().count(), 1)
----
====

Gives:

----
django.db.utils.IntegrityError: UNIQUE constraint failed: lists_item.list_id,
lists_item.text
----

We want to avoid integrity errors! Ideally, we want the call to `is_valid` to
somehow notice the duplication error before we even try to save, but to do
that, our form will need to know in advance what list it's being used for.

Let's put a skip on that test for now:

[role="sourcecode"]
.src/lists/tests/test_views.py (ch15l010)
====
[source,python]
----
from unittest import skip
[...]

    @skip
    def test_duplicate_item_validation_errors_end_up_on_lists_page(self):
----
====

// TODO: alternatively, try/except on the validation error,
// get everything passing, then refactor to use a form.
// use the forms tests to explore the api (introduce the idea of a spike)
// maybe get it working, show how the forms-layer tests are annoying
// and switch to only views-layer tests


=== A More Complex Form to Handle Uniqueness Validation

((("duplicate items testing", "complex form for")))((("uniqueness validation", seealso="duplicate items testing")))The
form to create a new list only needs to know one thing, the new item text.
A form which validates that list items are unique needs to know the list too.
Just as we overrode the save method on our `ItemForm`, this time we'll
override the constructor on our new form class so that it knows what list it
applies to.

We duplicate our tests for the previous form, tweaking them slightly:

[role="sourcecode"]
.src/lists/tests/test_forms.py (ch15l011)
====
[source,python]
----
[...]
from lists.forms import (
    DUPLICATE_ITEM_ERROR,
    EMPTY_ITEM_ERROR,
    ExistingListItemForm,
    ItemForm,
)
[...]

class ExistingListItemFormTest(TestCase):
    def test_form_renders_item_text_input(self):
        list_ = List.objects.create()
        form = ExistingListItemForm(for_list=list_)  # <1>
        self.assertIn('placeholder="Enter a to-do item"', form.as_p())

    def test_form_validation_for_blank_items(self):
        list_ = List.objects.create()
        form = ExistingListItemForm(for_list=list_, data={"text": ""})
        self.assertFalse(form.is_valid())
        self.assertEqual(form.errors["text"], [EMPTY_ITEM_ERROR])

    def test_form_validation_for_duplicate_items(self):
        list_ = List.objects.create()
        Item.objects.create(list=list_, text="no twins!")
        form = ExistingListItemForm(for_list=list_, data={"text": "no twins!"})
        self.assertFalse(form.is_valid())
        self.assertEqual(form.errors["text"], [DUPLICATE_ITEM_ERROR])
----
====

<1> We're specifying that our new `ExistingListItemForm` will take
    an argument `for_list=` in its constructor,
    to be able to specify which list the item is for.

Next we iterate through a few TDD cycles until we get a form with a
custom constructor, which just ignores its `for_list` argument.
(I won't show them all, but I'm sure you'll do them, right? Remember, the Goat
sees all.)

// DAVID: worth spelling out what you mean here - i.e. go through and fix the exact test failure,
// don't just paste in the whole thing and get it passing in one go.

// JAN: I'm having troubles with lists.models.Item.MultipleObjectsReturned: get() returned more than one Item -- it returned X! lists.tests.test_forms.ItemFormTest.test_form_save/lists.tests.test_forms.ItemFormTest.test_form_save_handles_saving_to_a_list
// CSANAD: I did not notice anything like that and the automated tests for the
// book also pass here. Can you compare your code against
// https://github.com/hjwp/book-example/tree/chapter_16_advanced_forms if that
// helps?

[role="sourcecode"]
.src/lists/forms.py (ch15l012)
====
[source,python]
----
DUPLICATE_ITEM_ERROR = "You've already got this in your list"
[...]
class ExistingListItemForm(forms.models.ModelForm):
    def __init__(self, for_list, *args, **kwargs):
        super().__init__(*args, **kwargs)
----
====

At this point our error should be:

----
ValueError: ModelForm has no model class specified.
----

Then let's see if making it inherit from our existing form helps:

[role="sourcecode"]
.src/lists/forms.py (ch15l013)
====
[source,python]
----
class ExistingListItemForm(ItemForm):
    def __init__(self, for_list, *args, **kwargs):
        super().__init__(*args, **kwargs)
----
====

Yes, that takes us down to just one failure:

----
FAIL: test_form_validation_for_duplicate_items (lists.tests.test_forms.Existing
ListItemFormTest.test_form_validation_for_duplicate_items)
[...]
    self.assertFalse(form.is_valid())
AssertionError: True is not false
----

The next step requires a little knowledge of Django's validation system,
can read up on it in the Django docs on
https://docs.djangoproject.com/en/5.2/ref/models/instances/#validating-objects[model
validation] and
https://docs.djangoproject.com/en/5.2/ref/forms/validation/[form validation].

We can customise validation for a field by implementing a `clean_<fieldname>`
method, and raising a `ValidationError` if the field is invalid:

[role="sourcecode"]
.src/lists/forms.py (ch15l013-1)
====
[source,python]
----
from django.core.exceptions import ValidationError
[...]

class ExistingListItemForm(ItemForm):
    def __init__(self, for_list, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.instance.list = for_list

    def clean_text(self):
        text = self.cleaned_data["text"]
        if self.instance.list.item_set.filter(text=text).exists():
            raise forms.ValidationError(DUPLICATE_ITEM_ERROR)
        return text
----
====


And we're there!  A quick commit:

[role="skipme"]
[subs="specialcharacters,quotes"]
----
$ *git diff*
$ *git add src/lists/forms.py src/lists/tests/test_forms.py*
$ *git commit -m "implement ExistingListItemForm, add DUPLICATE_ITEM_ERROR message"*
----


=== Using the Existing List Item Form in the List View

((("duplicate items testing", "in the list view", secondary-sortas="list view", id="DITlist15")))Now
let's see if we can put this form to work in our view.

We remove the skip, and while we're at it, we can use our new constant. Tidy.

[role="sourcecode"]
.src/lists/tests/test_views.py (ch15l014)
====
[source,python]
----
from lists.forms import (
    DUPLICATE_ITEM_ERROR,
    EMPTY_ITEM_ERROR,
    ExistingListItemForm,
    ItemForm,
)
[...]

    def test_duplicate_item_validation_errors_end_up_on_lists_page(self):
        [...]
        expected_error = html.escape(DUPLICATE_ITEM_ERROR)
        self.assertContains(response, expected_error)
        [...]
----
====

That brings back our integrity error:

----
django.db.utils.IntegrityError: UNIQUE constraint failed: lists_item.list_id,
lists_item.text
----

Our fix for this is to switch to using the new form class.
Before we implement it, let's find the tests where we check the form class, and adjust them:

[role="sourcecode"]
.src/lists/tests/test_views.py (ch15l015)
====
[source,python]
----
class ListViewTest(TestCase):
[...]

    def test_displays_item_form(self):
        mylist = List.objects.create()
        response = self.client.get(f"/lists/{mylist.id}/")
        self.assertIsInstance(response.context["form"], ExistingListItemForm)
        self.assertContains(response, 'name="text"')

    [...]

    def test_for_invalid_input_passes_form_to_template(self):
        response = self.post_invalid_input()
        self.assertIsInstance(response.context["form"], ExistingListItemForm)
----
====

// TODO: make a note - this adjustment of the form class was annoying wasn't it?

That gives us:

----
AssertionError: <ItemForm bound=False, valid=False, fields=(text)> is not an
instance of <class 'lists.forms.ExistingListItemForm'>
----

So we can adjust the view:

[role="sourcecode"]
.src/lists/views.py (ch15l016)
====
[source,python]
----
from lists.forms import ExistingListItemForm, ItemForm
[...]
def view_list(request, list_id):
    our_list = List.objects.get(id=list_id)
    if request.method == "POST":
        form = ExistingListItemForm(for_list=our_list, data=request.POST)
        if form.is_valid():
            form.save()
            [...]
    else:
        form = ExistingListItemForm(for_list=our_list)
    [...]
----
====

And that _almost_ fixes everything, except for an unexpected fail:

----
  File "...goat-book/src/lists/views.py", line 26, in view_list
    form.save()
    ~~~~~~~~~^^
TypeError: ItemForm.save() missing 1 required positional argument: 'for_list'
----

It's happening when we try to call `form.save()`.
What's gone wrong is that `ExistingListItemForm` has inherited
the custom save method from `ItemForm`,
which we don't need for `ExistingListItemForm`.

Let's make a quick unit test for that:

// DAVID: When the tests are failing it's a smell to be writing another test - we should be trying
// to get these passing first, no?

[role="sourcecode"]
.src/lists/tests/test_forms.py (ch15l017)
====
[source,python]
----
class ExistingListItemFormTest(TestCase):
[...]
    def test_form_save(self):
        mylist = List.objects.create()
        form = ExistingListItemForm(for_list=mylist, data={"text": "hi"})
        self.assertTrue(form.is_valid())
        new_item = form.save()
        self.assertEqual(new_item, Item.objects.get())
[...]
----
====

We can make our form call the grandparent save method:

[role="sourcecode"]
.src/lists/forms.py (ch15l018)
====
[source,python]
----
class ExistingListItemForm(ItemForm):
    [...]
    def save(self):
        return forms.models.ModelForm.save(self)  # <1>
----
====

<1> This manually calls the grandparent `save()`.
    Personal opinion here: I could have used `super()`,
    but I prefer not to use `super()` when it requires arguments,
    say, to get a grandparent.
    I find Python 3's `super()` with no args is awesome to get the immediate parent.
    Anything else is too error-prone, and I find it ugly besides. YMMV.

// SEBASTIAN: IMHO it's actually Django's fault that it handles code reuse using inheritance and methods overriding
//      Wouldn't do the same thing, but it's your book and your opinion so I shall close my mouth :D

Let's run the tests!  All the unit tests pass:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test lists*]
[...]
Ran 31 tests in 0.082s

OK
----

But we still have something to do about our FTs:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test functional_tests.test_list_item_validation*]
[...]
FAIL: test_cannot_add_duplicate_items [...]
----------------------------------------------------------------------
[...]
AssertionError: '' != "You've already got this in your list"
+ You've already got this in your list
----

The error message isn't being displayed because Bootstrap requires form elements
with errors to have _another_ custom class, `is-invalid`.

// TODO: screenshot of devtools trying this out.

I'm starting to get a bit nervous about the amount of hackery
we're doing in our forms now, but let's try this out nonetheless.

We want this behaviour for both types of form really,
so it can go in the tests for the parent `ItemForm` class:

[role="sourcecode"]
.src/lists/tests/test_forms.py (ch15l019-1)
====
[source,python]
----
class ItemFormTest(TestCase):
    def test_form_item_input_has_placeholder_and_css_classes(self):
        [...]
    def test_form_validation_for_blank_items(self):
        [...]

    def test_invalid_form_has_bootstrap_is_invalid_css_class(self):
        form = ItemForm(data={"text": ""})
        self.assertFalse(form.is_valid())
        field = form.fields["text"]
        self.assertEqual(
            field.widget.attrs["class"],  # <1>
            "form-control form-control-lg is-invalid",
        )

    def test_form_save_handles_saving_to_a_list(self):
        [...]
----
====

<1> Here's where we inspect the `class` attribute on the input field widget


And here's how we can make it work, by overriding the `is_valid()` method:

[role="sourcecode"]
.src/lists/forms.py (ch15l019-2)
====
[source,python]
----
class ItemForm(forms.models.ModelForm):
    class Meta:
        [...]

    def is_valid(self):
        result = super().is_valid()  # <1>
        if not result:
            self.fields["text"].widget.attrs["class"] += " is-invalid"  # <2>
        return result  # <3>

    def save(self, for_list):
        [...]
----
====

<1> We make sure to call the parent `is_valid()` method first,
    so we can do all the normal built-in validation.

<2> Here's how we add the extra CSS class to our widget

<3> And we remember to return the result.

It's not _too_ bad, but as I say I'm getting nervous about the amount
of fiddly code in our forms classes.
Let's make a note on our scratchpad, and come back to it when our FT is passing paperhaps:

[role="scratchpad"]
*****
* review amount of hackery in forms.py
*****

Speaking of our FT, let's see how it does now?

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test functional_tests.test_list_item_validation*]
[...]
======================================================================
FAIL: test_cannot_add_empty_list_items (functional_tests.test_list_item_validat
ion.ItemValidationTest.test_cannot_add_empty_list_items)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "...goat-book/src/functional_tests/test_list_item_validation.py", line
47, in test_cannot_add_empty_list_items
    self.wait_for_row_in_list_table("2: Make tea")
  File "...goat-book/src/functional_tests/base.py", line 38, in
wait_for_row_in_list_table
    self.assertIn(row_text, [row.text for row in rows])
AssertionError: '2: Make tea' not found in ['1: Make tea', '2: Purchase milk']
----

Ooops what happened here?


==== A Little Digression on Queryset Ordering and String Representations

((("queryset ordering", id="queryset15")))
((("string representations", id="triprep15")))
Something seems to be going wrong with the ordering of our list items.
Debugging this with an FT is going to be slow,
so let's work at the unit test level.

// DAVID: But first, why not just look at what's actually going on by using the application?

We'll add a test that checks that list items are ordered
in the order they are inserted.
You'll have to forgive me if I jump straight to the right answer,
using intuition borne of long experience,
but I suspect that it might be sorting alphabetically based on list text instead
(what else would it sort by after all?),
so I'll pick some text values designed to test that hypothesis:

[role="sourcecode"]
.src/lists/tests/test_models.py (ch15l020)
====
[source,python]
----
class ListModelTest(TestCase):
    def test_get_absolute_url(self):
        [...]

    def test_list_items_order(self):
        list1 = List.objects.create()
        item1 = Item.objects.create(list=list1, text="i1")
        item2 = Item.objects.create(list=list1, text="item 2")
        item3 = Item.objects.create(list=list1, text="3")
        self.assertEqual(
            list1.item_set.all(),
            [item1, item2, item3],
        )
----
====

TIP: FTs are a slow feedback loop.
    Switch to unit tests when you want to drill down on edge case bugs.


That gives us a new failure, but it's not very readable:

----
AssertionError: <QuerySet [<Item: Item object (3)>, <Item[40 chars]2)>]> !=
[<Item: Item object (1)>, <Item: Item obj[29 chars](3)>]
----

We need a better string representation for our `Item` model.
Let's add another unit test:


NOTE: Ordinarily you would be wary of adding more failing tests
    when you already have some--it
    makes reading test output that much more complicated,
    and just generally makes you nervous.
    Will we ever get back to a working state?
    In this case, they're all quite simple tests, so I'm not worried.


[role="sourcecode"]
.src/lists/tests/test_models.py (ch15l021)
====
[source,python]
----
class ItemModelTest(TestCase):
    [...]
    def test_string_representation(self):
        item = Item(text="some text")
        self.assertEqual(str(item), "some text")
----
====

That gives us:

----
AssertionError: 'Item object (None)' != 'some text'
----

As well as the other two failures.  Let's start fixing them all now:


[role="sourcecode"]
.src/lists/models.py (ch15l022)
====
[source,python]
----
class Item(models.Model):
    [...]

    def __str__(self):
        return self.text
----
====

Now we're down to one failure, and the ordering test has a more readable
failure message:

----
AssertionError: <QuerySet [<Item: 3>, <Item: i1>, <Item: item 2>]> != [<Item:
i1>, <Item: item 2>, <Item: 3>]
----

That confirms our suspicion that the ordering was alphabetical.

We can fix that in the `class Meta`:

[role="sourcecode"]
.src/lists/models.py (ch15l023)
====
[source,python]
----
class Item(models.Model):
    [...]
    class Meta:
        ordering = ("id",)
        unique_together = ("list", "text")
----
====

Does that work?

----
AssertionError: <QuerySet [<Item: i1>, <Item: item 2>, <Item: 3>]> != [<Item:
i1>, <Item: item 2>, <Item: 3>]
----

Urp?  It has worked; you can see the items _are_ in the same order,
but the tests are confused.

I keep running into this problem actually--Django
QuerySets don't compare well with lists.
We can fix it by converting the QuerySet to a listfootnote:[You could also check out `assertSequenceEqual` from `unittest`, and
`assertQuerysetEqual` from Django's test tools,
although I confess when I last looked at `assertQuerysetEqual`
I was quite baffled...]
in our test:

[role="sourcecode"]
.src/lists/tests/test_models.py (ch15l024)
====
[source,python]
----
    self.assertEqual(
        list(list1.item_set.all()),
        [item1, item2, item3],
    )
----
====

// SEBASTIAN: If it's not too much of Django internals, maybe it's worth to mention
//      how models instances are compared (or at least leave a link for curious readers)
//      That said, if it wasn't shown before in the book
//      https://docs.djangoproject.com/en/5.2/topics/db/queries/#comparing-objects

That works; we get a fully passing unit test suite:

----
Ran 34 tests in 0.034s

OK
----

((("", startref="triprep15")))
((("", startref="queryset15")))

We do need a migration for that ordering change though:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py makemigrations*]
Migrations for 'lists':
  src/lists/migrations/0006_alter_item_options.py
    ~ Change Meta options on item
----
//ch15l025

And as a final check, we rerun 'all' the FTs:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test functional_tests*]
[...]
 ---------------------------------------------------------------------
Ran 5 tests in 19.048s

OK
----

Hooray! Time for a final commit:


[subs="specialcharacters,quotes"]
----
*git status*
*git add src*
*git commit -m "Add is-invalid css class, fix list item ordering"*
----
((("", startref="DITlist15")))


=== On The Tradeoffs of Django Modelforms, and Frameworks in General

Let's come back to our scratchpad item:

[role="scratchpad"]
*****
* review amount of hackery in forms.py
*****


Let's take a look at the current state of our forms classes.
We've got a real mix of presentation logic,
validation logic, and ORM/storage logic:


[role="sourcecode currentcontents"]
.src/lists/forms.py
====
[source,python]
----
class ItemForm(forms.models.ModelForm):
    class Meta:
        model = Item
        fields = ("text",)
        widgets = {
            "text": forms.widgets.TextInput(
                attrs={
                    "placeholder": "Enter a to-do item",  # <1>
                    "class": "form-control form-control-lg",  # <1>
                }
            ),
        }
        error_messages = {"text": {"required": EMPTY_ITEM_ERROR}}

    def is_valid(self):
        result = super().is_valid()
        if not result:
            self.fields["text"].widget.attrs["class"] += " is-invalid"  # <1>
        return result

    def save(self, for_list):  # <3>
        self.instance.list = for_list
        return super().save()


class ExistingListItemForm(ItemForm):
    def __init__(self, for_list, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.instance.list = for_list  # <3>

    def clean_text(self):
        text = self.cleaned_data["text"]
        if self.instance.list.item_set.filter(text=text).exists():  <2>
            raise forms.ValidationError(DUPLICATE_ITEM_ERROR)  <2>
        return text

    def save(self):
        return forms.models.ModelForm.save(self)  # <3>
----
====

<1> Presentation logic
<2> Validation logic
<3> ORM/storage logic

////
I'm also nervous about the fact that we're overriding parts of the forms
API, like `is_valid()`, and `save()`. Not only that, but;

[role="sourcecode currentcontents"]
.src/lists/forms.py
====
[source,python]
----
class ItemForm(forms.models.ModelForm):
    def save(self, for_list):  # <1>
        [...]

class ExistingListItemForm(ItemForm):
    def __init__(self, for_list, *args, **kwargs):  # <2>
        [...]
    def save(self):  # <3>
        return forms.models.ModelForm.save(self)
----
====

<1> Here we not only override the forms API method,
    but we actually _change_ the API, meaning that `ItemForm` no longer matches
    the normal forms API

<2> It's the same here where we override the constructor to add the `for_list` argument.

<3> And in this one, we change the `save()` API _again_,
    so the API isn't even consistent within our own inheritance hierarchy.

Without wanting to get all OO-nerdy, this is a violation of the
Liskov Substitution Principle, which basically says that subclasses should
look like their parents.footnote:[
Read a better write-up here: https://realpython.com/solid-principles-python/]
////

I think what's happened is that we've reached the limits of the Django forms framework's sweet spot.
`ModelForms` can be great _because_ they can do presentation, validation and database storage all in one go, so you can get a lot done without much code.
But once you want to customise the default behaviours for each of those things,
the code you _do_ end up writing starts to get hard to understand.

Let's see what things would look like if we tried to:
1. Moved the responsibility for presentation and the rendering of HTML back into the tamplate
2. Stop using `ModelForm` and do any database logic more explicitly,
  with less magic
// 3. Tried to remove some of the Liskov violations

==== Moving Presentation Logic Back Into the Template

So, rather than using the `{{ form.text }}` magic in our template,
let's bring back our hand-crafted HTML.
It'll be longer,
but at least all of our bootstrap classes will be in one place,
where we expect then, in the template:

[role="sourcecode"]
.src/lists/templates/base.html (ch15l025)
====
[source,diff]
----
@@ -16,10 +16,22 @@
           <h1 class="display-1 mb-4">{% block header_text %}{% endblock %}</h1>

           <form method="POST" action="{% block form_action %}{% endblock %}" >
-            {{ form.text }}
             {% csrf_token %}
+            <input  <1>
+              id="id_text"
+              name="text"
+              class="form-control  <2>
+                     form-control-lg
+                     {% if form.errors %}is-invalid{% endif %}"
+              placeholder="Enter a to-do item"
+              value="{{ form.text.value | default:'' }}"  <3>
+              aria-describedby="id_text_feedback"  <4>
+              required
+            />
             {% if form.errors %}
-              <div class="invalid-feedback">{{ form.errors.text }}</div>
+              <div id="id_text_feedback" class="invalid-feedback">  <4>
+                {{ form.errors.text.0 }}  <5>
+              </div>
             {% endif %}
           </form>
         </div>
----
====

<1> Here's our artisan `<input>` once again,
  and the most important custom setting will be its `class` attributes.

<2> As you can see, we can use conditionals even for providing additional `class` -es.footnote:[
    We've split the input tag across multiple lines so it fits nicely on the screen.
    If you've not seen that before, it may look a little weird,
    but I promise it is valid HTML.
    You don't have to use it if you don't like it though.]

<3> The `| default` "filter" is a way to avoid the string "None"
    from showing up as the value in our input field.

<4> We add an `id` to the error message,
    to be able to use `aria-describedby` on the input,
    as recommended in the Bootstrap docs;
    it makes the error message more accessible to screen readers.

<5> If you just try to use `form.errors.text` you'll see
    that Django injects a `<ul>` list,
    because the forms framework can report multiple errors for each field.
    We know we've only got one, so we can use use `form.errors.text.0`.

// TODO: show a screenshot of this bullet point earlier


NOTE:  Another flip-flop!
  We spent most of the last chapter switching from handcrafted HTML
  to having our form autogenerated by Django, and now we're switching back.
  It's a little frustrating,
  and I could have gone back and changed the book's outline to avoid the back and forth,
  but I prefer to show software development as it really is.
  We often try things out and end up changing our minds.
  Particularly with frameworks like Django,
  you can find yourself taking advantage of auto-generated shortcuts for as long as they work,
  but at some points you meet the limits of what the framework designers have anticipated,
  and it's time to go back to doing the work yourself.
  It doesn't mean you should always reinvent the wheel!

Now let's start tidying up our forms.
We can start by deleting the three presentation-layer tests from `ItemFormTest`,

[role="sourcecode"]
.src/lists/tests/test_forms.py (ch15l026)
====
[source,diff]
----
@@ -10,28 +10,11 @@ from lists.models import Item, List


 class ItemFormTest(TestCase):
-    def test_form_item_input_has_placeholder_and_css_classes(self):
-        form = ItemForm()
-
-        rendered = form.as_p()
-
-        self.assertIn('placeholder="Enter a to-do item"', rendered)
-        self.assertIn('class="form-control form-control-lg"', rendered)
-
     def test_form_validation_for_blank_items(self):
         form = ItemForm(data={"text": ""})
         self.assertFalse(form.is_valid())
         self.assertEqual(form.errors["text"], [EMPTY_ITEM_ERROR])

-    def test_invalid_form_has_bootstrap_is_invalid_css_class(self):
-        form = ItemForm(data={"text": ""})
-        self.assertFalse(form.is_valid())
-        field = form.fields["text"]
-        self.assertEqual(
-            field.widget.attrs["class"],
-            "form-control form-control-lg is-invalid",
-        )
-
     def test_form_save_handles_saving_to_a_list(self):
         mylist = List.objects.create()
         form = ItemForm(data={"text": "do me"})
@@ -42,11 +25,6 @@ class ItemFormTest(TestCase):


 class ExistingListItemFormTest(TestCase):
-    def test_form_renders_item_text_input(self):
-        list_ = List.objects.create()
-        form = ExistingListItemForm(for_list=list_)
-        self.assertIn('placeholder="Enter a to-do item"', form.as_p())
-
     def test_form_validation_for_blank_items(self):
         list_ = List.objects.create()
         form = ExistingListItemForm(for_list=list_, data={"text": ""})
----
====

And now we can remove all that custom logic from the base `ItemForm` class:


[role="sourcecode dofirst-ch15l027-1"]
.src/lists/forms.py (ch15l027)
====
[source,diff]
----
@@ -11,22 +11,8 @@ class ItemForm(forms.models.ModelForm):
     class Meta:
         model = Item
         fields = ("text",)
-        widgets = {
-            "text": forms.widgets.TextInput(
-                attrs={
-                    "placeholder": "Enter a to-do item",
-                    "class": "form-control form-control-lg",
-                }
-            ),
-        }
         error_messages = {"text": {"required": EMPTY_ITEM_ERROR}}

-    def is_valid(self):
-        result = super().is_valid()
-        if not result:
-            self.fields["text"].widget.attrs["class"] += " is-invalid"
-        return result
-
     def save(self, for_list):
         self.instance.list = for_list
         return super().save()
----
====


Deleting code yay!

At this point we should be down to 31 passing tests:

----
Ran 31 tests in 0.024s

OK
----

==== Switching Back to Simple Forms

Now let's change our forms away from being `ModelForms` and back to regular forms.

We'll keep the `save()` methods for now,
but we'll switch to using the ORM more explicitly,
rather than relying on the ModelForm magic:


[role="sourcecode"]
.src/lists/forms.py (ch15l028)
====
[source,diff]
----
@@ -7,27 +7,29 @@ EMPTY_ITEM_ERROR = "You can't have an empty list item"
 DUPLICATE_ITEM_ERROR = "You've already got this in your list"


-class ItemForm(forms.models.ModelForm):
-    class Meta:
-        model = Item
-        fields = ("text",)
-        error_messages = {"text": {"required": EMPTY_ITEM_ERROR}}
+class ItemForm(forms.Form):
+    text = forms.CharField(
+        error_messages={"required": EMPTY_ITEM_ERROR},
+        required=True,
+    )

     def save(self, for_list):
-        self.instance.list = for_list
-        return super().save()
+        return Item.objects.create(
+            list=for_list,
+            text=self.cleaned_data["text"],
+        )


 class ExistingListItemForm(ItemForm):
     def __init__(self, for_list, *args, **kwargs):
         super().__init__(*args, **kwargs)
-        self.instance.list = for_list
+        self._for_list = for_list

     def clean_text(self):
         text = self.cleaned_data["text"]
-        if self.instance.list.item_set.filter(text=text).exists():
+        if self._for_list.item_set.filter(text=text).exists():
             raise forms.ValidationError(DUPLICATE_ITEM_ERROR)
         return text

     def save(self):
-        return forms.models.ModelForm.save(self)
+        return super().save(for_list=self._for_list)
----
====

We should still have passing tests at this point:

----
Ran 31 tests in 0.026s

OK
----

And we're in a better place I think!

////

We still have the Liskov violations on the `__init__()` and `save()`,
but perhaps we can live with those for now.

TODO: start by addressing this in 15, ch14l034,
no need to pass the `for_list=` into the save() method.

Then the custom constructor
////


=== Wrapping Up: What We've Learned About Testing Django

((("class-based generic views (CBGVs)", "key tests and assertions")))
((("Django framework", "class-based generic views")))
We're now at a point where our app looks a lot more like a "standard" Django app,
and it implements the three common Django layers: models, forms, and views.
We no longer have any "training wheels&#x201d;-style tests,
and our code looks pretty much like code we'd be happy to see in a real app.

We have one unit test file for each of our key source code files.
Here's a recap of the biggest (and highest-level) one, _test_views_


[[what-to-test-in-views]]
.Wrap-up: What to Test in Views
******************************************************************************

By way of a recap, let's see an outline of all the test methods and main
assertions in our `test_views`. This isn't to say you should copy-paste these
exactly, more like a list of things you should at least consider testing.

[role="sourcecode skipme small-code"]
.src/lists/tests/test_views.py
====
[source,python]
----
class ListViewTest(TestCase):
  def test_uses_list_template(self):
      response = self.client.get(f'/lists/{mylist.id}/') #<1>
      self.assertTemplateUsed(response, 'list.html') #<2>
  def test_passes_correct_list_to_template(self):
      self.assertEqual(response.context['list'], correct_list) #<3>
  def test_displays_item_form(self):
      self.assertIsInstance(response.context['form'], ExistingListItemForm) #<4>
      self.assertContains(response, 'name="text"')
  def test_displays_only_items_for_that_list(self):
      self.assertContains(response, 'itemey 1') #<5>
      self.assertContains(response, 'itemey 2') #<5>
      self.assertNotContains(response, 'other list item 1') #<5>
  def test_can_save_a_POST_request_to_an_existing_list(self):
      self.assertEqual(Item.objects.count(), 1) #<6>
      self.assertEqual(new_item.text, 'A new item for an existing list') #<6>
  def test_POST_redirects_to_list_view(self):
      self.assertRedirects(response, f'/lists/{correct_list.id}/') #<6>
  def test_for_invalid_input_nothing_saved_to_db(self):
      self.assertEqual(Item.objects.count(), 0) #<6>
  def test_for_invalid_input_renders_list_template(self):
      self.assertEqual(response.status_code, 200)
      self.assertTemplateUsed(response, 'list.html') #<6>
  def test_for_invalid_input_passes_form_to_template(self):
      self.assertIsInstance(response.context['form'], ExistingListItemForm) #<7>
  def test_for_invalid_input_shows_error_on_page(self):
      self.assertContains(response, html.escape(EMPTY_ITEM_ERROR)) #<7>
  def test_duplicate_item_validation_errors_end_up_on_lists_page(self):
      self.assertContains(response, expected_error) #<7>
      self.assertTemplateUsed(response, 'list.html')
      self.assertEqual(Item.objects.all().count(), 1)
----
====

<1> Use the Django Test Client.

<2> Check the template used.

<3> Check that the received objects are the right ones.

<4> Check that any forms are of the correct class.

<5> Think about testing template logic:  any `for` or `if` might deserve a
    minimal test.

<6> For POST requests, make sure you test both the valid case and the invalid
    case.

<7> Optionally, sense-check that your form is rendered, and its errors are
    displayed.

// TODO: link
// If you'd like to see a worked example of a major refactor,
// enabled by these tests,
// check out 
// <<appendix_Django_Class-Based_Views>>

((("", startref="FDVduplicate15")))((("", startref="UIduplicate15")))

******************************************************************************

Next we'll try to make our data validation more friendly by using a bit
of client-side code.  Uh-oh, you know what that means...
