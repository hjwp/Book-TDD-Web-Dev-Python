Server-side authentication and the admin site
---------------------------------------------

Let's crack on with the server side of our new auth system.

NOTE: as with all new chapters, I'd really appreciate feedback.  How is 
the pace?  What do you think of the "left as an exercise for the reader"
bit at the end?


Mocking in Python
~~~~~~~~~~~~~~~~~

Here's the spiked version of our view:

[source,python]
----
def login(request):
    print('login view', file=sys.stderr)
    #user = PersonaAuthenticationBackend().authenticate(request.POST['assertion'])
    user = authenticate(assertion=request.POST['assertion'])
    if user is not None:
        auth_login(request, user)
    return redirect('/')
----

Our authenticate function is going to make calls out, over the internet, to
Mozilla's servers.  We don't want that to happen in our unit test, so we'll
want to mock out `authenticate`.

The popular 'mock' package was added to the standard libary as part of Python
3. It provides a magical object called a Mock, which is a bit like the sinon
spy objects we saw in the last chapter, only much cooler.  Check this out:

----
>>> from unittest.mock import Mock
>>> m = Mock()
>>> m.any_attribute
<Mock name='mock.any_attribute' id='140716305179152'>
>>> m.foo
<Mock name='mock.foo' id='140716297764112'>
>>> m.any_method()
<Mock name='mock.any_method()' id='140716331211856'>
>>> m.foo()
<Mock name='mock.foo()' id='140716331251600'>
>>> m.called
False
>>> m.foo.called
True
>>> m.bar.return_value = 1
>>> m.bar()
1
----


A mock object would be a pretty neat thing to use to mock out the authenticate
function, wouldn't it?  Here's how you can do that:

(I trust you to set up a tests folder, and do the imports in the dunderinit)


[role="sourcecode"]
.accounts/tests/test_views.py
[source,python]
----
from django.test import TestCase
from unittest.mock import patch


class LoginViewTest(TestCase):

    @patch('accounts.views.authenticate') #<1>
    def test_calls_authenticate_with_assertion_from_post(
        self, mock_authenticate #<2>
    ):
        mock_authenticate.return_value = None #<3>
        self.client.post('/accounts/login', {'assertion': 'assert this'})
        mock_authenticate.assert_called_once_with(assertion='assert this') #<4>
----

<1> The decorator called `patch` is a bit like the sinon `spy` function we 
    saw in the last chapter.  It lets you specify an object you want to "mock
    out". In this case we're mocking out the authenticate function, which we
    expect to be using in 'accounts/views.py'. 

<2> The decorator adds the mock object as an additional argument to the
    function it's applied to.

<3> We can then configure the mock so that it has certain behaviours. Having
    authenticate return None is the simplest, so we set the special
    `.return_value` attribute.  Otherwise it would return another mock, and
    that would probably confuse our view.

<4> Mocks can make assertions! in this case, they can check whether they were
    called, and what with
    

So what does that give us?

----
AttributeError: <module 'accounts.views' from
'/workspace/superlists/accounts/views.py'> does not have the attribute
'authenticate'
----

We tried to patch something that doesn't exist yet!  We need to import 
authenticate into our views.py:


[role="sourcecode"]
.accounts/views.py
[source,python]
----
from django.contrib.auth import authenticate
----

Now we get:

----
AssertionError: Expected 'authenticate' to be called once. Called 0 times.
----

Expected failure!  To implement it, we'll have to wire up a URL for our
login view:

[role="sourcecode"]
.superlists/urls.py
[source,python]
----
urlpatterns = patterns('',
    url(r'^$', 'lists.views.home_page', name='home'),
    url(r'^lists/', include('lists.urls')),
    url(r'^accounts/', include('accounts.urls')),
----


[role="sourcecode"]
.accounts/urls.py
[source,python]
----
from django.conf.urls import patterns, url

urlpatterns = patterns('',
    url(r'^-login$', 'accounts.views.login', name='login'),
)
----

Will a minimal view do anything?

[role="sourcecode"]
.accounts/views.py
[source,python]
----
def login():
    pass
----

Yep:

----
TypeError: login() takes 0 positional arguments but 1 was given
----

And so:

[role="sourcecode"]
.accounts/views.py
[source,python]
----
def login(request):
    pass
----

Then

----
ValueError: The view accounts.views.login didn't return an HttpResponse object.
----

[role="sourcecode"]
.accounts/views.py
[source,python]
----
from django.contrib.auth import authenticate
from django.http import HttpResponse

def login(request):
    return HttpResponse()
----

And we're back to:

----
AssertionError: Expected 'authenticate' to be called once. Called 0 times.
----

We try:

[role="sourcecode"]
.accounts/views.py
[source,python]
----
def login(request):
    authenticate()
    return HttpResponse()
----

And sure enough, we get:

----
AssertionError: Expected call: authenticate(assertion='assert this')
Actual call: authenticate()
----

And then we can fix that too:

[role="sourcecode"]
.accounts/views.py
[source,python]
----
def login(request):
    authenticate(assertion=request.POST['assertion'])
    return HttpResponse()
----


Fine, but our authenticate view also needs to call the Django auth.login 
function if authenticate returns a user, and then it needs to return 
something other than an empty response -- since this is an Ajax view,
it doesn't need to return HTML, just an "OK" string will do.  We'll need to
mock out the `auth_login` view as well:



[role="sourcecode"]
.lists/tests/test_views.py
[source,python]
----
from django.contrib.auth import get_user_model
from django.http import HttpRequest
from django.test import TestCase
from unittest.mock import patch

User = get_user_model() #<1>

from accounts.views import login
[...]

    @patch('accounts.views.authenticate')
    def test_returns_OK_when_user_found(
        self, mock_authenticate
    ):
        user = User.objects.create(email='a@b.com')
        user.backend = '' # required for auth_login to work
        mock_authenticate.return_value = user
        response = self.client.post('/accounts/login', {'assertion': 'a'})
        self.assertEqual(response.content.decode(), 'OK')


    @patch('accounts.views.auth_login')
    @patch('accounts.views.authenticate')
    def test_calls_auth_login_if_authenticate_returns_a_user(
        self, mock_authenticate, mock_auth_login
    ):
        request = HttpRequest()
        request.POST['assertion'] = 'asserted'
        mock_user = mock_authenticate.return_value
        login(request)
        mock_auth_login.assert_called_once_with(request, mock_user)


    @patch('accounts.views.auth_login')
    @patch('accounts.views.authenticate')
    def test_does_not_call_auth_login_if_authenticate_returns_None(
        self, mock_authenticate, mock_auth_login
    ):
        request = HttpRequest()
        request.POST['assertion'] = 'asserted'
        mock_authenticate.return_value = None
        login(request)
        self.assertFalse(mock_auth_login.called)
----

<1> I should explain this use of `get_user_model` from `django.contrib.auth`.
    Its job is to find the project's User model, and it works whether you're
    using the standard User model or a custom one (like we will be)

Notice that, for these tests, we go back to importing the view function
directly, and calling it with an `HttpRequest` we build manually.  The Django
Test Client does a bit too much magic, and for these highly mocky tests, we
need more control -- we need to check that `auth_login` was passed the same
`request` object that we called the view with, for example.

That gives us:

----
AttributeError: <module 'accounts.views' from
'/workspace/superlists/accounts/views.py'> does not have the attribute
'auth_login'
AttributeError: <module 'accounts.views' from
'/workspace/superlists/accounts/views.py'> does not have the attribute
'auth_login'
AssertionError: '' != 'OK'
+ OK
----

Adding the import takes us down to two failures:

[role="sourcecode"]
.accounts/views.py
[source,python]
----
from django.contrib.auth import login as auth_login
----

And we go through another couple of TDD cycles, until:


[role="sourcecode"]
.accounts/views.py
[source,python]
----
def login(request):
    user = authenticate(assertion=request.POST['assertion'])
    if user:
        auth_login(request, user)
    return HttpResponse('OK')
----



De-spiking our custom authentication back-end: mocking out an internet request
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Our custom authentication back-end is next!  Here's how it looked in the spike:


[source,python]
.accounts/authentication.py
----
import requests
from accounts.models import ListUser

class PersonaAuthenticationBackend(object):

    def authenticate(self, assertion):
        # Send the assertion to Mozilla's verifier service.
        data = {'assertion': assertion, 'audience': 'localhost'}
        print('sending to mozilla', data, file=sys.stderr)
        resp = requests.post('https://verifier.login.persona.org/verify', data=data)
        print('got', resp, file=sys.stderr)

        # Did the verifier respond?
        if resp.ok:
            # Parse the response
            verification_data = resp.json()

            # Check if the assertion was valid
            if verification_data['status'] == 'okay':
                email = verification_data['email']
                try:
                    return self.get_user(email)
                except ListUser.DoesNotExist:
                    return ListUser.objects.create(email=email)


    def get_user(self, email):
        return ListUser.objects.get(email=email)

----

Decoding this:

* We take an assertion and send it off to Mozilla using `requests.post`.
* We check its response code (`resp.ok`), and then check for a `status=okay` in
  the response JSON.
* We then extract an email address, and either find an existing user with that 
  address, or create a new one.

1 if = 1 more test
^^^^^^^^^^^^^^^^^^

A rule of thumb for these sorts of tests:  any `if` means an extra test, and
any `try/except` means an extra test, so this should be about 4 tests.  Let's
start with one:


[role="sourcecode"]
.accounts/tests/test_authentication.py
[source,python]
----
import json
from unittest.mock import Mock, patch
from django.test import TestCase

from accounts.authentication import (
    PERSONA_VERIFY_URL, DOMAIN,
    PersonaAuthenticationBackend, User
)

class AuthenticateTest(TestCase):

    @patch('accounts.authentication.requests.post')
    def test_sends_assertion_to_mozilla_with_domain(self, mock_post):
        backend = PersonaAuthenticationBackend()
        backend.authenticate('an assertion')
        mock_post.assert_called_once_with(
            PERSONA_VERIFY_URL,
            data={'assertion': 'an assertion', 'audience': DOMAIN}
        )
----

In 'authenticate.py' we'll just have a few placeholders:
 
[role="sourcecode"]
.accounts/authentication.py
[source,python]
----
import requests
from django.contrib.auth.models import get_user_model

PERSONA_VERIFY_URL = 'https://verifier.login.persona.org/verify'
DOMAIN = 'localhost'
User = get_user_model()


class PersonaAuthenticationBackend(object):

    def authenticate(self, assertion):
        pass


    def get_user(self, email):
        pass
----

TODO: mention need to add `requests` to 'requirements.txt'

Let's see how we get on!

----
AssertionError: Expected 'post' to be called once. Called 0 times.
----

And we can get that to passing in 3 steps:

[role="sourcecode"]
.accounts/authentication.py
[source,python]
----
    def authenticate(self, assertion):
        requests.post(
            PERSONA_VERIFY_URL,
            data={'assertion': assertion, 'audience': DOMAIN}
        )
----

Next test:


[role="sourcecode"]
.accounts/tests/test_authentication.py
[source,python]
----
    @patch('accounts.authentication.requests.post')
    def test_return_none_if_response_errors(self, mock_post):
        mock_response = mock_post.return_value
        mock_response.ok = False
        backend = PersonaAuthenticationBackend()

        user = backend.authenticate('an assertion')
        self.assertIsNone(user)
----

And that passes straight away -- we currently return None in all cases! 


patching at the Class level
^^^^^^^^^^^^^^^^^^^^^^^^^^^

The next test involves a bit of duplication -- let's apply the "3 strikes"
rule:


[role="sourcecode"]
.accounts/tests/test_authentication.py
[source,python]
----
mock_post = Mock() #<1>
@patch('accounts.authentication.requests.post', mock_post) #<1>
class AuthenticateTest(TestCase):

    def setUp(self):
        self.backend = PersonaAuthenticationBackend()
        self.mock_response = mock_post.return_value #<3>
        self.mock_response.ok = True #<3>

    def tearDown(self):
        mock_post.reset_mock() #<2>

    def test_sends_assertion_to_mozilla_with_domain(self):
        self.backend.authenticate('an assertion')
        mock_post.assert_called_once_with(
            PERSONA_VERIFY_URL,
            data={'assertion': 'an assertion', 'audience': DOMAIN}
        )


    def test_return_none_if_response_errors(self):
        self.mock_response.ok = False #<4>
        user = self.backend.authenticate('an assertion')
        self.assertIsNone(user)


    def test_returns_none_if_status_not_okay(self):
        self.mock_response.json.return_value = {'status': 'not okay!'} #<4>
        user = self.backend.authenticate('an assertion')
        self.assertIsNone(user)
----

<1> You can apply a `patch` at the class level as well, and that has the effect
    that every method in the class will have the patch applied.  You can also
    see a second usage pattern of the `patch` function, which is that you can
    pass it a specific mock object to use, rather than have it inject it as
    an extra argument to the functions it decorates.

<2> Because we're using the same mock object every time, we call a special
    method called `reset_mock`, which resets properties like `.called`, so
    that each test is independent

<3> We can now use the `setUp` function to prepare some useful variables which
    we're going to use in most of our tests.  

<4> Now each test is only adjusting the setup variables 'it' needs, rather than
    setting up a load of duplicated boilerplate -- it's more readable.


And that's all very well, but everything still passes!  Time for a failing 
test:


[role="sourcecode"]
.accounts/tests/test_authentication.py
[source,python]
----
    def test_finds_existing_user_with_email(self):
        self.mock_response.json.return_value = {'status': 'okay', 'email': 'a@b.com'}
        self.backend.get_user = Mock()
        mock_user = self.backend.get_user.return_value
        user = self.backend.authenticate('an assertion')
        self.assertEqual(user, mock_user)
----

Hooray!  A fail:

----
AssertionError: None != <Mock name='mock()' id='139758452629392'>
----

Let's code:

----
    def authenticate(self, assertion):
        requests.post(
            PERSONA_VERIFY_URL,
            data={'assertion': assertion, 'audience': DOMAIN}
        )
        return self.get_user()
----

That gets our new test passing, but other tests fail:

----
TypeError: get_user() missing 1 required positional argument: 'email'
----

So we can "cheat":

----
        return self.get_user('bla')
----


And now we need to write a new unit test for the `self.get_user` call:


----
    def test_calls_get_user_with_email(self):
        self.mock_response.json.return_value = {'status': 'okay', 'email': 'a@b.com'}
        self.backend.get_user = Mock()
        self.backend.authenticate('an assertion')
        self.backend.get_user.assert_called_once_with('a@b.com')
----

Right:

----
AssertionError: Expected call: mock('a@b.com')
Actual call: mock('bla')
----

And so

-----
    def authenticate(self, assertion):
        response = requests.post(
            PERSONA_VERIFY_URL,
            data={'assertion': assertion, 'audience': DOMAIN}
        )
        email = response.json()['email']
        return self.get_user(email)
-----

But that breaks a couple of the old tests:

-----
    email = response.json()['email']
KeyError: 'email'
----

We need some more common setup:

----
    def setUp(self):
        self.backend = PersonaAuthenticationBackend()
        self.mock_response = mock_post.return_value
        self.mock_response.ok = True
        self.mock_response.json.return_value = {
            'status': 'okay', 'email': 'a@b.com'
        }

    [...]

    def test_returns_none_if_status_not_okay(self):
        self.mock_response.json.return_value = {'status': 'not okay!'}
        [...]

    def test_calls_get_user_with_email(self):
        self.backend.get_user = Mock()
        [...]


    def test_finds_existing_user_with_email(self):
        self.backend.get_user = Mock()
        [...]
----


Now we're down to just one error:

----
ERROR: test_returns_none_if_status_not_okay (accounts.tests.test_authentication.AuthenticateTest)
    email = response.json()['email']
KeyError: 'email'
----

And that one we fix in the code:

----
    if response.json()['status'] == 'okay':
        email = response.json()['email']
        return self.get_user(email)
----

Testing exception handling
^^^^^^^^^^^^^^^^^^^^^^^^^^

Last test:

----
    def test_creates_new_user_if_required(self):
        def raise_no_user_error(_):
            raise User.DoesNotExist()
        self.backend.get_user = raise_no_user_error
        user = self.backend.authenticate('an assertion')
        new_user = User.objects.all()[0]
        self.assertEqual(user, new_user)
        self.assertEqual(user.email, 'a@b.com')
----


This is another common mocking technique: patching out a function to raise
an error. 

----
    def authenticate(self, assertion):
        response = requests.post(
            PERSONA_VERIFY_URL,
            data={'assertion': assertion, 'audience': DOMAIN}
        )
        if response.json()['status'] == 'okay':
            email = response.json()['email']
            try:
                return self.get_user(email)
            except User.DoesNotExist:
                return User.objects.create(email=email)
----

That leaves one puzzler:  how come our `test_return_none_if_response_errors`
isn't failing?  It took me a while to figure it out, but it's because 
`self.get_user`, being currently a placeholder function with a `pass`, is 
returning None.  It's my own fault for writing even placeholder code without
tests.  The testing goat is angry!

Let's get some tests for `get_user` in asap then:


----
class GetUserTest(TestCase):

    def test_get_user_gets_user_from_database(self):
        actual_user = User.objects.create(email='a@b.com')
        backend = PersonaAuthenticationBackend()
        found_user = backend.get_user('a@b.com')
        self.assertEqual(found_user, actual_user)

----

That gives

----
AssertionError: None != <User: >
----

And so:

----
    def get_user(self, email):
        return User.objects.get(email=email)
----

And now our our response error test is failing as it should:

----
FAIL: test_return_none_if_response_errors
(accounts.tests.test_authentication.AuthenticateTest)
[...]
AssertionError: <User: > is not None
----

There we go! I prefer an early return rather than another nested if:

----

    def authenticate(self, assertion):
        response = requests.post(
            PERSONA_VERIFY_URL,
            data={'assertion': assertion, 'audience': DOMAIN}
        )
        if not response.ok:
            return
        if response.json()['status'] == 'okay':
            [...]
----

And I 'think' we have ourselves an authentication backend.  It won't work yet
though, because we need to define our custom user model next.



A minimal custom user model
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Django's built-in user model makes all sorts of assumptions about what
information you want to track about users, from explicitly recording
first name and last name, to forcing you to use a username.   I'm a great
believer in not storing information about users unless you absolutely must,
so a User model that records an email address and nothing else sounds good to
me!

[role="sourcecode"]
.accounts/tests/test_models.py
[source,python]
----
from django.test import TestCase
from django.contrib.auth import get_user_model

User = get_user_model()

class UserModelTest(TestCase):

    def test_user_is_valid_with_email_only(self):
        user = User(email='a@b.com')
        user.full_clean() # should not raise
-----

That gives us an expected failure:

----
django.core.exceptions.ValidationError: {'password': ['This field cannot be
blank.'], 'username': ['This field cannot be blank.']}
----

Password?  Username?  Bah!  How about this?


[role="sourcecode"]
.accounts/models.py
[source,python]
----
from django.db import models

class User(models.Model):
    email = models.EmailField()
----

And we wire it up inside 'settings.py':

[role="sourcecode"]
.superlists/settings.py
[source,python]
----
AUTH_USER_MODEL = 'accounts.User'
----

Now Django tells us off because it wants a couple of bits of metadata on any
custom user model:

----
AttributeError: type object 'User' has no attribute 'USERNAME_FIELD'
----

So:

----
class User(models.Model):
    email = models.EmailField()
    USERNAME_FIELD = 'email'
----

And:

----
AttributeError: type object 'User' has no attribute 'REQUIRED_FIELDS'
----

Sigh.  Come on, Django, it's only got one field, you should be able to figure
out the answers to these questions for yourself.  Here you go:

----
class User(models.Model):
    email = models.EmailField()
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ()
----

What now?

----
accounts.user: The USERNAME_FIELD must be unique. Add unique=True to the field parameters.
----

I'll do one better! Let's make the email field into the primary key, and
remove the auto-generated `id` column:

----
class User(models.Model):
    email = models.EmailField(unique=True)
----

That gets our tests running.  We'll write a test for this feature
anyway, just as a form of documentation:

----
    def test_email_is_primary_key(self):
        user = User()
        self.assertFalse(hasattr(user, 'id'))
----

And just to double-check, we can temporarily switch back the `EmailField` to
using `unique=True` instead of `primary_key=True`, just to see the test fail

NOTE: People sometimes say that your tests are a form of documentation for your
code -- they express what your requirements are of a particular class.
Sometimes, if you forget why you've done something a particular way, going back
and looking at the tests will give you the answer.  That's why it's important
to give your tests explicit, verbose method names.

Now we get an unexpected failure:

----
ERROR: test_returns_OK_when_user_found (accounts.tests.test_views.LoginViewTest)
  File "/worskpace/superlists/accounts/tests/test_views.py", line 29, in test_returns_OK_when_user_found
    response = self.client.post('/accounts/login', {'assertion': 'a'})
[...]
  File "/worskpace/superlists/accounts/views.py", line 8, in login
    auth_login(request, user)
[...]
  File "/usr/local/lib/python3.3/dist-packages/django/contrib/auth/models.py", line 31, in update_last_login
    user.save(update_fields=['last_login'])
  File "/usr/local/lib/python3.3/dist-packages/django/db/models/base.py", line 526, in save
    % ', '.join(non_model_fields))
ValueError: The following fields do not exist in this model or are m2m fields: last_login
----

Ah.  Looks like Django is going to insist on us having a `last_login` field on
our User model too.  Oh well.

----
from django.db import models
from django.utils import timezone

class User(models.Model):
    email = models.EmailField(primary_key=True)
    last_login = models.DateTimeField(default=timezone.now)
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ()
----

Right!  That works!

----
$ python3 manage.py test accounts
Creating test database for alias 'default'...
...............
 ---------------------------------------------------------------------
Ran 15 tests in 0.020s

OK
----




The moment of truth:  will the FT pass?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


I think we're just about ready to try our functional test!  Let's just wire 
up our base template.  Firstly, it needs to show a different message for
logged-in and non-logged-in users:

[role="sourcecode"]
.lists/templates/base.html
[source,html]
----
<nav class="navbar navbar-default" role="navigation">
    <a class="navbar-brand" href="/">Superlists</a>
    {% if user.email %}
        <a class="btn navbar-btn navbar-right" id="id_logout" href="#">Log out</a>
        <span class="navbar-text navbar-right">Logged in as {{ user.email }}</span>
    {% else %}
        <a class="btn navbar-btn navbar-right" id="id_login" href="#">Sign in</a>
    {% endif %}
</nav>
----

TODO: add check for email address in navbar to FT

Lovely.  Then we wire up our various context variables for the call to
`initialize`:

[role="sourcecode"]
.lists/templates/base.html
[source,html]
----
<script>
    $(document).ready( function () {
        var user = "{{ user.email }}" || null;
        var token = "{{ csrf_token }}";
        var urls = {
            login: "{% url 'login' %}",
            logout: "TODO",
        };
        Superlists.Accounts.initialize(navigator, user, token, urls);
    });
</script>
----

So how does our FT get along?

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.LoginTest*]
Creating test database for alias 'default'...

.
 ---------------------------------------------------------------------
Ran 1 test in 26.382s

OK
Destroying test database for alias 'default'...
-----

Woohoo!

I've been waiting to do a commit up until this point, just to make sure
everything works.  At this point, you could make a series of separate 
commits -- one for the login view, one for the auth backend, one for 
the user model, one for wiring up the template.  Or you could decide that,
since they're all inter-related, and none will work without the others,
you may as well just have one big commit:

[subs="specialcharacters,quotes"]
----
$ *git status*
$ *git add .*
$ *git diff --staged*
$ *git commit -am "Custom login using Persona"*
----


Extending our Ft to test logout
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We'll extend our FT to check that the logged-in status persists, ie it's 
not just something we set in JavaScript on the client side, but the server
knows about it too and will maintain the logged-in state if she refreshes
the page. We'll also test that she can log out.

I started off writing code a bit like this:

[role="sourcecode"]
.lists/functional_tests/test_login.py
[source,python]
----
        # Refreshing the page, she sees it's a real session login,
        # not just a one-off for that page
        self.browser.refresh()
        self.wait_for_element_with_id('id_logout')
        navbar = self.browser.find_element_by_css_selector('.navbar')
        self.assertIn(TEST_EMAIL, navbar.text)
----

And, after 4 repetitions of very similar code, a helper function suggested
itself:


[role="sourcecode"]
.lists/functional_tests/test_login.py
[source,python]
----
    def assert_logged_in(self, logged_in=True):
        if logged_in:
            self.wait_for_element_with_id('id_logout')
            navbar = self.browser.find_element_by_css_selector('.navbar')
            self.assertIn(TEST_EMAIL, navbar.text)
        else:
            self.wait_for_element_with_id('id_login')
            navbar = self.browser.find_element_by_css_selector('.navbar')
            self.assertNotIn(TEST_EMAIL, navbar.text)
----

And I extended the FT like this:

[role="sourcecode"]
.lists/functional_tests/test_login.py
[source,python]
----
        [...]
        # The Persona window closes
        self.switch_to_new_window('To-Do')

        # She can see that she is logged in
        self.assert_logged_in()

        # Refreshing the page, she sees it's a real session login,
        # not just a one-off for that page
        self.browser.refresh()
        self.assert_logged_in()

        # Terrified of this new feature, she reflexively clicks "logout"
        self.browser.find_element_by_id('id_logout').click()
        self.assert_logged_in(False)

        # The "logged out" status also persists after a refresh
        self.browser.refresh()
        self.assert_logged_in(False)
----

And that fails at the point we expect, the logout button doesn't work:

----
  File "/workspace/superlists/functional_tests/tests/test_login.py", line 67, in test_login_with_persona
    self.wait_for_element_with_id('id_login')
  File "/workspace/superlists/functional_tests/tests/test_login.py", line 80, in assert_logged_in
    self.wait_for_element_with_id('id_login')
  File "/workspace/superlists/functional_tests/tests/test_login.py", line 27, in wait_for_element_with_id
    lambda b: b.find_element_by_id(element_id)
  File "/usr/local/lib/python3.3/dist-packages/selenium/webdriver/support/wait.py", line 71, in until
    raise TimeoutException(message)
selenium.common.exceptions.TimeoutException: Message: '' 
[...]
----


The implementation is very simple:  we can use Django's 
https://docs.djangoproject.com/en/1.5/topics/auth/default/#module-django.contrib.auth.views[built-in
logout view], which clears down the user's session and redirects them
to a page of our choice:

[role="sourcecode"]
.accounts/urls.py
[source,python]
----
urlpatterns = patterns('',
    url(r'^login$', 'accounts.views.login', name='login'),
    url(r'^logout$', 'django.contrib.auth.views.logout', {'next_page': '/'}, name='logout'),
)
----

And in base.html, we just make the logout into a normal URL link:

[role="sourcecode"]
.lists/templates.base.html
[source,python]
----
<a class="btn navbar-btn navbar-right" id="id_logout" href="{% url 'logout' %}">Log out</>
----

TODO: investigate persona re-logging itself in if you don't hit refresh... 
think I need to fully switch to the "goldilocks" api, or manually call logout
before login...



Allowing users to save a list, and skipping the login process for future fts
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

From now on, we're probably going to have a lot of tests that are going to
require having a logged-in user.  Rather than making each test go through
the (time-consuming) Persona dialog, it would be good to be able to skip that
part.

This is about separation of concerns.  Functional tests aren't like unit tests,
in that they don't usually have a single assertion. But, conceptually, they 
should be testing a single thing.  There's no need for every single FT to test
the login/logout mechanisms. If we can figure out a way to "cheat" and skip that
part, we'll spend less time waiting for duplicated test paths.

TIP: Don't overdo de-duplication in FTs.  One of the benefits of an FT is that
it can catch strange and unpredictable interactions between different parts of
your application.

It's quite common for a user to return to a site and still have a cookie that 
means they are "pre-authenticated", so this isn't an unrealistic cheat at all.
Here's how you can set it up:

[roly="sourcecode"]
.functional_tests/tests/test_my_lists.py
[source,python]
----
from django.conf import settings
from django.contrib.auth import BACKEND_SESSION_KEY, SESSION_KEY, get_user_model
User = get_user_model()
from django.contrib.sessions.backends.db import SessionStore

from .base import FunctionalTest


class MyListsTest(FunctionalTest):

    def create_pre_authenticated_session(self):
        user = User.objects.create(email='edith@email.com')
        session = SessionStore()
        session[SESSION_KEY] = user.pk
        session[BACKEND_SESSION_KEY] = settings.AUTHENTICATION_BACKENDS[0]
        session.save()
        ## to set a cookie we need to first visit the domain.
        ## 404 pages load the quickest!
        self.browser.get(self.server_url + "/404_no_such_url/")
        self.browser.add_cookie(dict(
            name=settings.SESSION_COOKIE_NAME,
            value=session.session_key,
            path='/',
        ))
----

Note that this only works because we're using `LiveServerTestCase`, so the
User and Session objects we create will end up in the same database as the
test server.  When we switch to trying to run this against the staging server,
we'll need to use a different technique.  More on this in future chapters.

.On test fixtures
*******************************************************************************
When we pre-populate the database with test data, as we've done here with the
User object and its associated Session object, what we're doing is setting up
a "test fixture".

Django comes with built-in support for saving database objects as JSON (using
the `manage.py dumpdata`), and automatically loading them in your test runs 
using the `fixtures` class attribute on `TestCase`.

More and more people are starting 
http://blog.muhuk.com/2012/04/09/carl-meyers-testing-talk-at-pycon-2012.html[to
say]: don't use JSON fixtures.  They're a nightmare to maintain when your model
changes.  Instead, if you can, load data directly using the Django ORM, or look
into a tool like https://factoryboy.readthedocs.org/en/latest/[factory_boy]
*******************************************************************************


[roly="sourcecode"]
.functional_tests/tests/test_my_lists.py
[source,python]
----
    def test_logged_in_users_lists_are_saved_as_my_lists(self):
        # Edith is a logged-in user
        self.create_pre_authenticated_session()

        # She goes to the home page and starts a list
        self.browser.get(self.server_url)
        self.get_item_input_box().send_keys('Reticulate splines\n')
        self.get_item_input_box().send_keys('Immanentize eschaton\n')
        first_list_url = self.browser.current_url

        # She notices a "My lists" link, for the first time.
        self.browser.find_element_by_link_text('My lists').click()

        # She sees that her list is in there, named according to its
        # first list item
        self.browser.find_element_by_link_text('Reticulate splines').click()
        self.assertEqual(self.browser.current_url, first_list_url)

        # She decides to start another list, just to see
        self.browser.get(self.server_url)
        self.get_item_input_box().send_keys('Click cows\n')
        second_list_url = self.browser.current_url

        # Under "my lists", her new list appears
        self.browser.find_element_by_link_text('My lists').click()
        self.browser.find_element_by_link_text('Click cows').click()
        self.assertEqual(self.browser.current_url, second_list_url)

        # She logs out.  The "My lists" option disappears
        self.browser.find_element_by_id('id_logout').click()
        self.assertEqual(
            self.browser.find_elements_by_link_text('My lists'),
            []
        )
----

And that gets us:

----
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate element: {"method":"link text","selector":"My lists"}' ; Stacktrace: 
----


To implement this, we'll need:

* A new template 'my_lists.html', and some tweaks to 'base.html'
* An optional foreign key on the List model
* To change the `new_list` view, with optional addition of `list_.owner` from
  `request.user`. 
* And/or change `ItemForm.save` to take the `request.user`
    * A possible refactor could be: rename `ItemForm` to `NewListItemForm`.
    Maybe its `save` method doesn't need the `for_list` arg after all?
* A new view + urls entry in 'accounts', `my_lists`.

Rather than spell everything out exactly for you, I thought I would just show
you the new unit tests I had to write:

[role="sourcecode"]
.lists/tests.py
[source,python]
----
class MyListsViewTest(TestCase):
    def test_uses_my_lists_template(self):
    def test_passes_user_in_context(self):
    def test_template_displays_lists_using_first_item_text(self):

class ItemFormTest(TestCase):
    def test_form_save_sets_owner_if_real_user(self):
    def test_form_save_ignores_anon_user(self):

class ListModelTest(TestCase):
    def test_get_absolute_url(self):
    def test_can_optionally_set_owner(self):

class NewListTest(TestCase):
    def test_POST_from_real_user_sets_owner_on_list(self):
----

Can you come up with an implementation on your own?  The FT should tell
you once everything works OK.  Then, compare yourself against my implementation
https://github.com/hjwp/book-example/tree/chapter_15[on GitHub]

Here's a couple of tips:

* You can't really use `self.client.login` in the view tests.  I called the 
  raw view function instead

* You'll probably find the `AnonymousUser` class useful, it's at
  `django.contrib.auth.models`

* You'll probably need to add a new `{% block %}` to the 'base.html' template.


Wrap-up (under construction)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Use mock, but use it sparingly
* Dedupe your FTs: every single FT doesn't need to test every single feature.
  But be aware that FTs are there to catch strange and unpredictable between
  features.  Try to keep your "cheats" for deduplication reasonably plausible
  in the real world.


TODO: deploy.  Adapt FTs to be able to create users on the staging server
TODO: test what happens if Persona is down? Show how to test?


