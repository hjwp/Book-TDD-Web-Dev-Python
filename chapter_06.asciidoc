[[chapter-6]]
Working Incrementally
---------------------

In this chapter we're going to address the problems we discovered at the end
of the last chapter. In the immediate, the problem of cleaning up after
functional test runs. Later, the more general problem, which is that
our design only allows for one global list.  I'll demonstrate a critical
TDD technique:  how to adapt existing code using an incremental, step-by-step
process which takes you from working state to working state. Testing Goat, not
Refactoring Cat.


Ensuring Test Isolation in Functional Tests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

((("functional tests/testing (FT)","cleanup", id="ix_FTcleanup", range="startofrange")))
((("functional tests/testing (FT)","isolation in", id="ix_FTisolation", range="startofrange")))
We ended the last chapter with a classic testing problem:  how to ensure
'isolation' between tests.  Each run of our functional tests was leaving list
items lying around in the database, and that would interfere with the test
results when you next ran the tests.

When we run 'unit' tests, the Django test runner automatically creates a brand
new test database (separate from the real one), which it can safely reset
before each individual test is run, and then throw away at the end.  But our
functional tests currently run against the "real" database, 'db.sqlite3'.

One way to tackle this would be to "roll our own" solution, and add some code
to 'functional_tests.py' which would do the cleaning up. The `setUp` and
`tearDown` methods are perfect for this sort of thing.

((("LiveServerTestCase")))
((("Django", "LiveServerTestCase")))
((("Django", "functional tests (FT) in", see="functional tests/testing (FT)")))
Since Django 1.4 though, there's a new class called `LiveServerTestCase` which
can do this work for you. It will automatically create a test database (just
like in a unit test run), and start up a development server for the functional
tests to run against. Although as a tool it has some limitations which we'll
need to work around later, it's dead useful at this stage, so let's check it
out.

`LiveServerTestCase` expects to be run by the Django test runner using
'manage.py'. As of Django 1.6, the test runner will find any files whose name
begins with 'test'.  To keep things neat and tidy, let's make a folder for
our functional tests, so that it looks a bit like an app. All Django needs is
for it to be a valid Python package directory (i.e., one with a '\_\_init__.py'
in it):

[subs=""]
----
$ <strong>mkdir functional_tests</strong>
$ <strong>touch functional_tests/__init__.py</strong>
----

Then we 'move' our functional tests, from being a standalone file called
'functional_tests.py', to being the 'tests.py' of the `functional_tests` app.
We use *`git mv`* so that Git notices that we've moved the file:


[subs=""]
----
$ <strong>git mv functional_tests.py functional_tests/tests.py</strong>
$ <strong>git status</strong> # shows the rename to functional_tests/tests.py and __init__.py
----

At this point your directory tree should look like this:

----
.
├── db.sqlite3
├── functional_tests
│   ├── __init__.py
│   └── tests.py
├── lists
│   ├── admin.py
│   ├── apps.py
│   ├── __init__.py
│   ├── migrations
│   │   ├── 0001_initial.py
│   │   ├── 0002_item_text.py
│   │   ├── __init__.py
│   │   └── __pycache__
│   ├── models.py
│   ├── __pycache__
│   ├── templates
│   │   └── home.html
│   ├── tests.py
│   └── views.py
├── manage.py
└── superlists
    ├── __init__.py
    ├── __pycache__
    ├── settings.py
    ├── urls.py
    └── wsgi.py
----

'functional_tests.py' is gone, and has turned into 'functional_tests/tests.py'.
Now, whenever we want to run our functional tests, instead of running `python
functional_tests.py`, we will use `python manage.py test functional_tests`.

NOTE: You could mix your functional tests into the tests for the `lists` app.
    I tend to prefer to keep them separate, because functional tests usually
    have cross-cutting concerns that run across different apps.  FTs are meant
    to see things from the point of view of your users, and your users don't
    care about how you've split work between different apps!


Now let's edit 'functional_tests/tests.py' and change our `NewVisitorTest`
class to make it use `LiveServerTestCase`:


[role="sourcecode"]
.functional_tests/tests.py (ch06l001)
[source,python]
----
from django.test import LiveServerTestCase
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

class NewVisitorTest(LiveServerTestCase):

    def setUp(self):
        [...]
----

Next, instead of hardcoding the visit to localhost port 8000, `LiveServerTestCase`
gives us an attribute called `live_server_url`:


[role="dofirst-ch06l003 sourcecode"]
.functional_tests/tests.py (ch06l002)
[source,python]
----
    def test_can_start_a_list_and_retrieve_it_later(self):
        # Edith has heard about a cool new online to-do app. She goes
        # to check out its homepage
        self.browser.get(self.live_server_url)
----

We can also remove the `if __name__ == '__main__'` from the end if we want,
since we'll be using the Django test runner to launch the FT.

Now we are able to run our functional tests using the Django test runner, by
telling it to run just the tests for our new `functional_tests` app:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests*]
Creating test database for alias 'default'...
F
======================================================================
FAIL: test_can_start_a_list_and_retrieve_it_later
(functional_tests.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/.../superlists/functional_tests/tests.py", line 61, in
test_can_start_a_list_and_retrieve_it_later
    self.fail('Finish the test!')
AssertionError: Finish the test!

 ---------------------------------------------------------------------
Ran 1 test in 6.378s

FAILED (failures=1)
Destroying test database for alias 'default'...
----

The FT gets through to the `self.fail`, just like it did before the refactor.
You'll also notice that if you run the tests a second time, there aren't any
old list items lying around from the previous test--it has cleaned up after
itself.  Success! We should commit it as an atomic change:

[subs=""]
----
$ <strong>git status</strong> # functional_tests.py renamed + modified, new __init__.py
$ <strong>git add functional_tests</strong>
$ <strong>git diff --staged -M</strong>
$ <strong>git commit</strong>  # msg eg "make functional_tests an app, use LiveServerTestCase"
----

The `-M` flag on the `git diff` is a useful one. It means "detect moves", so it
will notice that 'functional_tests.py' and 'functional_tests/tests.py' are the
same file, and show you a more sensible diff (try it without the flag!).
(((range="endofrange", startref="ix_FTcleanup")))
(((range="endofrange", startref="ix_FTisolation")))


Running Just the Unit Tests
^^^^^^^^^^^^^^^^^^^^^^^^^^^

((("functional tests/testing (FT)", "running unit tests only")))
Now if we run `manage.py test`, Django will run both the functional and the
unit tests:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test*]
Creating test database for alias 'default'...
......F
======================================================================
FAIL: test_can_start_a_list_and_retrieve_it_later
[...]
AssertionError: Finish the test!

 ---------------------------------------------------------------------
Ran 7 tests in 3.132s

FAILED (failures=1)
Destroying test database for alias 'default'...
----

In order to run just the unit tests, we can specify that we want to
only run the tests for the `lists` app:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test lists*]
Creating test database for alias 'default'...
......
 ---------------------------------------------------------------------
Ran 6 tests in 0.009s

OK
Destroying test database for alias 'default'...
----



.Useful Commands Updated
*******************************************************************************

To run the functional tests::
    *`python manage.py test functional_tests`*

To run the unit tests::
    *`python manage.py test lists`*

What to do if I say "run the tests", and you're not sure which ones I mean?
Have another look at the flowchart at the end of <<chapter-4>>, and try and figure
out where we are.  As a rule of thumb, we usually only run the functional tests
once all the unit tests are passing, so if in doubt, try both!

*******************************************************************************

Now let's move on to thinking about how we want support for multiple lists to
work.  Currently the FT (which is the closest we have to a design document)
says this:

[role="sourcecode currentcontents"]
.functional_tests/tests.py
[source,python]
----
    # Edith wonders whether the site will remember her list. Then she sees
    # that the site has generated a unique URL for her -- there is some
    # explanatory text to that effect.
    self.fail('Finish the test!')

    # She visits that URL - her to-do list is still there.

    # Satisfied, she goes back to sleep
----

But really we want to expand on this, by saying that different users
don't see each other's lists, and each get their own URL as a way of
going back to their saved lists.  Let's think about this a bit more.


Small Design When Necessary
~~~~~~~~~~~~~~~~~~~~~~~~~~~

((("agile movement in software development")))
((("Big Design Up Front")))
TDD is closely associated with the agile movement in software development,
which includes a reaction against 'Big Design Up Front' the
traditional software engineering practice whereby, after a lengthy requirements
gathering exercise, there is an equally lengthy design stage where the
software is planned out on paper. The agile philosophy is that you learn more
from solving problems in practice than in theory, especially when you confront
your application with real users as soon as possible. Instead of a long
up-front design phase, we try and put a 'minimum viable application' out
there early, and let the design evolve gradually based on feedback from
real-world usage.

((("minimum viable application")))
But that doesn't mean that thinking about design is outright banned! In the
last chapter we saw how just blundering ahead without thinking can 'eventually'
get us to the right answer, but often a little thinking about design can help
us get there faster. So, let's think about our minimum viable lists app, and
what kind of design we'll need to deliver it.

* We want each user to be able to store their own list--at least one, for now.
* A list is made up of several items, whose primary attribute is a bit of
descriptive text.
* We need to save lists from one visit to the next.  For now, we can give
each user a unique URL for their list.  Later on we may want some way of
automatically recognising users and showing them their lists.

To deliver the "for now" items, it sounds like we're going to store
lists and their items in a database.  Each list will have a unique URL,
and each list item will be a bit of descriptive text, associated with a
particular list.

YAGNI!
^^^^^^

((("YAGNI")))
Once you start thinking about design, it can be hard to stop. All sorts of
other thoughts are occurring to us--we might want to give each list
a name or title, we might want to recognise users using usernames and
passwords, we might want to add a longer notes field as well as short
descriptions to our list, we might want to store some kind of ordering, and so
on.  But we obey another tenet of the agile gospel:  "YAGNI" (pronounced
yag-knee), which stands for "You aint gonna need it!"  As software
developers, we have fun creating things, and sometimes it's hard to resist
the urge to build things just because an idea occurred to us and we 'might'
need it.  The trouble is that more often than not, no matter how cool the idea
was, you 'won't' end up using it. Instead you have a load of unused code,
adding to the complexity of your application. YAGNI is the mantra we use to
resist our overenthusiastic creative urges.


REST
^^^^

We have an idea of the data structure we want--the Model part of
Model-View-Controller (MVC).  What about the View and Controller parts?
How should the user interact with Lists and their Items using a web browser?

((("REST (Representational Site Transfer)")))
Representational State Transfer (REST) is an approach to web design that's
usually used to guide the design of web-based APIs. When designing a
user-facing site, it's not possible to stick 'strictly' to the REST rules,
but they still provide some useful inspiration (skip ahead to 
<<appendix-rest-api-backend>> if you want to see a real REST API).

REST suggests that we have a URL structure that matches our data structure,
in this case lists and list items.  Each list can have its own URL:

[role="skipme"]
----
    /lists/<list identifier>/
----

That will fulfill the requirement we've specified in our FT. To view a list, we
use a GET request (a normal browser visit to the page).

To create a brand new list, we'll have a special URL that accepts POST
requests:

[role="skipme"]
----
    /lists/new
----

To add a new item to an existing list, we'll have a separate URL, to which
we can send POST requests:

[role="skipme"]
----
    /lists/<list identifier>/add_item
----

(Again, we're not trying to perfectly follow the rules of REST, which would
use a PUT request here--we're just using REST for inspiration.)

In summary, our scratchpad for this chapter looks something like this:

[role="scratchpad"]
*****
* '[strikethrough line-through]#Get FTs to clean up after themselves#'
* 'Adjust model so that items are associated with different lists'
* 'Add unique URLs for each list'
* 'Add a URL for creating a new list via POST'
* 'Add URLs for adding a new item to an existing list via POST'
*****

Implementing the New Design Incrementally using TDD
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

((("test-driven development (TDD)", "process flowchart")))
((("test-driven development (TDD)", "new design implementation with", id="ix_TDDndimp", range="startofrange")))
How do we use TDD to implement the new design? Let's take another look at
the flowchart for the TDD process in <<TDD-double-loop>>.

At the top level, we're going to use a combination of adding new functionality
(by adding a new FT and writing new application code), and refactoring our
application--i.e., rewriting some of the existing implementation so that it
delivers the same functionality to the user but using aspects of our new
design. We'll be able to use the existing functional test to verify we don't
break what already works, and the new functional test to drive the new 
features.

At the unit test level, we'll be adding new tests or modifying existing ones to
test for the changes we want, and we'll be able to similarly use the unit tests
we don't touch to help make sure we don't break anything in the process.

[[TDD-double-loop]]
.The TDD process with functional and unit tests
image::images/twdp_0601.png["A flowchart showing functional tests as the overall cycle, and unit tests helping to code. Tests passing and failing are marked as green and red respectively."]



Ensuring we have a regression test
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's translate our scratchpad into a new functional test method, which
introduces a second user a checks that their to-do list is separate from
Edith's.

We'll start out very similarly to the first, Edith adds a first item to
create a to-do list, but we introduce our first new assertion:  Edith's
list should live at its own, unique URL:

[role="sourcecode"]
.functional_tests/tests.py (ch06l005)
[source,python]
----
def test_can_start_a_list_for_one_user(self):
    # Edith has heard about a cool new online to-do app. She goes
    [...]
    # The page updates again, and now shows both items on her list
    self.check_for_row_in_list_table('2: Use peacock feathers to make a fly')
    self.check_for_row_in_list_table('1: Buy peacock feathers')

    # Satisfied, she goes back to sleep
    

def test_multiple_users_can_start_lists_at_different_urls(self):
    # Edith start a new todo list
    self.browser.get(self.live_server_url)
    inputbox = self.browser.find_element_by_id('id_new_item')
    inputbox.send_keys('Buy peacock feathers')
    inputbox.send_keys(Keys.ENTER)
    self.check_for_row_in_list_table('1: Buy peacock feathers')

    # She notices that her list has a unique URL
    edith_list_url = self.browser.current_url
    self.assertRegex(edith_list_url, '/lists/.+')  #<1>
----

<1> `assertRegex` is a helper function from `unittest` that checks
    whether a string matches a regular expression. We use it to check that our
    new REST-ish design has been implemented. Find out more in the
    ((("assertRegex")))
    http://docs.python.org/3/library/unittest.html[`unittest` documentation].


Next we imagine a new user coming along. We want to check that they don't see
any of Edith's items when they visit the home page, and that they get their own
unique URL for their list.

[role="sourcecode"]
.functional_tests/tests.py (ch06l006)
[source,python]
----
    [...]
    self.assertRegex(edith_list_url, '/lists/.+')  #<1>

    # Now a new user, Francis, comes along to the site.

    ## We use a new browser session to make sure that no information
    ## of Edith's is coming through from cookies etc
    self.browser.quit()
    self.browser = webdriver.Firefox()

    # Francis visits the home page.  There is no sign of Edith's
    # list
    self.browser.get(self.live_server_url)
    page_text = self.browser.find_element_by_tag_name('body').text
    self.assertNotIn('Buy peacock feathers', page_text)
    self.assertNotIn('make a fly', page_text)

    # Francis starts a new list by entering a new item. He
    # is less interesting than Edith...
    inputbox = self.browser.find_element_by_id('id_new_item')
    inputbox.send_keys('Buy milk')
    inputbox.send_keys(Keys.ENTER)
    self.check_for_row_in_list_table('1: Buy milk')

    # Francis gets his own unique URL
    francis_list_url = self.browser.current_url
    self.assertRegex(francis_list_url, '/lists/.+')
    self.assertNotEqual(francis_list_url, edith_list_url)

    # Again, there is no trace of Edith's list
    page_text = self.browser.find_element_by_tag_name('body').text
    self.assertNotIn('Buy peacock feathers', page_text)
    self.assertIn('Buy milk', page_text)

    # Satisfied, they both go back to sleep
----

<1> I'm using the convention of double-hashes (`##`) to indicate
    "meta-comments"&mdash;comments about 'how' the test is working and why--so
    that we can distinguish them from regular comments in FTs which explain the
    User Story. They're a message to our future selves, which might otherwise
    be wondering why the heck we're quitting the browser and starting a new
    one...
    ((("comments")))
    ((("meta-comments")))

Other than that, the new test is fairly self-explanatory. Let's see how we do
when we run our FTs:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests*]
Creating test database for alias 'default'...
.F
======================================================================
FAIL: test_multiple_users_can_start_lists_at_different_urls
(functional_tests.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/.../superlists/functional_tests/tests.py", line 71, in
test_multiple_users_can_start_lists_at_different_urls
    self.assertRegex(edith_list_url, '/lists/.+')
AssertionError: Regex didn't match: '/lists/.+' not found in
'http://localhost:8081/'

 ---------------------------------------------------------------------
Ran 2 tests in 5.786s

FAILED (failures=1)
Destroying test database for alias 'default'...
----

Good, our first test still passes, and the second one fails where we might
expect.  Let's do a commit, and then go and build some new models and views:

[subs="specialcharacters,quotes"]
----
$ *git commit -a*
----

NOTE: I found the FTs hung when I tried to run them today.  It turns out I
    needed to upgrade Selenium, with a `pip install --upgrade "selenium<3"`.
    You may remember from the preface that it's important to have the latest
    version of Selenium installed--it's only been a couple of months since I
    last upgraded, and Selenium had gone up by six point versions.  If
    something weird is happening, always try upgrading Selenium!
    ((("Selenium", "upgrading")))(((range="endofrange", startref="ix_TDDndimp")))


Iterating Towards the New Design
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

((("test-driven development (TDD)", "iterating towards new design")))
((("test-driven development (TDD)", "Working state to working state")))
Being all excited about our new design, I had an overwhelming urge to dive in
at this point and start changing 'models.py', which would have broken half the
unit tests, and then pile in and change almost every single line of code, all
in one go.  That's a natural urge, and TDD, as a discipline, is a constant
fight against it. Obey the Testing Goat, not Refactoring Cat!  We don't need to
implement our new, shiny design in a single big bang. Let's make small changes
that take us from a working state to a working state, with our design guiding
us gently at each stage.

There are four items on our to-do list. The FT, with its `Regexp didn't
match`, is telling us that the second item--giving lists their own URL and
identifier--is the one we should work on next. Let's have a go at fixing
that, and only that.

The URL comes from the redirect after POST.  In 'lists/tests.py', find
`test_home_page_redirects_after_POST`, and change the expected redirect
location:

[role="sourcecode"]
.lists/tests.py
[source,python]
----
self.assertEqual(response.status_code, 302)
self.assertEqual(response['location'], '/lists/the-only-list-in-the-world/')
----

Does that seem slightly strange?  Clearly, '/lists/the-only-list-in-the-world'
isn't a URL that's going to feature in the final design of our application. But
we're committed to changing one thing at a time.  While our application only
supports one list, this is the only URL that makes sense.  We're still moving
forwards, in that we'll have a different URL for our list and our home page,
which is a step along the way to a more REST-ful design. Later, when we have
multiple lists, it will be easy to change.

NOTE: Another way of thinking about it is as a problem-solving technique: our
    new URL design is currently not implemented, so it works for 0 items.
    Ultimately, we want to solve for 'n' items, but solving for 1 item is a
    good step along the way.

Running the unit tests gives us an expected fail:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test lists*]
[...]
AssertionError: '/' != '/lists/the-only-list-in-the-world/'
----

We can go adjust our `home_page` view in 'lists/views.py':

[role="sourcecode"]
.lists/views.py
[source,python]
----
def home_page(request):
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'])
        return redirect('/lists/the-only-list-in-the-world/')

    items = Item.objects.all()
    return render(request, 'home.html', {'items': items})
----

Of course, that will now totally break the functional tests, because there is
no such URL on our site yet.  Sure enough, if you run them, you'll find they
fail just after trying to submit the first item, saying that they can't find
the list table; it's because URL '/the-only-list-in-the-world/' doesn't exist
yet!

----
  File "/.../superlists/functional_tests/tests.py", line 45, in
test_can_start_a_list_for_one_user
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: {"method":"id","selector":"id_list_table"}
[...]

  File "/.../superlists/functional_tests/tests.py", line 67, in
test_multiple_users_can_start_lists_at_different_urls
    self.check_for_row_in_list_table('1: Buy peacock feathers')
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: {"method":"id","selector":"id_list_table"}
----
//IDEA: improve FT for better error messages when table missing

Not only is our new test failing, but the old one is too.  That tells
us we've introduce a 'regression'.  Let's try and get back to a working
state as quickly as possible by building a URL for our one and only list.


Taking a first, self-contained step: one new URL
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Open up 'lists/tests.py', and add a new test class called `ListViewTest`.  Then
copy the method called `test_displays_all_list_items` across from
`HomePageTest` into our new class, rename it, and adapt it slightly:

[role="sourcecode"]
.lists/tests.py (ch06l009)
[source,python]
----
class ListViewTest(TestCase):

    def test_displays_all_items(self):
        Item.objects.create(text='itemey 1')
        Item.objects.create(text='itemey 2')

        response = self.client.get('/lists/the-only-list-in-the-world/')

        self.assertContains(response, 'itemey 1')  #<1>
        self.assertContains(response, 'itemey 2')  #<1>

----

<1> Here's a new helper method: instead of using the slightly annoying
    `assertIn`/`response.content.decode()` dance, Django provides the
    `assertContains` method which knows how to deal with responses and the
    bytes of their content.


Let's try running this test now:

----
    self.assertContains(response, 'itemey 1')
[...]
AssertionError: 404 != 200 : Couldn't retrieve content: Response code was 404
----

Here's a nice side-effect of using `assertContains`: it tells us straight
away that the test is failing because our new URL doesn't exist yet, and
is returning a 404.


A New URL
^^^^^^^^^

((("Django", "URLs in")))
((("URLs", "in Django")))
Our singleton list URL doesn't exist yet.  We fix that in 'superlists/urls.py'.

TIP: Watch out for trailing slashes in URLs, both here in the tests and in
    'urls.py'. They're a common source of bugs.


[role="sourcecode small-code"]
.superlists/urls.py
[source,python]
----
urlpatterns = [
    url(r'^$', views.home_page, name='home'),
    url(r'^lists/the-only-list-in-the-world/$', views.view_list, name='view_list'),
]
----
//010-1


Running the tests again, we get:

----
AttributeError: module 'lists.views' has no attribute 'view_list'
[...]
FAILED (errors=6)
----


A New View Function
^^^^^^^^^^^^^^^^^^^

((("Django", "view functions in")))
((("view functions, in Django")))
Nicely self-explanatory.  Let's create a dummy view function in
'lists/views.py':

[role="sourcecode"]
.lists/views.py
[source,python]
----
def view_list(request):
    pass
----

Now we get:

----
ValueError: The view lists.views.view_list didn't return an HttpResponse
object. It returned None instead.

[...]
FAILED (errors=1)
----

Down to just one failure, and it's pointing us in the right direction. Let's
copy the two last lines from the `home_page` view and see if they'll do the
trick:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def view_list(request):
    items = Item.objects.all()
    return render(request, 'home.html', {'items': items})
----

Rerun the unit tests and they should pass:

----
Ran 7 tests in 0.016s
OK
----

Now let's try the FTs again and see what they tell us:

----
FAIL: test_can_start_a_list_for_one_user
[...]
  File "/.../superlists/functional_tests/tests.py", line 55, in
test_can_start_a_list_for_one_user
[...]
AssertionError: '2: Use peacock feathers to make a fly' not found in ['1: Buy
peacock feathers']
[...]
----

Both of them are getting a little further than they were before, but they're
still failing.  It would be nice to get back to a working state and get that
first one passing again.  What's it trying to tell us?

It's failing when we try to add the second item.  We have to put our debugging
hats on here.  We know the home page is working, because the test has got all
the way down to line 55 in the FT, so we've at least added a first item.  And
our unit tests are all passing, so we're pretty sure the URLs and views are
doing what they should -- the home page displays the right template, and
can handle POST requests, and the 'only-list-in-the-world' view knows how
to display all items...  But it doesn't know how to handle POST requests. Ah,
that gives us a clue.

A second clue is the rule of thumb that, when all the unit tests are passing
but the functional tests aren't, it's often pointing at a problem that's not
covered by the unit tests, and in our case, that's often a template problem.

The answer is that our 'home.html' input form currently doesn't specify an
explicit URL to POST to.

[role="sourcecode currentcontents"]
.lists/templates/home.html
[source,html]
----
        <form method="POST">
----

By default the browser sends the POST data back to the same URL it's currently
on.  When we're on the home page that works fine, but when we're on our
'only-list-in-the-world' page, it doesn't.

Now we could dive in and add POST request handling to our new view, but that
would involve writing a bunch more tests and code, and at this point we'd like
to get back to a working state as quickly as possible.  Actually the quickest
thing we can do to get things fixed is to just use the existing home page view,
which already works, for all POST requests:

[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
        <form method="POST" action="/">
----

Try that, and we'll see our FTs get back to a happier place:

[subs="specialcharacters,macros"]
----
FAIL: test_multiple_users_can_start_lists_at_different_urls
[...]
AssertionError: 'Buy peacock feathers' unexpectedly found in 'Your To-Do
list\n1: Buy peacock feathers'

Ran 2 tests in 8.541s
FAILED (failures=1)
----

Our original test passes once again, so we know we're back to a working state.
The new functionality may not be working yet, but at least the old stuff works
as well as it used to.


Green? Refactor
~~~~~~~~~~~~~~~

((("Red, Green, Refactor")))
((("refactoring", "Red, Green, Refactor")))
Time for a little tidying up.  

In the 'Red/Green/Refactor' dance, we've arrived at green, so we should see
what needs a refactor.  We now have two views, one for the home page, and one
for an individual list.  Both are currently using the same template, and
passing it all the list items currently in the database.  If we look through
our unit test methods, we can see some stuff we probably want to change:

[subs="specialcharacters,quotes"]
----
$ *grep -E "class|def" lists/tests.py*
class HomePageTest(TestCase):
    def test_uses_home_template(self):
    def test_displays_all_list_items(self):
    def test_can_save_a_POST_request(self):
    def test_redirects_after_POST(self):
    def test_only_saves_items_when_necessary(self):
class ListViewTest(TestCase):
    def test_displays_all_items(self):
class ItemModelTest(TestCase):
    def test_saving_and_retrieving_items(self):

----

We can definitely delete the `test_displays_all_list_items` method from 
`HomePageTest`, it's no longer needed.  If you run *`manage.py test lists`*
now, it should say it ran 6 tests instead of 7:

[role="dofirst-ch06l012"]
----
Ran 6 tests in 0.016s
OK
----

Next, since we don't actually need the home page template to display all list
items any more; it should just show a single input box inviting you to start a
new list.


Another Small Step: A Separate Template for Viewing Lists
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

((("templates", "separate")))
((("Django", "templates")))
Since the home page and the list view are now quite distinct pages,
they should be using different HTML templates; 'home.html' can have the
single input box, whereas a new template, 'list.html', can take care
of showing the table of existing items.

Let's add a new test to check that it's using a different template:

//13
[role="sourcecode"]
.lists/tests.py
[source,python]
----
class ListViewTest(TestCase):

    def test_uses_list_template(self):
        response = self.client.get('/lists/the-only-list-in-the-world/')
        self.assertTemplateUsed(response, 'list.html')


    def test_displays_all_items(self):
        [...]

----

((("assertTemplateUsed")))
`assertTemplateUsed` is one of the more useful functions that the Django test
client gives us.  Let's see what it says:

----
AssertionError: False is not true : Template 'list.html' was not a template
used to render the response. Actual template(s) used: home.html
----

Great!  Let's change the view:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def view_list(request):
    items = Item.objects.all()
    return render(request, 'list.html', {'items': items})
----

But, obviously, that template doesn't exist yet. If we run the unit tests, we
get:

----
django.template.exceptions.TemplateDoesNotExist: list.html
----

Let's create a new file at 'lists/templates/list.html':

[subs="specialcharacters,quotes"]
----
$ *touch lists/templates/list.html*
----

A blank template, which gives us this error--good to know the tests are
there to make sure we fill it in:

----
AssertionError: False is not true : Couldn't find 'itemey 1' in response
----

The template for an individual list will reuse quite a lot of the stuff
we currently have in 'home.html', so we can start by just copying that:

[subs="specialcharacters,quotes"]
----
$ *cp lists/templates/home.html lists/templates/list.html*
----

That gets the tests back to passing (green).  Now let's do a little more
tidying up (refactoring).  We said the home page doesn't need to list items, it
only needs the new list input field, so we can remove some lines from
'lists/templates/home.html', and maybe slightly tweak the `h1` to say "Start a
new To-Do list":

[role="sourcecode small-code"]
.lists/templates/home.html
[source,html]
----
<body>
    <h1>Start a new To-Do list</h1>
    <form method="POST">
        <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
        {% csrf_token %}
    </form>
</body>
----
//16

We rerun the unit tests to check that hasn't broken anything--good...

There's actually no need to pass all the items to the 'home.html' template in
our `home_page` view, so we can simplify that:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def home_page(request):
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'])
        return redirect('/lists/the-only-list-in-the-world/')
    return render(request, 'home.html')
----

Rerun the unit tests once more; they still pass. Time to run the functional
tests:

----
AssertionError: '1: Buy milk' not found in ['1: Buy peacock feathers', '2: Buy
milk']
----


Not bad!  Our regression test (the first FT) is passing, and our new test
is now getting slightly further forwards -- it's telling us that Francis
isn't getting his own list page (because he still sees some of Edith's
list items.)


It may feel like we haven't made much headway since, functionally, the site
still behaves almost exactly like it did when we started the chapter, but this
really is progress. We've started on the road to our new design, and we've
implemented a number of stepping stones 'without making anything worse than it
was before'.  Let's commit our progress so far:

[subs="specialcharacters,quotes"]
----
$ *git status* # should show 4 changed files and 1 new file, list.html
$ *git add lists/templates/list.html*
$ *git diff* # should show we've simplified home.html,
           # moved one test to a new class in lists/tests.py added a new view
           # in views.py, and simplified home_page and made one addition to
           # urls.py
$ *git commit -a* # add a message summarising the above, maybe something like
                # "new URL, view and template to display lists"
----


A Third Small Step: a URL for Adding List Items
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Where are we with our own to-do list?

[role="scratchpad"]
*****
* '[strikethrough line-through]#Get FTs to clean up after themselves#'
* 'Adjust model so that items are associated with different lists'
* 'Add unique URLs for each list'  <-- ...
* 'Add a URL for creating a new list via POST'
* 'Add URLs for adding a new item to an existing list via POST'
*****

We've 'sort of' made progress on the third item, even if there's still only one
list in the world. Item 2 is a bit scary.  Can we do something about items 4 or
5?  

Let's have a new URL for adding new list items.  If nothing else, it'll
simplify the home page view.


A Test Class for New List Creation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

((("Django", "test class in")))
Open up 'lists/tests.py', and 'move' the
`test_can_save_a_POST_request` and
`test_redirects_after_POST` methods into a new class, then change
the URL they POST to:

[role="sourcecode small-code"]
.lists/tests.py (ch06l021-1)
[source,python]
----
class NewListTest(TestCase):

    def test_can_save_a_POST_request(self):
        self.client.post('/lists/new', data={'item_text': 'A new list item'})
        self.assertEqual(Item.objects.count(), 1)
        new_item = Item.objects.first()
        self.assertEqual(new_item.text, 'A new list item')


    def test_redirects_after_POST(self):
        response = self.client.post('/lists/new', data={'item_text': 'A new list item'})
        self.assertEqual(response.status_code, 302)
        self.assertEqual(response['location'], '/lists/the-only-list-in-the-world/')
----

TIP: This is another place to pay attention to trailing slashes, incidentally.
    It's `/new`, with no trailing slash.  The convention I'm using is that URLs
    without a trailing slash are "action" URLs which modify the database.

While we're at it, let's learn a new Django Test Client method, `assertRedirects`:

[role="sourcecode small-code"]
.lists/tests.py (ch06l021-2)
[source,python]
----
    def test_redirects_after_POST(self):
        response = self.client.post('/lists/new', data={'item_text': 'A new list item'})
        self.assertRedirects(response, '/lists/the-only-list-in-the-world/')
----

There's not much to it, but it just nicely replaces two asserts with a single
one...

Try running that:

----
    self.assertEqual(Item.objects.count(), 1)
AssertionError: 0 != 1
[...]
    self.assertRedirects(response, '/lists/the-only-list-in-the-world/')
[...]
AssertionError: 404 != 302 : Response didn't redirect as expected: Response
code was 404 (expected 302)
----

The first failure tells us we're not saving a new item to the database, and the
second says that, instead of returning a 302 redirect, our view is returning 
a 404. That's because we haven't built a URL for '/lists/new', so the
`client.post` is just getting a "not found" response.

NOTE: Do you remember how we split this out into two tests in the last chapter?
    If we only had one test that checked both the saving and the redirect, it
    would have failed on the `0 != 1` failure, which would have been much
    harder to debug.  Ask me how I know this.


A URL and View for New List Creation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

((("Django", "view functions in")))
((("view functions, in Django")))
((("URLs", "in Django")))
((("Django", "URLs in")))
Let's build our new URL now:


//22
[role="sourcecode"]
.superlists/urls.py
[source,python]
----
urlpatterns = [
    url(r'^$', views.home_page, name='home'),
    url(r'^lists/new$', views.new_list, name='new_list'),
    url(r'^lists/the-only-list-in-the-world/$', views.view_list, name='view_list'),
]
----

Next we get a `no attribute 'new_list'`, so let's fix that, in
'lists/views.py':

[role="sourcecode"]
.lists/views.py
[source,python]
----
def new_list(request):
    pass
----

Then we get "The view lists.views.new_list didn't return an HttpResponse
object".  (This is getting rather familiar!)  We could return a raw
`HttpResponse`, but since we know we'll need a redirect, let's borrow a line
from `home_page`:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def new_list(request):
    return redirect('/lists/the-only-list-in-the-world/')
----

That gives:

----
    self.assertEqual(Item.objects.count(), 1)
AssertionError: 0 != 1
----

Seems reasonably straightforward. We borrow another line from `home_page`:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def new_list(request):
    Item.objects.create(text=request.POST['item_text'])
    return redirect('/lists/the-only-list-in-the-world/')
----
//24
//TODO: new_list gets into the wrong order here.  Maybe use a commit?

And everything now passes:

----
Ran 7 tests in 0.030s

OK
----


And the FTs show me that I'm back to the working state:

----
[...]
AssertionError: '1: Buy milk' not found in ['1: Buy peacock feathers', '2: Buy
milk']
Ran 2 tests in 8.972s
FAILED (failures=1)
----


Removing Now-Redundant Code and Tests
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

((("functional tests/testing (FT)","cleanup")))
We're looking good. Since our new views are now doing most of the work that
`home_page` used to do, we should be able to massively simplify it. Can we
remove the whole `if request.method == 'POST'` section, for example?

[role="sourcecode"]
.lists/views.py
[source,python]
----
def home_page(request):
    return render(request, 'home.html')
----
//24

Yep!

----
OK
----

And while we're at it, we can remove the now-redundant
`test_only_saves_items_when_necessary` test too!

Doesn't that feel good?  The view functions are looking much simpler. We rerun
the tests to make sure...

[role="dofirst-ch06l025"]
----
Ran 6 tests in 0.016s
OK
----

and the FTs?


A regression! Pointing Our Forms at the New URL
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Oops:

----
ERROR: test_can_start_a_list_for_one_user
[...]
  File "/.../superlists/functional_tests/tests.py", line 45, in
test_can_start_a_list_for_one_user
    self.check_for_row_in_list_table('1: Buy peacock feathers')
  File "/.../superlists/functional_tests/tests.py", line 16, in
check_for_row_in_list_table
    table = self.browser.find_element_by_id('id_list_table')
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: {"method":"id","selector":"id_list_table"}

ERROR: test_multiple_users_can_start_lists_at_different_urls
[...]
  File "/.../superlists/functional_tests/tests.py", line 67, in
test_multiple_users_can_start_lists_at_different_urls
    self.check_for_row_in_list_table('1: Buy peacock feathers')
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: {"method":"id","selector":"id_list_table"}
[...]

Ran 2 tests in 11.592s
FAILED (errors=2)
----

((("URLs", "pointing forms to")))
((("Django", "URLs in")))
((("URLs", "in Django")))
It's because our forms are still pointing to the old URL. In 'both' 'home.html'
and 'lists.html', let's change them to:

//ch06l026
[role="sourcecode"]
.lists/templates/home.html, lists/templates/list.html
[source,html]
----
    <form method="POST" action="/lists/new">
----

And that should get us back to working again:

----
AssertionError: '1: Buy milk' not found in ['1: Buy peacock feathers', '2: Buy
milk']
[...]
FAILED (failures=1)
----


That's another nicely self-contained commit, in that we've made a bunch
of changes to our URLs, our 'views.py' is looking much neater and tidier, and
we're sure the application is still working as well as it did before.  We're
getting good at this working-state-to-working-state malarkey!

[subs="specialcharacters,quotes"]
----
$ *git status* # 5 changed files
$ *git diff* # URLs for forms x2, moved code in views + tests, new URL
$ *git commit -a*
----

And we can cross out an item on the to-do list:

[role="scratchpad"]
*****
* '[strikethrough line-through]#Get FTs to clean up after themselves#'
* 'Adjust model so that items are associated with different lists'
* 'Add unique URLs for each list'
* '[strikethrough line-through]#Add a URL for creating a new list via POST#'
* 'Add URLs for adding a new item to an existing list via POST'
*****


Biting the bullet: Adjusting Our Models
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

((("Django", "model adjustment in")))
Enough housekeeping with our URLs. It's time to bite the bullet and
change our models.  Let's adjust the model unit test. Just for a change, I'll
present the changes in the form of a diff:

//(ch06l027)
[role="sourcecode"]
.lists/tests.py
[source,diff]
----
@@ -1,5 +1,5 @@
 from django.test import TestCase
-from lists.models import Item
+from lists.models import Item, List
 
 
 class HomePageTest(TestCase):
@@ -44,22 +44,32 @@ class ListViewTest(TestCase):
 
 
 
-class ItemModelTest(TestCase):
+class ListAndItemModelsTest(TestCase):
 
     def test_saving_and_retrieving_items(self):
+        list_ = List()
+        list_.save()
+
         first_item = Item()
         first_item.text = 'The first (ever) list item'
+        first_item.list = list_
         first_item.save()
 
         second_item = Item()
         second_item.text = 'Item the second'
+        second_item.list = list_
         second_item.save()
 
+        saved_list = List.objects.first()
+        self.assertEqual(saved_list, list_)
+
         saved_items = Item.objects.all()
         self.assertEqual(saved_items.count(), 2)
 
         first_saved_item = saved_items[0]
         second_saved_item = saved_items[1]
         self.assertEqual(first_saved_item.text, 'The first (ever) list item')
+        self.assertEqual(first_saved_item.list, list_)
         self.assertEqual(second_saved_item.text, 'Item the second')
+        self.assertEqual(second_saved_item.list, list_)

----

We create a new `List` object, and then we assign each item to it
by assigning it as its `.list` property.  We check the list is properly
saved, and we check that the two items have also saved their relationship
to the list.  You'll also notice that we can compare list objects with each
other directly (`saved_list` and `list_`)&mdash;behind the scenes, these
will compare themselves by checking their primary key (the `.id` attribute)
is the same.

NOTE: I'm using the variable name `list_` to avoid "shadowing" the Python
    built-in `list` function.  It's ugly, but all the other options I tried
    were equally ugly or worse (`my_list`, `the_list`, `list1`, `listey`...).

Time for another unit-test/code cycle.   

For the first couple of iterations, rather than explicitly showing you what
code to enter in between every test run, I'm only going to show you the
expected error messages from running the tests.  I'll let you figure out what
each minimal code change should be on your own:

TIP: Need a hint?  Go back and take a look at the steps we took to introduce
    the `Item` model in <<chapter_05, the last chapter>>.

Your first error should be:

[subs="specialcharacters,macros"]
----
ImportError: cannot import name 'List'
----

Fix that, then you should see:

[role="dofirst-ch06l028-1"]
----
AttributeError: 'List' object has no attribute 'save'
----

Next you should see:

[role="dofirst-ch06l028-2"]
----
django.db.utils.OperationalError: no such table: lists_list
----

So we run a `makemigrations`:

//29
[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py makemigrations*]
Migrations for 'lists':
  lists/migrations/0003_list.py:
    - Create model List
----

And then you should see:

----
    self.assertEqual(first_saved_item.list, list_)
AttributeError: 'Item' object has no attribute 'list'
----


A Foreign Key Relationship
^^^^^^^^^^^^^^^^^^^^^^^^^^

((("migrations")))
((("Django", "foreign key relationship")))
((("foreign key relationship")))
How do we give our `Item` a list attribute?  Let's just try naively making it
like the `text` attribute:


[role="sourcecode"]
.lists/models.py
[source,python]
----
from django.db import models

class List(models.Model):
    pass

class Item(models.Model):
    text = models.TextField(default='')
    list = models.TextField(default='')
----
//030-1

As usual, the tests tell us we need a migration:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test lists*]
[...]
django.db.utils.OperationalError: no such column: lists_item.list

$ pass:quotes[*python manage.py makemigrations*]
Migrations for 'lists':
  lists/migrations/0004_item_list.py:
    - Add field list to item
----


Let's see what that gives us:

----
AssertionError: 'List object' != <List: List object>
----


We're not quite there. Look closely at each side of the `!=`.  Django has only
saved the string representation of the `List` object. To save the relationship to
the object itself, we tell Django about the relationship between the two
classes using a `ForeignKey`:

[role="sourcecode"]
.lists/models.py
[source,python]
----
from django.db import models

class List(models.Model):
    pass


class Item(models.Model):
    text = models.TextField(default='')
    list = models.ForeignKey(List, default=None)
----
//030-2


((("migrations", "deleting")))
That'll need a migration too.  Since the last one was a red herring, let's
delete it and replace it with a new one:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*rm lists/migrations/0004_item_list.py*]
$ pass:quotes[*python manage.py makemigrations*]
Migrations for 'lists':
  lists/migrations/0004_item_list.py:
    - Add field list to item
----
//31


WARNING: Deleting migrations is dangerous. If you delete a migration that's
    already been applied to a database somewhere, Django will be confused about
    what state it's in, and how to apply future migrations. You should only do
    it when you're sure the migration hasn't been used.  A good rule of thumb
    is that you should never delete a migration that's been committed to your
    VCS. 



Adjusting the Rest of the World to Our New Models
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Back in our tests, now what happens?

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test lists*]
[...]
ERROR: test_displays_all_items (lists.tests.ListViewTest)
django.db.utils.IntegrityError: NOT NULL constraint failed: lists_item.list_id
[...]
ERROR: test_redirects_after_POST (lists.tests.NewListTest)
django.db.utils.IntegrityError: NOT NULL constraint failed: lists_item.list_id
[...]
ERROR: test_can_save_a_POST_request (lists.tests.NewListTest)
django.db.utils.IntegrityError: NOT NULL constraint failed: lists_item.list_id

Ran 6 tests in 0.021s

FAILED (errors=3)
----

Oh dear!  

There is some good news. Although it's hard to see, our model tests are
passing.  But three of our view tests are failing nastily.

The reason is because of the new relationship we've introduced between
Items and Lists, which requires each item to have a parent list, which 
our old tests and code aren't prepared for.

Still, this is exactly why we have tests! Let's get them working again.  The
easiest is the `ListViewTest`; we just create a parent list for our two test
items:


[role="sourcecode"]
.lists/tests.py (ch06l031)
[source,python]
----
class ListViewTest(TestCase):

    def test_displays_all_items(self):
        list_ = List.objects.create()
        Item.objects.create(text='itemey 1', list=list_)
        Item.objects.create(text='itemey 2', list=list_)
----

That gets us down to two failing tests, both on tests that try to POST to our
`new_list` view. Decoding the tracebacks using our usual technique, working back
from error, to line of test code, to, buried in there somewhere, the line of
our own code that caused the failure:

[subs="specialcharacters,macros"]
----
File "/.../superlists/lists/views.py", line 14, in new_list
Item.objects.create(text=request.POST['item_text'])
----

//TODO: line 14 shld be line 9, because new_list is in wrong place, see todo above.

It's when we try and create an item without a parent list. So we make a similar
change in the view:

[role="sourcecode"]
.lists/views.py
[source,python]
----
from lists.models import Item, List
[...]
def new_list(request):
    list_ = List.objects.create()
    Item.objects.create(text=request.POST['item_text'], list=list_)
    return redirect('/lists/the-only-list-in-the-world/')
----

And that gets our tests passing again:

----
Ran 6 tests in 0.030s

OK
----

Are you cringing internally at this point?  'Arg! This feels so wrong, we
create a new list for every single new item submission, and we're still just
displaying all items as if they belong to the same list!'
I know, I feel the same.  The step-by-step approach, in which you go
from working code to working code, is counterintuitive. I always feel like
just diving in and trying to fix everything all in one go, instead of going
from one weird half-finished state to another.  But remember the Testing Goat!
When you're up a mountain, you want to think very carefully about where you put
each foot, and take one step at a time, checking at each stage that the place
you've put it hasn't caused you to fall off a cliff.

So just to reassure ourselves that things have worked, we rerun the FT.

----
AssertionError: '1: Buy milk' not found in ['1: Buy peacock feathers', '2: Buy
milk']
[...]
----


Sure enough, it gets all the way through to where we were before.  We haven't broken
anything, and we've made a change to the database.  That's something to be
pleased with! Let's commit:

[subs="specialcharacters,quotes"]
----
$ *git status* # 3 changed files, plus 2 migrations
$ *git add lists*
$ *git diff --staged*
$ *git commit*
----

And we can cross out another item on the to-do list:

[role="scratchpad"]
*****
* '[strikethrough line-through]#Get FTs to clean up after themselves#'
* '[strikethrough line-through]#Adjust model so that items are associated with different lists#'
* 'Add unique URLs for each list'
* '[strikethrough line-through]#Add a URL for creating a new list via POST#'
* 'Add URLs for adding a new item to an existing list via POST'
*****


Each List Should Have Its Own URL
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

((("Django", "URLs in")))
((("URLs", "in Django")))
((("URLs", "distinct")))
What shall we use as the unique identifier for our lists?  Probably the
simplest thing, for now, is just to use the auto-generated `id` field from the
database. Let's change `ListViewTest` so that the two tests point at new
URLs.

We'll also change the old `test_displays_all_items` test and call it
`test_displays_only_items_for_that_list` instead, and make it check that
only the items for a specific list are displayed:

[role="sourcecode"]
.lists/tests.py (ch06l033)
[source,python]
----
class ListViewTest(TestCase):

    def test_uses_list_template(self):
        list_ = List.objects.create()
        response = self.client.get('/lists/%d/' % (list_.id,))
        self.assertTemplateUsed(response, 'list.html')


    def test_displays_only_items_for_that_list(self):
        correct_list = List.objects.create()
        Item.objects.create(text='itemey 1', list=correct_list)
        Item.objects.create(text='itemey 2', list=correct_list)
        other_list = List.objects.create()
        Item.objects.create(text='other list item 1', list=other_list)
        Item.objects.create(text='other list item 2', list=other_list)

        response = self.client.get('/lists/%d/' % (correct_list.id,))

        self.assertContains(response, 'itemey 1')
        self.assertContains(response, 'itemey 2')
        self.assertNotContains(response, 'other list item 1')
        self.assertNotContains(response, 'other list item 2')
----


NOTE: If you're not familiar with Python string substitutions, or the
    `printf` function from C, maybe that `%d` is a little confusing?
    http://www.diveintopython.net/['Dive Into Python'] has a good overview, if
    you want to go look them up quickly.  We'll see an alternative string
    substitution syntax later in the book too.
    ((("string substitutions")))

Running the unit tests gives an expected 404, and another related error:

----
FAIL: test_displays_only_items_for_that_list (lists.tests.ListViewTest)
AssertionError: 404 != 200 : Couldn't retrieve content: Response code was 404
(expected 200)
[...]
FAIL: test_uses_list_template (lists.tests.ListViewTest)
AssertionError: No templates used to render the response
----


Capturing Parameters from URLs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

((("URLs", "capturing parameters in")))
It's time to learn how we can pass parameters from URLs to views:


[role="sourcecode"]
.superlists/urls.py
[source,python]
----
urlpatterns = [
    url(r'^$', views.home_page, name='home'),
    url(r'^lists/new$', views.new_list, name='new_list'),
    url(r'^lists/(.+)/$', views.view_list, name='view_list'),
]
----
//34


We adjust the regular expression for our URL to include a 'capture group',
`(.+)`, which will match any characters, up to the following `/`. The captured
text will get passed to the view as an argument.

In other words, if we go to the URL '/lists/1/', `view_list` will get a second
argument after the normal `request` argument, namely the string `"1"`.
If we go to '/lists/foo/', we get `view_list(request, "foo")`.

But our view doesn't expect an argument yet! Sure enough, this causes problems:

----
ERROR: test_displays_only_items_for_that_list (lists.tests.ListViewTest)
[...]
TypeError: view_list() takes 1 positional argument but 2 were given
[...]
ERROR: test_uses_list_template (lists.tests.ListViewTest)
[...]
TypeError: view_list() takes 1 positional argument but 2 were given
[...]
ERROR: test_redirects_after_POST (lists.tests.NewListTest)
[...]
TypeError: view_list() takes 1 positional argument but 2 were given
FAILED (errors=3)
----

We can fix that easily with a dummy parameter in 'views.py':

[role="sourcecode"]
.lists/views.py
[source,python]
----
def view_list(request, list_id):
    [...]
----

Now we're down to our expected failure:

----
FAIL: test_displays_only_items_for_that_list (lists.tests.ListViewTest)
[...]
AssertionError: 1 != 0 : Response should not contain 'other list item 1'
----

Let's make our view discriminate over which items it sends to the
template:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def view_list(request, list_id):
    list_ = List.objects.get(id=list_id)
    items = Item.objects.filter(list=list_)
    return render(request, 'list.html', {'items': items})
----
//35-2


Adjusting new_list to the New World
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Oops, now we get errors in another test:

----
ERROR: test_redirects_after_POST (lists.tests.NewListTest)
ValueError: invalid literal for int() with base 10:
'the-only-list-in-the-world'
----

Let's take a look at this test then, since it's moaning:


[role="sourcecode currentcontents"]
.lists/tests.py
[source,python]
----
class NewListTest(TestCase):
    [...]

    def test_redirects_after_POST(self):
        response = self.client.post('/lists/new', data={'item_text': 'A new list item'})
        self.assertRedirects(response, '/lists/the-only-list-in-the-world/')
----

It looks like it hasn't been adjusted to the new world of Lists and Items.
The test should be saying that this view redirects to the URL of the specific
new list it just created:

[role="sourcecode"]
.lists/tests.py (ch06l036-1)
[source,python]
----
    def test_redirects_after_POST(self):
        response = self.client.post('/lists/new', data={'item_text': 'A new list item'})
        new_list = List.objects.first()
        self.assertRedirects(response, '/lists/%d/' % (new_list.id,))
----

That still gives us the 'invalid literal' error. We take a look at the view
itself, and change it so it redirects to a valid place:

//IDEA: explain more exactly why this is happening?

[role="sourcecode"]
.lists/views.py (ch06l036-2)
[source,python]
----
def new_list(request):
    list_ = List.objects.create()
    Item.objects.create(text=request.POST['item_text'], list=list_)
    return redirect('/lists/%d/' % (list_.id,))
----

That gets us back to passing unit tests.  

----
Creating test database for alias 'default'...
......
 ---------------------------------------------------------------------
Ran 6 tests in 0.033s

OK
Destroying test database for alias 'default'...
----


What about the functional tests?  We must be almost there?


The functional tests detect another regression
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Well, almost:

----
Creating test database for alias 'default'...
F.
======================================================================
FAIL: test_can_start_a_list_for_one_user
(functional_tests.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/.../superlists/functional_tests/tests.py", line 55, in
test_can_start_a_list_for_one_user
    self.check_for_row_in_list_table('2: Use peacock feathers to make a fly')
  File "/.../superlists/functional_tests/tests.py", line 18, in
check_for_row_in_list_table
    self.assertIn(row_text, [row.text for row in rows])
AssertionError: '2: Use peacock feathers to make a fly' not found in ['1: Use
peacock feathers to make a fly']

 ---------------------------------------------------------------------
Ran 2 tests in 8.617s

FAILED (failures=1)
Destroying test database for alias 'default'...
----

Our new test is actually passing, and different users can get different lists,
but the old test is warning us of a regression.  It looks like you can't
add a second item to a list any more.  It's because of our quick-and dirty hack
where create a new list for every single POST submission. This is exactly what
we have functional tests for!

And it correlates nicely with the last item on our to-do list:

[role="scratchpad"]
*****
* '[strikethrough line-through]#Get FTs to clean up after themselves#'
* '[strikethrough line-through]#Adjust model so that items are associated with different lists#'
* '[strikethrough line-through]#Add unique URLs for each list#'
* '[strikethrough line-through]#Add a URL for creating a new list via POST#'
* 'Add URLs for adding a new item to an existing list via POST'
*****


One More View to Handle Adding Items to an Existing List
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

((("Django", "view functions in", id="ix_Djangoviewfunctions", range="startofrange")))
((("view functions, in Django", id="ix_viewfunctions", range="startofrange")))
We need a URL and view to handle adding a new item to an existing list
('/lists/<list_id>/add_item').  We're getting pretty good at these now, so
let's knock one together quickly:

[role="sourcecode"]
.lists/tests.py
[source,python]
----
class NewItemTest(TestCase):

    def test_can_save_a_POST_request_to_an_existing_list(self):
        other_list = List.objects.create()
        correct_list = List.objects.create()

        self.client.post(
            '/lists/%d/add_item' % (correct_list.id,),
            data={'item_text': 'A new item for an existing list'}
        )

        self.assertEqual(Item.objects.count(), 1)
        new_item = Item.objects.first()
        self.assertEqual(new_item.text, 'A new item for an existing list')
        self.assertEqual(new_item.list, correct_list)


    def test_redirects_to_list_view(self):
        other_list = List.objects.create()
        correct_list = List.objects.create()

        response = self.client.post(
            '/lists/%d/add_item' % (correct_list.id,),
            data={'item_text': 'A new item for an existing list'}
        )

        self.assertRedirects(response, '/lists/%d/' % (correct_list.id,))
----

NOTE: Are you wondering about `other_list`?  A bit like in the tests for
    viewing a specific list, it's important that we add items to a specific
    list.  Adding this second object to the database prevents me from using
    a hack like List.objects.first() in the implementation.  That would be
    a stupid thing to do, and you can't go too far down the road of testing
    for all the stupid things you must not do (there are an infinite number
    of those after all). It's a judgement call, but this one feels worth it.
    There's some more discussion of this in <<Chapter
    12,testing-for-stupidity>>

We get:

----
AssertionError: 0 != 1
[...]
AssertionError: 301 != 302 : Response didn't redirect as expected: Response
code was 301 (expected 302)
----


Beware of Greedy Regular Expressions!
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

((("greedy regular expressions")))
That's a little strange. We haven't actually specified a URL for
'/lists/1/add_item' yet, so our expected failure is `404 != 302`.  Why are we
getting a 301?

This was a bit of a puzzler! It's because we've used a very "greedy"
regular expression in our URL:


[role="sourcecode currentcontents"]
.superlists/urls.py
[source,python]
----
    url(r'^lists/(.+)/$', views.view_list, name='view_list'),
----

Django has some built-in code to issue a permanent redirect (301) whenever
someone asks for a URL which is 'almost' right, except for a missing slash.
In this case, '/lists/1/add_item/' would be a match for `lists/(.+)/`, with
the `(.+)` capturing `1/add_item`.  So Django "helpfully" guesses that we
actually wanted the URL with a trailing slash.

We can fix that by making our URL pattern explicitly capture only numerical
digits, by using the regular expression `\d`:

[role="sourcecode"]
.superlists/urls.py
[source,python]
----
    url(r'^lists/(\d+)/$', views.view_list, name='view_list'),
----
//38

That gives us the failure we expected:

----
AssertionError: 0 != 1
[...]
AssertionError: 404 != 302 : Response didn't redirect as expected: Response
code was 404 (expected 302)
----

The Last New URL
^^^^^^^^^^^^^^^^

((("URLs", "in Django")))
((("Django", "URLs in")))
Now we've got our expected 404, let's add a new URL for adding new items to
existing lists:

[role="sourcecode"]
.superlists/urls.py
[source,python]
----
urlpatterns = [
    url(r'^$', views.home_page, name='home'),
    url(r'^lists/new$', views.new_list, name='new_list'),
    url(r'^lists/(\d+)/$', views.view_list, name='view_list'),
    url(r'^lists/(\d+)/add_item$', views.add_item, name='add_item'),
]
----

Three very similar-looking URLs there.  Let's make a note on our
to-do list; they look like good candidates for a refactoring.

[role="scratchpad"]
*****
* '[strikethrough line-through]#Get FTs to clean up after themselves#'
* '[strikethrough line-through]#Adjust model so that items are associated with different lists#'
* '[strikethrough line-through]#Add unique URLs for each list#'
* '[strikethrough line-through]#Add a URL for creating a new list via POST#'
* 'Add URLs for adding a new item to an existing list via POST'
* 'Refactor away some duplication in urls.py'
*****


Back to the tests, we get the usual missing module view objects:

----
AttributeError: module 'lists.views' has no attribute 'add_item'
----


The Last New View
^^^^^^^^^^^^^^^^^

Let's try:


[role="sourcecode"]
.lists/views.py
[source,python]
----
def add_item(request):
    pass
----

Aha:

----
TypeError: add_item() takes 1 positional argument but 2 were given
----


[role="sourcecode"]
.lists/views.py
[source,python]
----
def add_item(request, list_id):
    pass
----

And then:

----
ValueError: The view lists.views.add_item didn't return an HttpResponse object.
It returned None instead.
----

We can copy the `redirect` from `new_list` and the `List.objects.get` from
`view_list`:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def add_item(request, list_id):
    list_ = List.objects.get(id=list_id)
    return redirect('/lists/%d/' % (list_.id,))
----

That takes us to:

----
    self.assertEqual(Item.objects.count(), 1)
AssertionError: 0 != 1
----

Finally we make it save our new list item:


[role="sourcecode"]
.lists/views.py
[source,python]
----
def add_item(request, list_id):
    list_ = List.objects.get(id=list_id)
    Item.objects.create(text=request.POST['item_text'], list=list_)
    return redirect('/lists/%d/' % (list_.id,))
----

And we're back to passing tests.
(((range="endofrange", startref="ix_Djangoviewfunctions")))
(((range="endofrange", startref="ix_viewfunctions")))

----
Ran 8 tests in 0.050s

OK
----


Testing the response context objects directly
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

((("URLs", "in Django")))
((("Django", "URLs in")))
Now we just need to use this URL in our 'list.html' template.  Open it up and
adjust the form tag...

[role="sourcecode skipme"]
.lists/templates/list.html
[source,html]
----
    <form method="POST" action="but what should we put here?">
----


\... oh. To get the URL for adding to the current list, the template needs to
know what list it's rendering, as well as what the items are.  We want to
be able to do something like this:

[role="sourcecode skipme"]
.lists/templates/list.html
[source,html]
----
    <form method="POST" action="/lists/{{ list.id }}/add_item">
----


For that to work, the view will have to pass the list to the template.
Let's create a new unit test in `ListViewTest`:

[role="sourcecode"]
.lists/tests.py (ch06l041)
[source,python]
----
    def test_passes_correct_list_to_template(self):
        other_list = List.objects.create()
        correct_list = List.objects.create()
        response = self.client.get('/lists/%d/' % (correct_list.id,))
        self.assertEqual(response.context['list'], correct_list)  #<1>
----

//IDEA: explain correct_list, other_list

<1> `response.context` represents the context we're going to pass into
    the render function--the Django test client puts it on the `response`
    object for us, to help with testing.

That gives us:

----
KeyError: 'list'
----

because we're not passing `list` into the template.  It actually gives us an
opportunity to simplify a little:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def view_list(request, list_id):
    list_ = List.objects.get(id=list_id)
    return render(request, 'list.html', {'list': list_})
----

That, of course, will break one of our old tests, because the template
needed `items`:

----
FAIL: test_displays_only_items_for_that_list (lists.tests.ListViewTest)
[...]
AssertionError: False is not true : Couldn't find 'itemey 1' in response
----

But we can fix it in 'list.html', as well as adjusting the form's POST action:

[role="sourcecode"]
.lists/templates/list.html (ch06l043)
[source,html]
----
    <form method="POST" action="/lists/{{ list.id }}/add_item">  <1>

    [...]

        {% for item in list.item_set.all %}  <2>
            <tr><td>{{ forloop.counter }}: {{ item.text }}</td></tr>
        {% endfor %}
----

<1> There's our new form action.

<2> `.item_set` is called a 
    https://docs.djangoproject.com/en/1.10/topics/db/queries/#following-relationships-backward[reverse lookup].
    It's one of Django's incredibly useful bits of ORM that lets you look up an
    object's related items from a different table...

So that gets the unit tests to pass:

----
Ran 9 tests in 0.040s

OK
----

How about the FTs?

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests*]
Creating test database for alias 'default'...
..
 ---------------------------------------------------------------------
Ran 2 tests in 9.771s

OK
Destroying test database for alias 'default'...
----

HOORAY!  Oh, and a quick check on our to-do list:

[role="scratchpad"]
*****
* '[strikethrough line-through]#Get FTs to clean up after themselves#'
* '[strikethrough line-through]#Adjust model so that items are associated with different lists#'
* '[strikethrough line-through]#Add unique URLs for each list#'
* '[strikethrough line-through]#Add a URL for creating a new list via POST#'
* '[strikethrough line-through]#Add URLs for adding a new item to an existing list via POST#'
* 'Refactor away some duplication in urls.py'
*****

((("Testing Goat")))
Irritatingly, the Testing Goat is a stickler for tying up loose ends too, so
we've got to do this one final thing.

((("test-driven development (TDD)", "Working state to working state")))
((("commits")))
Before we start, we'll do a commit--always make sure you've got a commit
of a working state before embarking on a refactor:

[subs="specialcharacters,quotes"]
----
$ *git diff*
$ *git commit -am "new URL + view for adding to existing lists. FT passes :-)"*
----

A Final Refactor Using URL includes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

((("Django", "URLs in")))
'superlists/urls.py' is really meant for URLs that apply to your
entire site.  For URLs that only apply to the `lists` app, Django encourages us
to use a separate 'lists/urls.py', to make the app more self-contained.  The
simplest way to make one is to use a copy of the existing 'urls.py':

[subs="specialcharacters,quotes"]
----
$ *cp superlists/urls.py lists/*
----
//44

Then we replace three lines in 'superlists/urls.py' with an `include`.

[role="sourcecode"]
.superlists/urls.py
[source,python]
----
from django.conf.urls import include, url
from lists import views as list_views  #<1>
from lists import urls as list_urls  #<1>

urlpatterns = [
    url(r'^$', list_views.home_page, name='home'),
    url(r'^lists/', include(list_urls)),  #<2>
]
----
//45

<1> While we're at it, we use the `import x as y` syntax to alias `views` and
    `urls`.  This is good practice in your top-level 'urls.py', because it will
    let us import views and urls from multiple apps if we want--and indeed we
    will need to later on in the book.

<2> Here's the `include`. Notice that it can take a part of a URL regex as a
    prefix, which will be applied to all the included URLs (this is the bit
    where we reduce duplication, as well as giving our code a better
    structure):


Back in 'lists/urls.py' we can trim down to only include the latter part
of our three URLs, and none of the other stuff from the parent 'urls.py':


[role="sourcecode"]
.lists/urls.py (ch06l046)
[source,python]
----
from django.conf.urls import url
from lists import views

urlpatterns = [
    url(r'^new$', views.new_list, name='new_list'),
    url(r'^(\d+)/$', views.view_list, name='view_list'),
    url(r'^(\d+)/add_item$', views.add_item, name='add_item'),
]
----

Rerun the unit tests to check everything worked.  


When I did it, I couldn't quite believe I did it correctly on the first go. It
always pays to be skeptical of your own abilities, so I deliberately changed
one of the URLs slightly, just to check if it broke a test. It did. We're
covered.

Feel free to try it yourself!  Remember to change it back, check the tests
all pass again, and then a final commit:

[subs="specialcharacters,quotes"]
----
$ *git status*
$ *git add lists/urls.py*
$ *git add superlists/urls.py*
$ *git diff --staged*
$ *git commit*
----

Phew. A marathon chapter. But we covered a number of important topics, starting
with test isolation, and then some thinking about design. We covered some rules
of thumb like "YAGNI" and "three strikes then refactor". But, most importantly,
we saw how to adapt an existing site step by step, going from working state to
working state, in order to iterate towards a new design.

I'd say we're pretty close to being able to ship this site, as the very first
beta of the superlists website that's going to take over the world.  Maybe it
needs a little prettification first...let's look at what we need to do to
deploy it in the next couple of chapters.


.Useful TDD Concepts and Rules Of Thumb
*******************************************************************************

Test Isolation and Global State::
    Different tests shouldn't affect one another.  This means we need to
    reset any permanent state at the end of each test. Django's test runner
    helps us do this by creating a test database, which it wipes clean in
    between each test.  (See also <<isolation-chapter>>.)
    ((("test isolation")))
    ((("functional tests/testing (FT)", "isolation in")))

Working State to Working State (aka The Testing Goat vs. Refactoring Cat)::
    Our natural urge is often to dive in and fix everything at once...but if
    we're not careful, we'll end up like Refactoring Cat, in a situation with
    loads of changes to our code and nothing working.  The Testing Goat
    encourages us to take one step at a time, and go from working state to
    working state.
    ((("test-driven development (TDD)", "Working state to working state")))
    ((("Testing Goat")))
    ((("Refactoring Cat")))

YAGNI::
    You ain't gonna need it!  Avoid the temptation to write code that you 
    think 'might' be useful, just because it suggests itself at the time.
    Chances are, you won't use it, or you won't have anticipated your
    future requirements correctly.  See <<outside-in-chapter>> for one
    methodology that helps us avoid this trap.

*******************************************************************************
