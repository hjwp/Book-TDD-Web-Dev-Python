[[chapter_05_post_and_database]]
== Saving User Input: Testing the Database

// ((("user interactions", "testing database input", id="UIdatabase05")))
// disabled due to pdf rendering issue
So far, we've managed to return a static HTML page with an input box in it.
Next, we want to take the text that the user types into that input box and send it to the server,
so that we can save it somehow and display it back to them later.

The first time I started writing code for this chapter,
I immediately wanted to skip to what I thought was the right design:
multiple database tables for lists and list items,
a bunch of different URLs for adding new lists and items,
three new view functions,
and about half a dozen new unit tests for all of the above.
But I stopped myself.
Although I was pretty sure I was smart enough
to handle coding all those problems at once,
the point of TDD is to enable you to do one thing at a time,
when you need to.
So I decided to be deliberately short-sighted,
and at any given moment _only_ do what was necessary
to get the functional tests (FTs) a little further.

((("iterative development style")))
This will be a demonstration of how TDD can support an incremental,
iterative style of development--it
may not be the quickest route, but you do get there in the end.footnote:[
"Geepaw" Hill, another one of the TDD OGs, has
https://oreil.ly/qTCLk[a series of blog posts]
advocating for taking "Many More Much Smaller Steps (MMMSS)".
In this chapter I'm being unrealistically short-sighted for effect,
so don't do that!
But Geepaw argues that in the real world,
when you slice your work into tiny increments,
not only do you get there in the end,
but you end up delivering business value _faster_.
] There's a neat side benefit,
which is that it enables me to introduce new concepts like models,
dealing with POST requests, Django template tags, and so on,
_one at a time_ rather than having to dump them on you all at once.

None of this says that you _shouldn't_ try to think ahead and be clever.
In the next chapter, we'll use a bit more design and up-front thinking,
and show how that fits in with TDD.
But for now, let's plough on mindlessly and just do what the tests tell us to.



=== Wiring Up Our Form to Send a POST Request

((("database testing", "HTML POST requests", "creating", id="DBIpostcreate05")))((("form data validation", "wiring up form to send POST request", id="ix_form")))
((("POST requests", "creating", id="POSTcreate05")))
((("HTML", "POST requests", "creating")))
At the end of the last chapter,
the tests were telling us we weren't able to save the user's input:

----
  File "...goat-book/functional_tests.py", line 40, in
test_can_start_a_todo_list
[...]
AssertionError: False is not true : New to-do item did not appear in table
----

To get it to the server, for now we'll use a standard HTML POST request.
A little boring, but also nice and easy to deliver--we
can use all sorts of sexy HTML5 and JavaScript later in the book.

To get our browser to send a POST request, we need to do two things:

1. Give the `<input>` element a `name=` attribute.
2. Wrap it in a `<form>` tagfootnote:[Did you know that
   you don't need a button to make a form submit?
   I can't remember when I learned that,
   but readers have mentioned that it's unusual
   so I thought I'd draw your attention to it.]
   with `method="POST"`.


=== Testing the Contract Between Frontend and Backend

If you remember in the last chapter, we said we wanted to come back
and revisit the smoke test of our home page template content.((("frontend, testing contract between backend and")))((("backend, testing contract between frontend and")))
Let's have a quick look at our unit tests:


[role="sourcecode currentcontents"]
.lists/tests.py
====
[source,python]
----
class HomePageTest(TestCase):
    def test_uses_home_template(self):
        response = self.client.get("/")
        self.assertTemplateUsed(response, "home.html")

    def test_renders_homepage_content(self):
        response = self.client.get("/")
        self.assertContains(response, "To-Do")
----
====

What's important about our home page content?
How can we obey both the "don't test constants" rule
and the "test behaviour, not implementation" rule?

The specific spelling of the word "To-Do" is not important.
As we've just seen, the most important _behaviour_ that our home page is enabling,
is the ability to submit a to-do item.((("behaviour", "testing for To-Do page")))
The way we're going to deliver that is by adding a `<form>` tag with `method="POST"`,
and inside that, making sure our `<input>` has a `name="item_text"`.

Our FTs are telling us that it's not working at a high level,
so what unit tests can we write at the lower level?((("unit tests", "writing for form in To-Do list home page")))  Let's start with the form:


[role="sourcecode"]
.lists/tests.py (ch05l001)
====
[source,python]
----
class HomePageTest(TestCase):
    def test_uses_home_template(self):
        [...]

    def test_renders_input_form(self):  # <1>
        response = self.client.get("/")
        self.assertContains(response, '<form method="POST">')  # <2>
----
====

<1> We change the name of the test.
<2> And we assert on the `<form>` tag specifically.

That gives us:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test*]
[...]
AssertionError: False is not true : Couldn't find '<form method="POST">' in the
following response
b'<html>\n  <head>\n    <title>To-Do lists</title>\n  </head>\n  <body>\n
<h1>Your To-Do list</h1>\n    <input id="id_new_item" placeholder="Enter a
to-do item" />\n    <table id="id_list_table">\n    </table>\n
</body>\n</html>\n'
----


Let's adjust our template at 'lists/templates/home.html':

[role="sourcecode"]
.lists/templates/home.html (ch05l002)
====
[source,html]
----
    <h1>Your To-Do list</h1>
    <form method="POST">
      <input id="id_new_item" placeholder="Enter a to-do item" />
    </form>
----
====

That gives us passing unit tests:

----
OK
----

And next, let's add a test for the `name=` attribute on the `<input>` tag:


[role="sourcecode"]
.lists/tests.py (ch05l003)
====
[source,python]
----
    def test_renders_input_form(self):
        response = self.client.get("/")
        self.assertContains(response, '<form method="POST">')
        self.assertContains(response, '<input name="item_text"')
----
====

[role="pagebreak-before"]
That gives us this expected failure:

----
[...]
AssertionError: False is not true : Couldn't find '<input name="item_text"' in
the following response
b'<html>\n  <head>\n    <title>To-Do lists</title>\n  </head>\n  <body>\n
<h1>Your To-Do list</h1>\n    <form method="POST">\n      <input
id="id_new_item" placeholder="Enter a to-do item" />\n    </form>\n    <table
id="id_list_table">\n    </table>\n  </body>\n</html>\n'
----


And we fix it like this:

[role="sourcecode small-code"]
.lists/templates/home.html (ch05l004)
====
[source,html]
----
    <h1>Your To-Do list</h1>
    <form method="POST">
      <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
    </form>
    <table id="id_list_table">
----
====

That gives us passing unit tests:

----
OK
----

The lesson here is that we've tried to identify the "contract" between
the frontend and the backend of our site.  For our HTML form to work,
it needs the form with the right `method`, and the input with the right `name`.
Everything else is cosmetic. So that's what we test for in our unit tests.((("form data validation", "wiring up form to send POST request", startref="ix_form")))


=== Debugging Functional Tests

Time to go back to our FT.((("functional  tests (FTs)", "debugging for To-Do list home page form", id="ix_FTdbg"))) It gives us a slightly cryptic, unexpected error:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python functional_tests.py*]
[...]
Traceback (most recent call last):
  File "...goat-book/functional_tests.py", line 38, in
test_can_start_a_todo_list
    table = self.browser.find_element(By.ID, "id_list_table")
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: [id="id_list_table"]; [...]
----

Oh dear, we're now failing two lines _earlier_,
after we submit the form, but before we are able to do the assert.
Selenium seems to be unable to find our list table.
Why on earth would that happen?
Let's take another look at our code:


[role="sourcecode currentcontents"]
.functional_tests.py
====
[source,python]
----
        # When she hits enter, the page updates, and now the page lists
        # "1: Buy peacock feathers" as an item in a to-do list table
        inputbox.send_keys(Keys.ENTER)
        time.sleep(1)

        table = self.browser.find_element(By.ID, "id_list_table")  # <1>
        rows = table.find_elements(By.TAG_NAME, "tr")
        self.assertTrue(
            any(row.text == "1: Buy peacock feathers" for row in rows),
            "New to-do item did not appear in table",
        )
----
====

<1> Our test unexpectedly fails on this line.
    How do we figure out what's going on?


((("functional tests (FTs)", "debugging techniques")))
((("time.sleeps")))
((("error messages", seealso="troubleshooting")))
((("print", "debugging with")))
((("debugging", "of functional tests")))
When a functional test fails with an unexpected failure, there are several
things we can do to debug it:

* Add `print` statements to show, for example, what the current page text is.
* Improve the _error message_ to show more info about the current state.
* Manually visit the site yourself.
* Use `time.sleep` to pause the test during execution so you can inspect what was happening.footnote:[
Another common technique for debugging tests is to use `breakpoint()` to drop into a debugger like `pdb`.
This is more useful for _unit_ tests rather than FTs though,
because in an FT you usually can't step into actual application code.
Personally, I only find debuggers useful for really fiddly algorithms,
which we won't see in this book.]

We'll look at all of these over the course of this book,
but the `time.sleep` option is the one that leaps to mind with this kind of error in an FT.
Let's try it now.((("sleep", see="time.sleeps")))


==== Debugging with time.sleep

Conveniently, we've already got a ((("time.sleeps", "debugging with")))sleep just before the error occurs;
let's just extend it a little:

[role="sourcecode"]
.functional_tests.py (ch05l005)
====
[source,python]
----
    # When she hits enter, the page updates, and now the page lists
    # "1: Buy peacock feathers" as an item in a to-do list table
    inputbox.send_keys(Keys.ENTER)
    time.sleep(10)

    table = self.browser.find_element(By.ID, "id_list_table")
----
====

((("debugging", "Django debug page")))
Depending on how fast Selenium runs on your PC,
you may have caught a glimpse of this already,
but when we run the FTs again,
we've got time to see what's going on:
you should see a page that looks like
<<csrf_error_screenshot>>, with lots of Django debug information.


[[csrf_error_screenshot]]
.Django debug page showing CSRF error
image::images/tdd3_0501.png["Django debug page showing CSRF error"]


.Security: Surprisingly Fun!
*******************************************************************************
((("cross-site request forgery (CSRF)")))
((("security issues and settings", "cross-site request forgery")))
If you've never heard of a _cross-site request forgery_ (CSRF) exploit, why not look it up now?
Like all security exploits, it's entertaining to read about,
being an ingenious use of a system in unexpected ways.

When I went to university to get my computer science degree,
I signed up for the "security" module out of a sense of duty:
_Oh well, it'll probably be very dry and boring,
but I suppose I'd better take it.
Eat your vegetables, and so forth_.
It turned out to be one of the most fascinating modules of the whole course!
Absolutely full of the joy of hacking, of the particular mindset it takes
to think about how systems can be used in unintended ways.

I want to recommend the textbook from that course,
Ross Anderson's https://oreil.ly/TKmYQ[_Security Engineering_].
It's quite light on pure crypto,
but it's absolutely full of interesting discussions of unexpected topics like lock picking,
forging bank notes, inkjet printer cartridge [keep-together]#economics#,
and spoofing South African Air Force jets with replay attacks.
It's a huge tome, about three inches thick,
and I promise you it's an absolute page-turner.
*******************************************************************************


((("templates", "tags", "{% csrf_token %}")))
((("{% csrf_token %}")))
Django's CSRF protection involves placing a little autogenerated unique token into each generated form,
to be able to verify that POST requests have definitely come from the form generated by the server.
So far, our template has been pure HTML,
and in this step we make the first use of Django's template magic.
To add the CSRF token, we use a 'template tag',
which has the curly-bracket/percent syntax,
`{% ... %}`&mdash;famous for being the world's most annoying two-key touch-typing
combination:


// IDEA: unit test this?  can use Client(enforce_csrf_checks=True)

[role="sourcecode"]
.lists/templates/home.html (ch05l006)
====
[source,html]
----
  <form method="POST">
    <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
    {% csrf_token %}
  </form>
----
====

Django will substitute the template tag during rendering with an `<input type="hidden">`
containing the CSRF token.
Rerunning the functional test will now bring us back to our previous (expected) failure:

----
  File "...goat-book/functional_tests.py", line 40, in
test_can_start_a_todo_list
[...]
AssertionError: False is not true : New to-do item did not appear in table
----

Because our long `time.sleep` is still there, the test will pause on the final
screen, showing us that the new item text disappears after the form is
submitted, and the page refreshes to show an empty form again.  That's because
we haven't wired up our server to deal with the POST request yet--it just
ignores it and displays the normal home page.


((("", startref="DBIpostcreate05")))
((("", startref="POSTcreate05")))
We can put our normal short `time.sleep` back now though:

[role="sourcecode"]
.functional_tests.py (ch05l007)
====
[source,python]
----
    # "1: Buy peacock feathers" as an item in a to-do list table
    inputbox.send_keys(Keys.ENTER)
    time.sleep(1)

    table = self.browser.find_element(By.ID, "id_list_table")
----
====



=== Processing a POST Request on the Server

((("functional  tests (FTs)", "debugging for To-Do list home page form", startref="ix_FTdbg")))((("database testing", "HTML POST requests", "processing")))
((("POST requests", "processing")))
((("HTML", "POST requests", "processing")))
Because we haven't specified an `action=` attribute in the form,
it is submitting back to the same URL it was rendered from by default (i.e., `/`),
which is dealt with by our `home_page` function.
That's fine for now; let's adapt the view to be able to deal with a POST request.

That means a new unit test for the `home_page` view.
Open up 'lists/tests.py', and add a new method to `HomePageTest`:

[role="sourcecode small-code"]
.lists/tests.py (ch05l008)
====
[source,python]
----
class HomePageTest(TestCase):
    def test_uses_home_template(self):
        [...]
    def test_renders_input_form(self):
        response = self.client.get("/")
        self.assertContains(response, '<form method="POST">')
        self.assertContains(response, '<input name="item_text"')  # <2>

    def test_can_save_a_POST_request(self):
        response = self.client.post("/", data={"item_text": "A new list item"})  # <1><2>
        self.assertContains(response, "A new list item")  # <3>
----
====

<1> To do a POST, we call `self.client.post` and, as you can see, it takes
  a `data` argument that contains the form data we want to send.

<2> Notice the echo of the `item_text` name from earlier.footnote:[
    You could even define a constant for this, to make the link more explicit.]

<3> Then we check that the text from our POST request ends up in the rendered HTML.

That gives us our expected fail:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test*]
[...]
AssertionError: False is not true : Couldn't find 'A new list item' in the
following response
b'<html>\n  <head>\n    <title>To-Do lists</title>\n  </head>\n  <body>\n
<h1>Your To-Do list</h1>\n    <form method="POST">\n      <input
name="item_text" id="id_new_item" placeholder="Enter a to-do item" />\n
<input type="hidden" name="csrfmiddlewaretoken"
value="[...]
</form>\n    <table id="id_list_table">\n    </table>\n  </body>\n</html>\n'
----


In (slightly exaggerated) TDD style,
we can single-mindedly do "the simplest thing that could possibly work"
to address this test failure,
which is to add an `if` and a new code path for POST requests,
with a deliberately silly return value:

[role="sourcecode"]
.lists/views.py (ch05l009)
====
[source,python]
----
from django.http import HttpResponse
from django.shortcuts import render


def home_page(request):
    if request.method == "POST":  # <1>
        return HttpResponse("You submitted: " + request.POST["item_text"])  # <2>
    return render(request, "home.html")
----
====

<1> `request.method` lets us check whether we got a POST or a GET request.

<2> `request.POST` is a dictionary-like object containing the form data
    (in this case, the `item_text` value we expect from the form `input` tag).

Fine, that gets our unit tests passing:

----
OK
----

...but it's not really what we want.footnote:[
But we _did_ learn about `request.method` and `request.POST`, right?
I know it might seem that I'm overdoing it,
but doing things in tiny little steps really does have a lot of advantages,
and one of them is that you can really think about (or in this case, learn)
one thing at a time.]

And even if we were genuinely hoping this was the right solution,
our FTs are here to remind us that this isn't how things are supposed to work:


----
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: [id="id_list_table"]; [...]
----


The list table disappears after the form submission.
If you didn't see it in the FT run, try it manually with `runserver`;
you'll see something like <<table_gone_screenshot>>.

[[table_gone_screenshot]]
.I see my item text but no table...
image::images/tdd3_0502.png["A screenshot of the page after submission, which just has the raw text You submitted: Buy asparagus"]

What we really want to do is add the POST submission
to the to-do items table in the home page template.
We need some sort of way to pass data from our view,
to be shown in the template.


=== Passing Python Variables to Be Rendered in the Template

We've already had a hint of it,
and now it's time to start to get to know the real power of the Django template syntax,
which is to pass variables from our Python view code into HTML templates.((("database testing", "template syntax", id="DTtemplate05")))((("templates", "syntax")))((("templates", "passing variables to")))

Let's start by seeing how the template syntax lets us include a Python object in our template.
The notation is `{{ ... }}`, which displays the object as a string:

[role="sourcecode small-code"]
.lists/templates/home.html (ch05l010)
====
[source,html]
----
<body>
  <h1>Your To-Do list</h1>
  <form method="POST">
    <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
    {% csrf_token %}
  </form>
  <table id="id_list_table">
    <tr><td>{{ new_item_text }}</td></tr>  <1>
  </table>
</body>
----
====

<1> Here's our template variable.
    `new_item_text` will be the variable name for the user input we display in the template.

Let's adjust our unit test so that it checks whether we are still using the template:


[role="sourcecode"]
.lists/tests.py (ch05l011)
====
[source,python]
----
    def test_can_save_a_POST_request(self):
        response = self.client.post("/", data={"item_text": "A new list item"})
        self.assertContains(response, "A new list item")
        self.assertTemplateUsed(response, "home.html")
----
====

And that will fail as expected:

----
AssertionError: No templates used to render the response
----

Good; our deliberately silly return value is now no longer fooling our tests,
so we are allowed to rewrite our view, and tell it to pass the POST parameter to the template.
The `render` function takes, as its third argument, a dictionary,
which maps template variable names to their values.

In theory, we can use it for the POST case as well as the default GET case,
so let's remove the `if request.method == "POST"` and simplify our view right down to:

[role="sourcecode"]
.lists/views.py (ch05l012)
====
[source,python]
----
def home_page(request):
    return render(
        request,
        "home.html",
        {"new_item_text": request.POST["item_text"]},
    )
----
====

What do the tests think?

----
ERROR: test_uses_home_template
(lists.tests.HomePageTest.test_uses_home_template)

[...]
    {"new_item_text": request.POST["item_text"]},
                      ~~~~~~~~~~~~^^^^^^^^^^^^^
[...]
django.utils.datastructures.MultiValueDictKeyError: 'item_text'

----


==== An Unexpected Failure

((("unexpected failures")))
((("Test-Driven Development (TDD)", "concepts", "unexpected failures")))
Oops, an _unexpected failure_.

If you remember the rules for reading tracebacks,
you'll spot that it's actually a failure in a _different_ test.
We got the actual test we were working on to pass,
but the unit tests have picked up an unexpected consequence, a regression:
we broke the code path where there is no POST request.

This is the whole point of having tests.
Yes, perhaps we could have predicted this would happen,
but imagine if we'd been having a bad day or weren't paying attention:
our tests have just saved us from accidentally breaking our application
and, because we're using TDD, we found out immediately.
We didn't have to wait for a QA team,
or switch to a web browser and click through our site manually,
so we can get on with fixing it straight away.
Here's how:


[role="sourcecode"]
.lists/views.py (ch05l013)
====
[source,python]
----
def home_page(request):
    return render(
        request,
        "home.html",
        {"new_item_text": request.POST.get("item_text", "")},
    )
----
====

We use http://docs.python.org/3/library/stdtypes.html#dict.get[`dict.get`] to
supply a default value, for the case where we are doing a normal GET request,
when the POST dictionary is empty.

[role="pagebreak-before"]
The unit tests should now pass.  Let's see what the FTs say:

----
AssertionError: False is not true : New to-do item did not appear in table
----


TIP: If your functional tests show you a different error at this point,
    or at any point in this chapter, complaining about a
    +S&#x2060;t&#x2060;a&#x2060;l&#x2060;e&#x2060;E&#x2060;l&#x2060;e&#x2060;m&#x2060;e&#x2060;n&#x2060;t&#x200b;R&#x2060;e&#x2060;f&#x2060;e&#x2060;r&#x2060;e&#x2060;n&#x2060;c&#x2060;e&#x2060;Exception+, you may need to increase the
    `time.sleep` explicit wait--try two or three seconds instead of one;
    then read on to the next chapter for a more robust solution.


==== Improving Error Messages in Tests

((("debugging", "improving error messages")))((("error messages", "improving in tests")))
Hmm, not a wonderfully helpful error.
Let's use another of our FT debugging techniques: improving the error message.
This is probably the most constructive technique,
because those improved error messages stay around to help debug any future errors:

[role="sourcecode"]
.functional_tests.py (ch05l014)
====
[source,python]
----
self.assertTrue(
    any(row.text == "1: Buy peacock feathers" for row in rows),
    f"New to-do item did not appear in table. Contents were:\n{table.text}",
)
----
====

That gives us a more helpful message:

----
AssertionError: False is not true : New to-do item did not appear in table.
Contents were:
Buy peacock feathers
----

Actually, you know what would be even better?
Making that assertion a bit less clever!
As you may remember from <<chapter_04_philosophy_and_refactoring>>,
I was very pleased with myself for using the `any()` function,
but one of my early release readers (thanks, Jason!) suggested a much simpler implementation.
We can replace all four lines of the `assertTrue` with a single `assertIn`:

[role="sourcecode"]
.functional_tests.py (ch05l015)
====
[source,python]
----
    self.assertIn("1: Buy peacock feathers", [row.text for row in rows])
----
====

Much better.
You should always be very worried whenever you think you're being clever,
because what you're probably being is _overcomplicated_.

Now we get the error message for free:

----
    self.assertIn("1: Buy peacock feathers", [row.text for row in rows])
AssertionError: '1: Buy peacock feathers' not found in ['Buy peacock feathers']
----


Consider me suitably chastened.

TIP: If, instead, your FT seems to be saying the table is empty ("not found in
    ['']"), check your `<input>` tag--does it have the correct
    `name="item_text"` attribute?  And does it have `method="POST"`?  Without
    them, the user's input won't be in the right place in `request.POST`.

The point is that the FT wants us to enumerate list items with a "1:" at the
beginning of the first list item.

The fastest way to get that to pass is with another quick "cheating" change to the template:


[role="sourcecode"]
.lists/templates/home.html (ch05l016)
====
[source,html]
----
    <tr><td>1: {{ new_item_text }}</td></tr>
----
====


.When Should You Stop Cheating? DRY Versus Triangulation
*******************************************************************************
People often ask about when it's OK to "stop cheating",
and change from an implementation we know to be wrong,
to one we're happy with.((("Test-Driven Development (TDD)", "concepts", "triangulation")))
((("triangulation")))
((("Don't Repeat Yourself (DRY)")))
((("Test-Driven Development (TDD)", "concepts", "DRY")))
((("duplication, eliminating")))

One justification is _eliminate duplication_—aka DRY (don’t repeat yourself)—which (with some caveats) is a good guideline for any kind of code.

If your test uses a magic constant (like the "1:" in front of our list item),
and your application code also uses it,
some people say _that_ counts as duplication, so it justifies refactoring.
Removing the magic constant from the application code usually means you have to stop cheating.

It's a judgement call,
but I feel that this is stretching the definition of "repetition" a little,
so I often like to use a second technique, which is called _triangulation_:
if your tests let you get away with writing "cheating" code that you're not happy with
(like returning a magic constant),
then _write another test_ that forces you to write some better code.
That's what we're doing when we extend the FT
to check that we get a "2:" when inputting a second list item.

See also <<three_strikes_and_refactor>> for a further note of caution
on applying DRY too quickly.

*******************************************************************************

[role="pagebreak-before"]
Now we get to the `self.fail('Finish the test!')`.
If we get rid of that and finish writing our FT,
to add the check for adding a second item to the table
(copy and paste is our friend),
we begin to see that our first cut solution really isn't going to, um, cut it:

[role="sourcecode"]
.functional_tests.py (ch05l017)
====
[source,python]
----
    # There is still a text box inviting her to add another item.
    # She enters "Use peacock feathers to make a fly"
    # (Edith is very methodical)
    inputbox = self.browser.find_element(By.ID, "id_new_item")
    inputbox.send_keys("Use peacock feathers to make a fly")
    inputbox.send_keys(Keys.ENTER)
    time.sleep(1)

    # The page updates again, and now shows both items on her list
    table = self.browser.find_element(By.ID, "id_list_table")
    rows = table.find_elements(By.TAG_NAME, "tr")
    self.assertIn(
        "2: Use peacock feathers to make a fly",
        [row.text for row in rows],
    )
    self.assertIn(
        "1: Buy peacock feathers",
        [row.text for row in rows],
    )

    # Satisfied, she goes back to sleep
----
====

((("", startref="DTtemplate05")))
Sure enough, the FTs return an error:

----
AssertionError: '2: Use peacock feathers to make a fly' not found in ['1: Use
peacock feathers to make a fly']
----

[role="pagebreak-before less_space"]
[[three_strikes_and_refactor]]
=== Three Strikes and Refactor

((("code smell")))
((("three strikes and refactor rule", id="threestrikes05")))
((("refactoring", id="refactor05")))
But before we go further--we've got a bad __code smell__footnote:[
If you've not come across the concept, a "code smell" is
something about a piece of code that makes you want to rewrite it. Jeff Atwood
has https://oreil.ly/GFrNp[a compilation on
his blog, _Coding Horror_]. The more experience you gain as a programmer, the more
fine-tuned your nose becomes to code smells...]
in this FT.
We have three almost identical code blocks checking for new items in the list table.
((("Don’t Repeat Yourself (DRY)")))
When we want to apply the DRY principle,
I like to follow the motto _three strikes and refactor_.
You can copy and paste code once,
and it may be premature to try to remove the duplication it causes,
but once you get three occurrences, it's time to tidy up.

Let's start by committing what we have so far. Even though we know our site
has a major flaw--it can only handle one list item--it's still further ahead than it was.
We may have to rewrite it all, and we may not, but the rule
is that before you do any refactoring, always do a commit:

[subs="specialcharacters,quotes"]
----
$ *git diff*
# should show changes to functional_tests.py, home.html,
# tests.py and views.py
$ *git commit -a*
----


TIP:  Always do a commit before embarking on a refactor.

// TODO: also, make sure the tests are passing?

Onto our functional test refactor. Let's use a helper method--remember,
only methods that begin with `test_` will be run as tests,
so you can use other methods for your own purposes:

[role="sourcecode"]
.functional_tests.py (ch05l018)
====
[source,python]
----
    def tearDown(self):
        self.browser.quit()

    def check_for_row_in_list_table(self, row_text):
        table = self.browser.find_element(By.ID, "id_list_table")
        rows = table.find_elements(By.TAG_NAME, "tr")
        self.assertIn(row_text, [row.text for row in rows])

    def test_can_start_a_todo_list(self):
        [...]
----
====

[role="pagebreak-before"]
I like to put helper methods near the top of the class, between the `tearDown`
and the first test. Let's use it in the FT:

[role="sourcecode"]
.functional_tests.py (ch05l019)
====
[source,python]
----
    # When she hits enter, the page updates, and now the page lists
    # "1: Buy peacock feathers" as an item in a to-do list table
    inputbox.send_keys(Keys.ENTER)
    time.sleep(1)
    self.check_for_row_in_list_table("1: Buy peacock feathers")

    # There is still a text box inviting her to add another item.
    # She enters "Use peacock feathers to make a fly"
    # (Edith is very methodical)
    inputbox = self.browser.find_element(By.ID, "id_new_item")
    inputbox.send_keys("Use peacock feathers to make a fly")
    inputbox.send_keys(Keys.ENTER)
    time.sleep(1)

    # The page updates again, and now shows both items on her list
    self.check_for_row_in_list_table("2: Use peacock feathers to make a fly")
    self.check_for_row_in_list_table("1: Buy peacock feathers")

    # Satisfied, she goes back to sleep
----
====

We run the FT again to check that it still behaves in the same way:

----
AssertionError: '2: Use peacock feathers to make a fly' not found in ['1: Use
peacock feathers to make a fly']
----

Good. Now we can commit the FT refactor as its own small, atomic change:


[subs="specialcharacters,quotes"]
----
$ *git diff* # check the changes to functional_tests.py
$ *git commit -a*
----


There are a couple more bits of duplication in the FTs,
like the repetition of finding the `inputbox`,
but they're not as egregious yet, so we'll deal with them later.

// SEBASTIAN: One could mention there's still an option to cheat and keep items in a list in memory.
//    I think there's no need to demonstrate it, though.

Instead, back to work.
If we're ever going to handle more than one list item,
we're going to need some kind of persistence,
and databases are a stalwart solution in this area.
((("", startref="threestrikes05")))
((("", startref="refactor05")))


[role="pagebreak-before less_space"]
[[django_ORM_first_model]]
=== The Django ORM and Our First Model

((("Object-Relational Mapper (ORM)", id="orm05")))
((("Django framework", "Object-Relational Mapper (ORM)", id="DJForm05")))
((("database testing", "Object-Relational Mapper (ORM)", id="DBTorm05")))
An Object-Relational Mapper (ORM) is a layer of abstraction for data stored in a database
with tables, rows, and columns.
It lets us work with databases using familiar object-oriented metaphors that work well with code.
Classes map to database tables, attributes map to columns,
and an individual instance of the class represents a row of data in the database.

Django comes with an excellent ORM,
and writing a unit test that uses it is actually an excellent way of learning it,
because it exercises code by specifying how we want it to work.

// SEBASTIAN: This reminds me of (https://github.com/gregmalcolm/python_koans)[Python Koans].
//    Perhaps one could link it here as an example of learning with tests

Let's create a new class in _lists/tests.py_:

[role="sourcecode"]
.lists/tests.py (ch05l020)
====
[source,python]
----
from django.test import TestCase
from lists.models import Item


class HomePageTest(TestCase):
    [...]


class ItemModelTest(TestCase):
    def test_saving_and_retrieving_items(self):
        first_item = Item()
        first_item.text = "The first (ever) list item"
        first_item.save()

        second_item = Item()
        second_item.text = "Item the second"
        second_item.save()

        saved_items = Item.objects.all()
        self.assertEqual(saved_items.count(), 2)

        first_saved_item = saved_items[0]
        second_saved_item = saved_items[1]
        self.assertEqual(first_saved_item.text, "The first (ever) list item")
        self.assertEqual(second_saved_item.text, "Item the second")
----
====

You can see that creating a new record in the database
is a relatively simple matter of creating an object,
assigning some attributes, and calling a `.save()` function.
Django also gives us an API for querying the database
via a class attribute, `.objects`,
and we use the simplest possible query, `.all()`,
which retrieves all the records for that table.
The results are returned as a list-like object called a `QuerySet`,
from which we can extract individual objects,
and also call further functions, like `.count()`.
We then check the objects as saved to the database,
to check whether the right information was saved.


((("Django framework", "tutorials")))
Django's ORM has many other helpful and intuitive features;
this might be a good time to skim through the
https://docs.djangoproject.com/en/5.2/intro/tutorial01[Django tutorial],
which has an excellent intro to them.

NOTE: I've written this unit test in a very verbose style,
    as a way of introducing the Django ORM.
    I wouldn't recommend writing your model tests like this "in real life",
    because it's testing the framework, rather than testing our own code.
    We'll actually rewrite this test to be much more concise
    in <<chapter_16_advanced_forms>>
    (specifically, at <<rewrite-model-test>>).


.Unit Tests Versus Integration Tests, and the Database
*******************************************************************************
((("unit tests", "versus integration tests", secondary-sortas="integration")))
((("integration tests", "versus unit tests", secondary-sortas="unit")))
Some people will tell you that a "real" unit test should never touch the database,
and that the test I've just written should be more properly called an "integration" test,
because it doesn't _only_ test our code,
but also relies on an external system--that is, a database.

It's OK to ignore this distinction for now--we have two types of test:
the high-level FTs, which test the application from the user's point of view,
and these lower-level tests, which test it from the programmer's point of view.

We'll come back to this topic
and talk about the differences between unit tests, integration tests, and more
in <<chapter_27_hot_lava>>, at the end of the book.
*******************************************************************************

Let's try running the unit test. Here comes another unit-test/code cycle:

[subs="specialcharacters,macros"]
----
ImportError: cannot import name 'Item' from 'lists.models'
----

Very well, let's give it something to import from 'lists/models.py'.  We're
feeling confident so we'll skip the `Item = None` step, and go straight to
creating a class:

[[first-django-model]]
[role="sourcecode"]
.lists/models.py (ch05l021)
====
[source,python]
----
from django.db import models

# Create your models here.
class Item:
    pass
----
====

[role="pagebreak-before"]
That gets our test as far as:

----
[...]
  File "...goat-book/lists/tests.py", line 25, in
test_saving_and_retrieving_items
    first_item.save()
    ^^^^^^^^^^^^^^^
AttributeError: 'Item' object has no attribute 'save'
----

To give our `Item` class a `save` method, and to make it into a real Django
model, we make it inherit from the `Model` class:


[role="sourcecode"]
.lists/models.py (ch05l022)
====
[source,python]
----
from django.db import models


class Item(models.Model):
    pass
----
====


==== Our First Database Migration

((("database migrations")))
The next thing that happens is a huuuuge traceback,
the long and short of which is that there's a problem with the database:

----
django.db.utils.OperationalError: no such table: lists_item
----

In Django, the ORM's job is to model and read and write from database tables,
but there's a second system that's in charge of actually _creating_
the tables in the database called "migrations".
Its job is to let you add, remove, and modify tables and columns,
based on changes you make to your _models.py_ files.

One way to think of it is as a version control system (VCS) for your database.
As we'll see later, it proves particularly useful
when we need to upgrade a database that's deployed on a live server.

For now all we need to know is how to build our first database migration,
which we do using the `makemigrations` command:footnote:[
If you've done a bit of Django before,
you may be wondering about when we're going to run "migrate" as well as "makemigrations"?
Read on; that's coming up later in the chapter.]


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py makemigrations*]
Migrations for 'lists':
  lists/migrations/0001_initial.py
    + Create model Item
$ pass:quotes[*ls lists/migrations*]
0001_initial.py  __init__.py  __pycache__
----

If you're curious, you can go and take a look in the migrations file,
and you'll see it's a representation of our additions to 'models.py'.

In the meantime, we should find that our tests get a little further.


==== The Test Gets Surprisingly Far

The test actually gets surprisingly far:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test*]
[...]
    self.assertEqual(first_saved_item.text, "The first (ever) list item")
                     ^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'Item' object has no attribute 'text'
----

That's a full eight lines later than the last failure--we've
been all the way through saving the two ++Item++s,
and we've checked that they're saved in the database,
but Django just doesn't seem to have "remembered" the `.text` attribute.

If you're new to Python, you might have been surprised
that we were allowed to assign the `.text` attribute at all.
In a language like Java, you would probably get a compilation error.
Python is more relaxed.

Classes that inherit from `models.Model` will map to tables in the database.
By default, they get an autogenerated `id` attribute,
which will be a primary key columnfootnote:[
Database tables usually have a special column called a "primary key",
which is the unique identifier for each row in the table.((("primary key")))
It's worth brushing up on a _tiny_ bit of relational database theory,
if you're not familiar with the concept or why it's useful.((("relational database theory")))
The top three articles I found when searching for "introduction to databases"
all seemed pretty good, at the time of writing.]
in the database,
but you have to define any other columns and attributes you want explicitly.
Here's how we set up a text column:

[role="sourcecode"]
.lists/models.py (ch05l024)
====
[source,python]
----
class Item(models.Model):
    text = models.TextField()
----
====

Django has many other field types, like `IntegerField`, `CharField`,
`DateField`, and so on.  I've chosen `TextField` rather than `CharField` because
the latter requires a length restriction, which seems arbitrary at this point.
You can read more on field types in the Django
https://docs.djangoproject.com/en/5.2/intro/tutorial02/#creating-models[tutorial]
and in the
https://docs.djangoproject.com/en/5.2/ref/models/fields[documentation].


[role="pagebreak-before less_space"]
==== A New Field Means a New Migration

Running the tests gives us another database error:

----
django.db.utils.OperationalError: table lists_item has no column named text
----

It's because we've added another new field to our database, which means we need
to create another migration.((("database migrations", "new field requiring new migration")))  Nice of our tests to let us know!

Let's try it:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py makemigrations*]
It is impossible to add a non-nullable field 'text' to item without specifying
a default. This is because the database needs something to populate existing
rows.
Please select a fix:
 1) Provide a one-off default now (will be set on all existing rows with a null
value for this column)
 2) Quit and manually define a default value in models.py.
Select an option:pass:quotes[*2*]
----


Ah.  It won't let us add the column without a default value.  Let's pick option
2 and set a default in 'models.py'.  I think you'll find the syntax reasonably
self-explanatory:


[role="sourcecode"]
.lists/models.py (ch05l025)
====
[source,python]
----
class Item(models.Model):
    text = models.TextField(default="")
----
====


//IDEA: default could get another unit test, which could actually replace the
// overly verbose one.

And now the migration should complete:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py makemigrations*]
Migrations for 'lists':
  lists/migrations/0002_item_text.py
    + Add field text to item
----

So, two new lines in 'models.py', two database migrations, and as a result,
the `.text` attribute on our model objects is now recognised as a special attribute,
so it does get saved to the database, and the tests pass:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test*]
[...]

Ran 4 tests in 0.010s
OK
----


((("", startref="orm05")))
((("", startref="DBTorm05")))
((("", startref="DJForm05")))
So let's do a commit for our first ever model!

[subs="specialcharacters,quotes"]
----
$ *git status* # see tests.py, models.py, and 2 untracked migrations
$ *git diff* # review changes to tests.py and models.py
$ *git add lists*
$ *git commit -m "Model for list Items and associated migration"*
----


=== Saving the POST to the Database

So, we have a model; now we need to use it!

((("database testing", "HTML POST requests", "saving", id="DTpostsave05")))
((("HTML", "POST requests", "saving", id="HTMLpostsave05")))
((("POST requests", "saving", id="POSTsave05")))
Let's adjust the test for our home page POST request,
and say we want the view to save a new item to the database
instead of just passing it through to its response.
We can do that by adding three new lines to the existing test called
+test_can_save_a_POST_request+:

[role="sourcecode"]
.lists/tests.py (ch05l027)
====
[source,python]
----
def test_can_save_a_POST_request(self):
    response = self.client.post("/", data={"item_text": "A new list item"})

    self.assertEqual(Item.objects.count(), 1)  # <1>
    new_item = Item.objects.first()  # <2>
    self.assertEqual(new_item.text, "A new list item")  # <3>

    self.assertContains(response, "A new list item")
    self.assertTemplateUsed(response, "home.html")
----
====

<1> We check that one new `Item` has been saved to the database.
    `objects.count()` is a shorthand for `objects.all().count()`.

<2> `objects.first()` is the same as doing `objects.all()[0]`,
    except it will return `None` if there are no objects.footnote:[
    You can also use `objects.get()`, which will immediately raise an exception
    if there are no objects in the database, or if there are more than one.
    On the plus side you get a more immediate failure,
    and you get warned if there are too many objects.
    The downside is that I find it slightly less readable.
    As so often, it's a trade-off.]

<3> We check that the item's text is correct.


[role="pagebreak-before"]
((("unit tests", "length of")))
This test is getting a little long-winded.
It seems to be testing lots of different things.
That's another _code smell_&mdash;a
long unit test either needs to be broken into two,
or it may be an indication that the thing you're testing is too complicated.
Let's add that to a little to-do list of our own,
perhaps on a piece of scrap paper:


[role="scratchpad"]
*****
* 'Code smell: POST test is too long?'
*****


.An Alternative Testing Strategy: Staying at the HTTP Level
*******************************************************************************

It's a very common pattern in Django to test POST views
by asserting on the side effects, as seen in the database.
Sandi Metz, a TDD legend from the Ruby world, puts it like this:
"test commands via public side effects".footnote:[
This advice is in her talk
https://oreil.ly/Gqxgg[The Magic Tricks of Testing],
which I highly recommend watching.]

But is the database really a public API?  That's arguable.
Certainly it's at a different level of abstraction,
or a different conceptual "layer" in the application,
to the HTTP requests we're working with in our current unit tests.

If you wanted to write our tests in a way that stays at the HTTP level—that treats the application as more of an "opaque box"—you can prove to yourself that to-do items are persisted,
by sending more than one:

[role="sourcecode skipme"]
.lists/tests/test_views.py
====
[source,python]
----
def test_can_save_multiple_items(self):
    self.client.post("/", data={"item_text": "first item"})
    response = self.client.post("/", data={"item_text": "second item"})
    self.assertContains(response, "first item")
    self.assertContains(response, "second item")
----
====

If you feel like going off road, why not give it a try?


////
HARRY NOTES 2023-07-07

had a quick go at a new flow for the chapter based on this idea.

https://github.com/hjwp/book-example/tree/chapter_05_post_and_database_possible_alternative

    def test_post_saves_items(self):
        self.client.post("/", data={"item_text": "onions"})
        response1 = self.client.get("/")
        self.assertContains(response1, "onions")

    def test_multiple_posts_save_all_items(self):
        self.client.post("/", data={"item_text": "onions"})
        self.client.post("/", data={"item_text": "carrots"})
        response = self.client.get("/")
        self.assertContains(response, "onions")
        self.assertContains(response, "carrots")

    def test_no_items_by_default(self):
        response = self.client.get("/")
        empty_table = '<table id="id_list_table"></table>',
        self.assertContains(response, empty_table, html=True)

notes

* you can start with just the first test
* you can cheat to get this to pass by hardcoding 'onions' in the template obvs
* then maybe we add the last test, no items by default
* separate calls to get and post eliminates the weird return-things-from-a-post dance, may or may not be a good thing
  - totally possible to imagine keeping that dance mind you.
* then can move on to multiple items
* if you want to cheat, you can just use a global variable, but that will never pass the 'no items by default' test
* it does end up being a less obvious segue into why use a database tho.
  because global vars are weirdly less persistent than a db,
  because the test runner resets the database between each test?
  that's a lot to explain.

overally, definitely intrigued but haven't quite figured out
the perfect way to rewrite this chapter.
////
*******************************************************************************

[role="pagebreak-before"]
Writing things down on a scratchpad like this reassures us that we won't forget them,
so we are comfortable getting back to what we were working on.
We rerun the tests and see an expected failure:

----
    self.assertEqual(Item.objects.count(), 1)
AssertionError: 0 != 1
----


Let's adjust our view:

[role="sourcecode"]
.lists/views.py (ch05l028)
====
[source,python]
----
from django.shortcuts import render
from lists.models import Item


def home_page(request):
    item = Item()
    item.text = request.POST.get("item_text", "")
    item.save()

    return render(
        request,
        "home.html",
        {"new_item_text": request.POST.get("item_text", "")},
    )
----
====

I've coded a very naive solution and you can probably spot a very obvious problem,
which is that we're going to be saving empty items with every request to the home page.
Let's add that to our list of things to fix later.
You know, along with the painfully obvious fact
that we currently have no way at all of having different lists for different people.
That we'll keep ignoring for now.

Remember, I'm not saying you should always ignore glaring problems like this in "real life".
Whenever we spot problems in advance, there's a judgement call to make
over whether to stop what you're doing and start again, or leave them until later.
Sometimes finishing off what you're doing is still worth it,
and sometimes the problem may be so major as to warrant a stop and rethink.

Let's see how the unit tests get on...
----
Ran 4 tests in 0.010s

OK
----

[role="pagebreak-before"]
They pass!  Good. Let's have a little look at our scratchpad.
I've added a couple of the other things that are on our mind:

[role="scratchpad"]
*****
* 'Don't save blank items for every request.'
* 'Code smell: POST test is too long?'
* 'Display multiple items in the table.'
* 'Support more than one list!'
*****


Let's start with the first scratchpad item:
"Don't save blank items for every request".
We could tack on an assertion to an existing test,
but it's best to keep unit tests to testing one thing at a time,
so let's add a new one:

[role="sourcecode"]
.lists/tests.py (ch05l029)
====
[source,python]
----
class HomePageTest(TestCase):
    def test_uses_home_template(self):
        [...]

    def test_can_save_a_POST_request(self):
        [...]

    def test_only_saves_items_when_necessary(self):
        self.client.get("/")
        self.assertEqual(Item.objects.count(), 0)
----
====

// TODO: consider Item.objects.all() == [] instead
// and explain why it gives you a nicer error message


That gives us a `1 != 0` failure.  Let's fix it by bringing the
`if request.method` check back and putting the `Item` creation in there:

[role="sourcecode"]
.lists/views.py (ch05l030)
====
[source,python]
----
def home_page(request):
    if request.method == "POST":  # <1>
        item = Item()
        item.text = request.POST["item_text"]  # <2>
        item.save()

    return render(
        request,
        "home.html",
        {"new_item_text": request.POST.get("item_text", "")},
    )
----
====

<1> We bring back the `request.method` check.
<2> And we can switch from using `request.POST.get()` to `request.POST[]`
    with square brackets,
    because we know for sure that the `item_text` key should be in there,
    and it's better to fail hard if it isn't.


((("", startref="DTpostsave05")))
((("", startref="HTMLpostsave05")))
((("", startref="POSTsave05")))
And that gets the test passing:

----
Ran 5 tests in 0.010s

OK
----


=== Redirect After a POST

((("database testing", "HTML POST requests", "redirect following", id="DThtmlredirect05")))
((("HTML", "POST requests", "redirect following", id="HTMLpostredirect05")))
((("POST requests", "redirect following", id="POSTredirect05")))
But, yuck—those duplicated `request.POST` accesses are making me pretty unhappy.
Thankfully we are about to have the opportunity to fix it.
A view function has two jobs: processing user input and returning an appropriate response.
We've taken care of the first part, which is saving the user's input to the database,
so now let's work on the second part.

https://oreil.ly/yGSl0[Always redirect after a POST],
they say, so let's do that.
Once again we change our unit test for saving a POST request:
instead of expecting a response with the item in it,
we want it to expect a redirect back to the home page.

[role="sourcecode"]
.lists/tests.py (ch05l031)
====
[source,python]
----
    def test_can_save_a_POST_request(self):
        response = self.client.post("/", data={"item_text": "A new list item"})

        self.assertEqual(Item.objects.count(), 1)
        new_item = Item.objects.first()
        self.assertEqual(new_item.text, "A new list item")

        self.assertRedirects(response, "/")  # <1>

    def test_only_saves_items_when_necessary(self):
        [...]
----
====

<1> We no longer expect a response with HTML content rendered by a template,
    so we lose the `assertContains` calls that looked at that.
    Instead, we use Django's `assertRedirects` helper,
    which checks that we return an HTTP 302 redirect, back to the home URL.

That gives us this expected failure:

----
AssertionError: 200 != 302 : Response didn't redirect as expected: Response
code was 200 (expected 302)
----

We can now tidy up our view substantially:


[role="sourcecode"]
.lists/views.py (ch05l032)
====
[source,python]
----
from django.shortcuts import redirect, render
from lists.models import Item


def home_page(request):
    if request.method == "POST":
        item = Item()
        item.text = request.POST["item_text"]
        item.save()
        return redirect("/")

    return render(
        request,
        "home.html",
        {"new_item_text": request.POST.get("item_text", "")},
    )
----
====


And the tests should now pass:

----
Ran 5 tests in 0.010s

OK
----


We're at green; time for a little refactor!

Let's have a look at _views.py_
and see what opportunities for improvement there might be:

[role="sourcecode currentcontents"]
.lists/views.py
====
[source,python]
----
def home_page(request):
    if request.method == "POST":
        item = Item()  # <1>
        item.text = request.POST["item_text"]  # <1>
        item.save()  # <1>
        return redirect("/")

    return render(
        request,
        "home.html",
        {"new_item_text": request.POST.get("item_text", "")},  # <2>
    )
----
====

<1> There's a quicker way to do these three lines with `.objects.create()`.

<2> This line doesn't seem quite right now; in fact, it won't work at all.
    Let's make a note on our scratchpad to sort out passing list items to the template.
    It's actually closely related to "Display multiple items",
    so we'll put it just before that one:


[role="scratchpad"]
*****
* '[strikethrough line-through]#Don't save blank items for every request.#'
* 'Code smell: POST test is too long?'
* 'Pass existing list items to the template somehow.'
* 'Display multiple items in the table.'
* 'Support more than one list!'
*****

[role="pagebreak-before"]
And here's the refactored version of _views.py_ using the `.objects.create()`
helper method that Django provides, for one-line creation of objects:

[role="sourcecode"]
.lists/views.py (ch05l033)
====
[source,python]
----
def home_page(request):
    if request.method == "POST":
        Item.objects.create(text=request.POST["item_text"])
        return redirect("/")

    return render(
        request,
        "home.html",
        {"new_item_text": request.POST.get("item_text", "")},
    )

----
====


=== Better Unit Testing Practice: Each Test Should Test One Thing

((("unit tests", "testing only one thing")))
((("testing best practices")))((("POST requests", "POST test is too long code smell, addressing")))
Let's address the "POST test is too long" code smell.

Good unit testing practice says that each test should only test one thing. The
reason is that it makes it easier to track down bugs.  Having multiple
assertions in a test means that, if the test fails on an early assertion, you
don't know what the statuses of the later assertions are. As we'll see in the next
chapter, if we ever break this view accidentally, we want to know whether it's
the saving of objects that's broken, or the type of response.

You may not always write perfect unit tests with single assertions on your
first go, but now feels like a good time to separate out our concerns:

[role="sourcecode"]
.lists/tests.py (ch05l034)
====
[source,python]
----
    def test_can_save_a_POST_request(self):
        self.client.post("/", data={"item_text": "A new list item"})
        self.assertEqual(Item.objects.count(), 1)
        new_item = Item.objects.first()
        self.assertEqual(new_item.text, "A new list item")

    def test_redirects_after_POST(self):
        response = self.client.post("/", data={"item_text": "A new list item"})
        self.assertRedirects(response, "/")
----
====

((("", startref="HTMLpostredirect05")))
((("", startref="DThtmlredirect05")))
((("", startref="POSTredirect05")))
And we should now see six tests pass instead of five:

----
Ran 6 tests in 0.010s

OK
----

[role="pagebreak-before less_space"]
=== Rendering Items in the Template

((("database testing", "rendering items in the template", id="DTrender05")))
Much better!  Back to our to-do list:

[role="scratchpad"]
*****
* '[strikethrough line-through]#Don't save blank items for every request.#'
* '[strikethrough line-through]#Code smell: POST test is too long?#'
* 'Pass existing list items to the template somehow.'
* 'Display multiple items in the table.'
* 'Support more than one list!'
*****


Crossing things off the list is almost as satisfying as seeing tests pass!

The third and fourth items are the last of the "easy" ones.
Our view now does the right thing for POST requests;
it saves new list items to the database.
Now we want GET requests to load all currently existing list items,
and pass them to the template for rendering.
Let's have a new unit test for that:

[role="sourcecode"]
.lists/tests.py (ch05l035)
====
[source,python]
----
class HomePageTest(TestCase):
    def test_uses_home_template(self):
        [...]
    def test_renders_input_form(self):
        [...]

    def test_displays_all_list_items(self):
        Item.objects.create(text="itemey 1")
        Item.objects.create(text="itemey 2")

        response = self.client.get("/")

        self.assertContains(response, "itemey 1")
        self.assertContains(response, "itemey 2")

    def test_can_save_a_POST_request(self):
        [...]
----
====

[role="pagebreak-before less_space"]
.Arrange-Act-Assert or Given-When-Then
*******************************************************************************

Did you notice the use of whitespace in this test?
I'm visually separating out the code into three blocks:
((("Arrange, Act, Assert")))
((("Given / When / Then")))

[role="sourcecode currentcontentss"]
.lists/tests.py
====
[source,python]
----
    def test_displays_all_list_items(self):
        Item.objects.create(text="itemey 1")  # <1>
        Item.objects.create(text="itemey 2")  # <1>

        response = self.client.get("/")  # <2>

        self.assertContains(response, "itemey 1")  # <3>
        self.assertContains(response, "itemey 2")  # <3>
----
====

<1> Arrange: where we set up the data we need for the test.
<2> Act: where we call the code under test
<3> Assert: where we check on the results

This isn't obligatory, but it's a common convention,
and it does help see the structure of the test.

Another popular way to talk about this structure is _given-when-then_:

* _Given_ the database contains our list with two items,
* _When_ I make a GET request for our list,
* _Then_ I see the both items in our list.

This latter phrasing comes from the world of behaviour-driven development (BDD),
and I actually prefer it somewhat.((("BDD (behaviour-driven development)")))
You can see that it encourages phrasing things in a more natural way,
and we're gently nudged to think of things in terms of behaviour
and the perspective of the user.


*******************************************************************************

That fails as expected:

----
AssertionError: False is not true : Couldn't find 'itemey 1' in the following
response
b'<html>\n  <head>\n    <title>To-Do lists</title>\n  </head>\n  <body>\n
[...]
----

[role="pagebreak-before"]
((("templates", "tags", "{% for ... endfor %}")))
((("{% for ... endfor %}")))
The Django template syntax has a tag for iterating through lists,
`{% for .. in .. %}`; we can use it like this:


[role="sourcecode"]
.lists/templates/home.html (ch05l036)
====
[source,html]
----
<table id="id_list_table">
  {% for item in items %}
    <tr><td>1: {{ item.text }}</td></tr>
  {% endfor %}
</table>
----
====

This is one of the major strengths of the templating system. Now the template
will render with multiple `<tr>` rows, one for each item in the variable
`items`.  Pretty neat!  I'll introduce a few more bits of Django template
magic as we go, but at some point you'll want to go and read up on the rest of
them in the
https://docs.djangoproject.com/en/5.2/topics/templates[Django docs].

Just changing the template doesn't get our tests to green; we need to actually
pass the items to it from our home page view:

[role="sourcecode"]
.lists/views.py (ch05l037)
====
[source,python]
----
def home_page(request):
    if request.method == "POST":
        Item.objects.create(text=request.POST["item_text"])
        return redirect("/")

    items = Item.objects.all()
    return render(request, "home.html", {"items": items})
----
====

That does get the unit tests to pass. Moment of truth...will the functional
test pass?

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python functional_tests.py*]
[...]
AssertionError: 'To-Do' not found in 'OperationalError at /'
----

((("", startref="DTrender05")))
((("debugging", "using manual visits to the site")))
Oops, apparently not.  Let's use another FT debugging technique,
and it's one of the most straightforward: manually visiting the site!
Open up pass:[<em>http://localhost:8000</em>] in your web browser,
and you'll see a Django debug page saying "no such table: lists_item",
as in <<operationalerror>>.

[[operationalerror]]
[role="width-75"]
.Another helpful debug message
image::images/tdd3_0503.png["Screenshot of Django debug page, saying OperationalError at / no such table: lists_item"]


[role="pagebreak-before less_space"]
=== Creating Our Production Database with migrate

((("database testing", "production database creation", id="DTproduction05")))
((("database migrations")))
So, we've got another helpful error message from Django,
which is basically complaining that we haven't set up the database properly.
How come everything worked fine in the unit tests, I hear you ask?
Because Django creates a special 'test database' for unit tests;
it's one of the magical things that Django's `TestCase` does.

To set up our "real" database, we need to explicitly create it.
SQLite databases are just a file on disk,
and you'll see in 'settings.py' that Django, by default, will just put it in a file
called 'db.sqlite3' in the base project directory:

[role="sourcecode currentcontents"]
.superlists/settings.py
====
[source,python]
----
[...]
# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}
----
====

We've told Django everything it needs to create the database,
first via 'models.py' and then when we created the migrations file.
To actually apply it to creating a real database,
we use another Django Swiss Army knife 'manage.py' command, `migrate`:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py migrate*]
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, lists, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying lists.0001_initial... OK
  Applying lists.0002_item_text... OK
  Applying sessions.0001_initial... OK
----

It seems to be doing quite a lot of work!
That's because it's the first ever migration,
and Django is creating tables for all its built-in "batteries included"
apps, like the admin site and the built-in auth modules.
We don't need to pay attention to them for now.
But you can see our `lists.0001_initial` and `lists.0002_item_text` in there!

At this point, you can refresh the page on _localhost_ and see that the error is gone.
Let's try running the functional tests again:footnote:[
If you get a different error at this point,
try restarting your dev server--it may have gotten confused
by the changes to the database happening under its feet.]

// DAVID: FWIW I'm not sure how this might happen - interested to know
// if you have a real example of someone running into this problem.

----
AssertionError: '2: Use peacock feathers to make a fly' not found in ['1: Buy
peacock feathers', '1: Use peacock feathers to make a fly']
----


So close!((("templates", "tags", "{{ forloop.counter }}")))  We just need to get our list numbering right.
Another awesome Django template tag, `forloop.counter`, will help here:

[role="sourcecode"]
.lists/templates/home.html (ch05l038)
====
[source,html]
----
  {% for item in items %}
    <tr><td>{{ forloop.counter }}: {{ item.text }}</td></tr>
  {% endfor %}
----
====


If you try it again, you should now see the FT gets to the end:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python functional_tests.py*]
.
 ---------------------------------------------------------------------
Ran 1 test in 5.036s

OK
----

Hooray!

But, as it's running, you may notice something is amiss, like in
<<items_left_over_from_previous_run>>.


[[items_left_over_from_previous_run]]
.There are list items left over from the last run of the test
image::images/tdd3_0504.png["There are list items left over from the last run of the test"]


Oh dear. It looks like previous runs of the test are leaving stuff lying around
in our database.  In fact, if you run the tests again, you'll see it gets
worse:

[role="skipme"]
----
1: Buy peacock feathers
2: Use peacock feathers to make a fly
3: Buy peacock feathers
4: Use peacock feathers to make a fly
5: Buy peacock feathers
6: Use peacock feathers to make a fly
----

Grrr.  We're so close! We're going to need some kind of automated way of
tidying up after ourselves. For now, if you feel like it, you can do it
manually by deleting the database and re-creating it fresh with `migrate`
(you'll need to shut down your Django server first):

[subs="specialcharacters,quotes"]
----
$ *rm db.sqlite3*
$ *python manage.py migrate --noinput*
----

And then (after restarting your server!) reassure yourself that the FT still
passes.

Apart from that little bug in our functional testing, we've got some code
that's more or less working.  Let's do a commit.
((("", startref="DTproduction05")))


Start by doing a `git status` and a `git diff`, and you should see changes
to 'home.html', 'tests.py', and 'views.py'. Let's add them:

[subs="specialcharacters,quotes"]
----
$ *git add lists*
$ *git commit -m "Redirect after POST, and show all items in template"*
----

TIP: You might find it useful to add markers for the end of each chapter, like
    *`git tag end-of-chapter-05`*.


=== Recap

Where are we?  How is progress on our app, and what have we learned?

* We've got a form set up to add new items to the list using POST.

* We've set up a simple model in the database to save list items.

* We've learned about creating database migrations, both for the
  test database (where they're applied automatically) and for the real
  database (where we have to apply them manually).

* We've used our first couple of Django template tags:  `{% csrf_token %}`
  and the `{% for ... endfor %}` loop.

* And we've used two different FT debugging techniques:
  ++time.sleep++s, and improving the error messages.


But we've got a couple of items on our own to-do list,
namely getting the FT to clean up after itself,
and perhaps more critically,
adding support for more than one list.

[role="scratchpad"]
*****
* '[strikethrough line-through]#Don't save blank items for every request.#'
* '[strikethrough line-through]#Code smell: POST test is too long?#'
* '[strikethrough line-through]#Pass existing list items to the template somehow.#'
* '[strikethrough line-through]#Display multiple items in the table.#'
* 'Clean up after FT runs.'
* 'Support more than one list!'
*****


I mean, we _could_ ship the site as it is, but people might find it strange
that the entire human population has to share a single to-do list.
I suppose it might get people to stop and think about
how connected we all are to one another,
how we all share a common destiny here on Spaceship Earth,
and how we must all work together to solve the global problems that we face.

But in practical terms, the site wouldn't be very useful.

Ah well.
// (("", startref="UIdatabase05"))


.Useful TDD Concepts
*******************************************************************************

Regression::
    When a change unexpectedly breaks some aspect of the application that used to work.
    ((("Test-Driven Development (TDD)", "concepts", "regression")))
    ((("regression")))

Unexpected failure::
    When a test fails in a way we weren't expecting.
    This either means that we've made a mistake in our tests,
    or that the tests have helped us find a regression,
    and we need to fix something in our code.
    ((("Test-Driven Development (TDD)", "concepts", "unexpected failures")))
    ((("unexpected failures")))

Triangulation::
    Adding a test case with a new specific example for some existing code,
    to justify generalising the implementation
    (which may be a "cheat" until that point).
    ((("Test-Driven Development (TDD)", "concepts", "triangulation")))
    ((("triangulation")))

Three strikes and refactor::
    A rule of thumb for when to remove duplication from code.
    When two pieces of code look very similar,
    it often pays to wait until you see a third use case,
    so that you're more sure about what part of the code really is the common,
    reusable part to refactor out.
    ((("Test-Driven Development (TDD)", "concepts", "three strikes and refactor")))
    ((("three strikes and refactor rule")))

The scratchpad to-do list::
    A place to write down things that occur to us as we're coding,
    so that we can finish up what we're doing and come back to them later.
    Love a good old-fashioned piece of paper now and again!
    ((("Test-Driven Development (TDD)", "concepts", "scratchpad to-do list")))
    ((("scratchpad to-do list")))

// SEBASTIAN: (idea) alternative to maintaining a scratchpad could be to write empty unit tests without implementation.
//    Such "tests prototypes" could be skipped initially until we work on them.

*******************************************************************************
