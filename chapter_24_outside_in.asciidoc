[[chapter_24_outside_in]]
== Finishing "My Lists": Outside-In TDD

.A Note for Early Release Readers
****
With Early Release ebooks, you get books in their earliest form—the author's raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.

This will be the 24th chapter of the final book. The GitHub repo is available at https://github.com/hjwp/book-example.

If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at obeythetestinggoat@gmail.com.
****

.Warning, Chapter Recently Updated
*******************************************************************************
Warning, this Chapter is freshly updated for Django 5 + Python 3.13.

The code listings should have valid syntax,
and I've been through and sense-checked the chapter text,
but a few things might still be off!
So let me know what you think of the chapter, via obeythetestinggoat@gmail.com

*******************************************************************************


((("Test-Driven Development (TDD)", "outside-in technique", id="TTDoutside22")))
In this chapter I'd like to talk about a technique called Outside-In TDD.
It's pretty much what we've been doing all along.
Our "double-loop" TDD process,
in which we write the functional test first and then the unit tests,
is already a manifestation of outside-in--we
design the system from the outside, and build up our code in layers.
Now I'll make it explicit, and talk about some of the common issues involved.


=== The Alternative: "Inside-Out"

The alternative to "outside-in" is to work "inside-out",
which is the way most people intuitively work before they encounter TDD.
After coming up with a design, the natural inclination is sometimes
to implement it starting with the innermost, lowest-level components first.

For example, when faced with our current problem,
providing users with a "My Lists" page of saved lists,
the temptation is to start at the models layer:
we probably want to add an "owner" attribute to the `List` model object,
reasoning that an attribute like this is "obviously" going to be required.
Once that's in place, we would modify the more peripheral layers of code,
such as views and templates, taking advantage of the new attribute,
and then finally add URL routing to point to the new view.

It feels comfortable because it means you're never working on a bit of code
that is dependent on something that hasn't yet been implemented.
Each bit of work on the inside is a solid foundation
on which to build the next layer out.

But working inside-out like this also has some weaknesses.


=== Why Prefer "Outside-In"?

((("Outside-In TDD", "vs. inside-out", secondary-sortas="inside-out")))
((("inside-out TDD")))
The most obvious problem with inside-out is that
it requires us to stray from a TDD workflow.
Our functional test's first failure might be due to missing URL routing,
but we decide to ignore that
and go off adding attributes to our database model objects instead.

We might have ideas in our head
about the new desired behaviour of our inner layers like database models,
and often these ideas will be pretty good,
but they are actually just speculation about what's really required,
because we haven't yet built the outer layers that will use them.

One problem that can result is to build inner components that are more general
or more capable than we actually need, which is a waste of time,
and an added source of complexity for your project.
Another common problem is that you create inner components
with an API which is convenient for their own internal design,
but which later turns out to be inappropriate
for the calls your outer layers would like to make...worse still,
you might end up with inner components which, you later realise,
don't actually solve the problem that your outer layers need solved.

In contrast, working outside-in allows you to use each layer
to imagine the most convenient API you could want from the layer beneath it.
Let's see it in action.


=== The FT for "My Lists"

((("functional tests (FTs)", "outside-in technique")))
As we work through the following functional test,
we start with the most outward-facing (presentation layer),
through to the view functions (or "controllers"),
and lastly the innermost layers, which in this case will be model code.
See <<outside-in-layers>>.


[[outside-in-layers]]
.The Layer in Our Application
image::images/tdd3_2401.png["A diagram of the layers of the application, with the user at the top, then a presentation layer (aka views in mvc) containing some templates, below that the views layer (aka controllers in mvc) containg views and forms, then the models layer with django models, and finally an icon for the database at the bottom.  there is also an arrow from top to bottom, with the top labelled OUTSIDE! and the bottom labelled IN!"]


While we're drawing diagrams, would it help to sketch out
what we're imagining?  See <<my-lists-page-sketch>>.

[[my-lists-page-sketch]]
.A sketch of the "My Lists" page
image::images/tdd3_2402.png["A sketch of the My Lists page, showing the users email in the page header, and several lists with a callout saying that we will use the first item text as the hyperlink text for each list."]


Let's incarnate this idea in FT form.
We know our `create_pre_authenticated_session` code works now,
so we can just fill out the actual body of the test,
to describe using this prospective "My Lists" page.


[role="sourcecode"]
.src/functional_tests/test_my_lists.py (ch24l001)
====
[source,python]
----
from selenium.webdriver.common.by import By
[...]

    def test_logged_in_users_lists_are_saved_as_my_lists(self):
        # Edith is a logged-in user
        self.create_pre_authenticated_session("edith@example.com")

        # She goes to the homepage and starts a list
        self.browser.get(self.live_server_url)
        self.add_list_item("Reticulate splines")  # <1>
        self.add_list_item("Immanentize eschaton")
        first_list_url = self.browser.current_url

        # She notices a "My lists" link, for the first time.
        self.browser.find_element(By.LINK_TEXT, "My lists").click()

        # She sees her email is there in the page heading
        self.wait_for(
            lambda: self.assertIn(
                "edith@example.com",
                self.browser.find_element(By.CSS_SELECTOR, "h1").text,
            )
        )

        # And she sees that her list is in there,
        # named according to its first list item
        self.wait_for(
            lambda: self.browser.find_element(By.LINK_TEXT, "Reticulate splines")
        )
        self.browser.find_element(By.LINK_TEXT, "Reticulate splines").click()
        self.wait_for(
            lambda: self.assertEqual(self.browser.current_url, first_list_url)
        )
----
====

<1> We'll define this `add_list_item()` shortly.

As you can see, we create a list with a couple of items,
then we check that this list appears on a new "My Lists" page,
and that it's "named" after the first item in the list.

Let's validate that it really works by creating a second list,
and seeing that appear on the My Lists page as well.
The FT continues, and while we're at it,
we check that only logged-in users can see the "My Lists" page:

[role="sourcecode"]
.src/functional_tests/test_my_lists.py (ch24l002)
====
[source,python]
----
        [...]
        self.wait_for(
            lambda: self.assertEqual(self.browser.current_url, first_list_url)
        )

        # She decides to start another list, just to see
        self.browser.get(self.live_server_url)
        self.add_list_item("Click cows")
        second_list_url = self.browser.current_url

        # Under "my lists", her new list appears
        self.browser.find_element(By.LINK_TEXT, "My lists").click()
        self.wait_for(lambda: self.browser.find_element(By.LINK_TEXT, "Click cows"))
        self.browser.find_element(By.LINK_TEXT, "Click cows").click()
        self.wait_for(
            lambda: self.assertEqual(self.browser.current_url, second_list_url)
        )

        # She logs out.  The "My lists" option disappears
        self.browser.find_element(By.CSS_SELECTOR, "#id_logout").click()
        self.wait_for(
            lambda: self.assertEqual(
                self.browser.find_elements(By.LINK_TEXT, "My lists"),
                [],
            )
        )
----
====

Our FT uses a new helper method, `add_list_item()`,
which abstracts away entering text into the right input box.
We define it in _base.py_:


[role="sourcecode small-code"]
.src/functional_tests/base.py (ch24l003)
====
[source,python]
----
from selenium.webdriver.common.keys import Keys
[...]

    def add_list_item(self, item_text):
        num_rows = len(self.browser.find_elements(By.CSS_SELECTOR, "#id_list_table tr"))
        self.get_item_input_box().send_keys(item_text)
        self.get_item_input_box().send_keys(Keys.ENTER)
        item_number = num_rows + 1
        self.wait_for_row_in_list_table(f"{item_number}: {item_text}")
----
====


And while we're at it we can use it in a few of the other FTs,
like this for example:


[role="sourcecode dofirst-ch24l004-1"]
.src/functional_tests/test_layout_and_styling.py (ch24l004-2)
====
[source,diff]
----
         # She starts a new list and sees the input is nicely
         # centered there too
-        inputbox.send_keys("testing")
-        inputbox.send_keys(Keys.ENTER)
-        self.wait_for_row_in_list_table("1: testing")
+        self.add_list_item("testing")
+
----
====

I think it makes the FTs a lot more readable.
I made a total of six changes--see if you agree with me.

A quick run of all FTs, a commit, and then back to the FT we're working on.
The first error should look like this:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test functional_tests.test_my_lists*]
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: My lists; [...]
----


=== The Outside Layer: Presentation and Templates


((("Outside-In TDD", "outside layer")))
The test is currently failing because it can't find a link saying "My Lists".
We can address that at the presentation layer, in _base.html_, in our navigation bar.
Here's the minimal code change:


[role="sourcecode small-code"]
.src/lists/templates/base.html (ch24l005)
====
[source,html]
----
      <nav class="navbar">
        <div class="container-fluid">
          <a class="navbar-brand" href="/">Superlists</a>
          {% if user.email %}
            <a class="navbar-link" href="#">My lists</a>
            <span class="navbar-text">Logged in as {{ user.email }}</span>
            <form method="POST" action="{% url 'logout' %}">
              [...]
----
====

Of course the `href="#"` means that link doesn't actually go anywhere,
but it _does_ get our FT along to the next failure:


[subs=""]
----
$ <strong>python src/manage.py test functional_tests.test_my_lists</strong>
[...]
    lambda: self.assertIn(
            ~~~~~~~~~~~~~^
        "edith@example.com",
        ^^^^^^^^^^^^^^^^^^^^
        self.browser.find_element(By.CSS_SELECTOR, "h1").text,
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    )
    ^
AssertionError: 'edith@example.com' not found in 'Your To-Do list'
----

Which is telling us we're going to have to build a page
that at least has the user's email in its header.
Let's start with the basics--a URL and a placeholder template for it.

Again, we can go outside-in,
starting at the presentation layer with just the URL and nothing else:

[role="sourcecode"]
.src/lists/templates/base.html (ch24l006)
====
[source,html]
----
  {% if user.email %}
    <a class="navbar-link" href="{% url 'my_lists' user.email %}">My lists</a>
----
====

// TODO: mention urlencoding emails

=== Moving Down One Layer to View Functions (the Controller)

((("Outside-In TDD", "controller layer")))
That will cause a template error in the FT:

[subs=""]
----
$ <strong>./src/manage.py test functional_tests.test_my_lists</strong>
[...]
Internal Server Error: /
[...]
  File "...goat-book/src/lists/views.py", line 8, in home_page
    return render(request, "home.html", {"form": ItemForm()})
[...]
django.urls.exceptions.NoReverseMatch: Reverse for 'my_lists' not found.
'my_lists' is not a valid view function or pattern name.
[...]
ERROR: test_logged_in_users_lists_are_saved_as_my_lists [...]
[...]
selenium.common.exceptions.NoSuchElementException: [...]
----

To fix it, we'll need to start to move from working at the presentation layer,
gradually into the controller layer, Django's urls and views.

As always, we start with a test.
In this layer, a unit test is the way to go:

[role="sourcecode"]
.src/lists/tests/test_views.py (ch24l007)
====
[source,python]
----
class MyListsTest(TestCase):
    def test_my_lists_url_renders_my_lists_template(self):
        response = self.client.get("/lists/users/a@b.com/")
        self.assertTemplateUsed(response, "my_lists.html")
----
====

That gives:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test lists*]
[...]
AssertionError: No templates used to render the response
----


That's because the URL doesn't exist yet, and a 404 has no template.
Let's start our fix in _urls.py_:


[role="sourcecode"]
.src/lists/urls.py (ch24l008)
====
[source,python]
----
urlpatterns = [
    path("new", views.new_list, name="new_list"),
    path("<int:list_id>/", views.view_list, name="view_list"),
    path("users/<str:email>/", views.my_lists, name="my_lists"),
]
----
====


That gives us a new test failure,
which informs us of what we should do.
As you can see, it's pointing us at a _views.py_,
we're clearly in the controller layer:

----
    path("users/<str:email>/", views.my_lists, name="my_lists"),
                               ^^^^^^^^^^^^^^
AttributeError: module 'lists.views' has no attribute 'my_lists'
----


Let's create a minimal placeholder then:

[role="sourcecode"]
.src/lists/views.py (ch24l009)
====
[source,python]
----
def my_lists(request, email):
    return render(request, "my_lists.html")
----
====

And a minimal template, with no real content
except for the header that shows the user's email address:

[role="sourcecode"]
.src/lists/templates/my_lists.html (ch24l010)
====
[source,html]
----
{% extends 'base.html' %}

{% block header_text %}{{ user.email }}'s Lists{% endblock %}
----
====

That gets our unit tests passing.

[subs="specialcharacters,quotes"]
----
$ *./src/manage.py test lists*
[...]
OK
----

And hopefully it will address the current error in our FT:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test functional_tests.test_my_lists*]
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: Reticulate splines; [...]
----

Step by step! Sure enough, the FT get a little further.
It _can_ now find the email in the `<h1>`,
but it's now saying that the "My Lists" page doesn't yet show any lists.
It wants them to appear as clickable links, named after the first item.

=== Another Pass, Outside-In


((("Outside-In TDD", "FT-driven development", id="OITDDft22")))
At each stage, we're still letting the FT drive what development we do.

Starting again at the outside layer, in the template,
we begin to write the template code we'd like to use
to get the "My Lists" page to work the way we want it to.
As we do so, we start to specify the API we want
from the code at the layers below.

// Programming by wishful thinking, as always!


==== A Quick Restructure of Our Template Composition

((("templates", "composition")))
Let's take a look at our base template, _base.html_.
It currently has a lot of content that's specific to editing todo lists,
which our "My Lists" page doesn't need:


[role="sourcecode currentcontents"]
.src/lists/templates/base.html
====
[source,html]
----
    <div class="container">

      <nav class="navbar">
        [...]
      </nav>

      {% if messages %}
        [...]
      {% endif %}

      <div class="row justify-content-center p-5 bg-body-tertiary rounded-3">
        <div class="col-lg-6 text-center">
          <h1 class="display-1 mb-4">{% block header_text %}{% endblock %}</h1>

          <form method="POST" action="{% block form_action %}{% endblock %}" >  <1>
            [...]
          </form>
        </div>
      </div>

      <div class="row justify-content-center">
        <div class="col-lg-6">
          {% block table %}  <2>
          {% endblock %}
        </div>
      </div>

    </div>

    <script src="/static/lists.js"></script>  <3>
      [...]
----
====

<1> The `<form>` tag is definitely something we only want on pages where we edit lists.
    Everything else up to this point is generic enough to be on any page.

<2> Similarly the `{% block table %}` isn't something we'd need on the "My Lists" page.

<3> Finally the `<script>` tag is specific to lists too.

So we'll want to change things so that _base.html_ is a bit more generic.

Let's recap: we've got three actual pages we want to render:

1. The home page (where you can enter a first todo item to create a new list)
2. The "list" page (where you can view an existing list and add to it)
3. The "my lists" page (which is a list of all your existing lists)

* The home page and list page both share the "form" elements and the lists.js javascript.
* But the lists page is the only one that needs to show the full table of list items
* The "my lists" page doesn't need anything related to editing or displaying lists.

So we have some things shared between all 3, and some only shared between 1 and 2.

So far we've been using inheritance to share the common parts of our templates,
but this is a good place to start using composition instead.
At the moment we're saying that "home" is a type of "base" template,
but with the "table" section switched off, which is a bit awkward.
Let's not make it even more awkward by saying that "lists"
is a "base" template with both the form and the table switched off!
It might make more sense to say that "home" is a type of base template which "includes" a list form,
but no table, and "list" includes both the list form and the list table.

((("composition over inheritance principle")))
TIP: People often say "prefer composition over inheritance",
    because inheritance can become hard to reason about as the inheritance hierarchy grows.
    Composition is more flexible,
    and often makes more sense.
    For a lengthy discussion of this topic, see
    https://hynek.me/articles/python-subclassing-redux/[Hynek Schlawack's definitive article on subclassing in Python].

So, let's:

1. Pull out the `<form>` tag and the _lists.js_ `<script>` tag into into some blocks
   we can "include" in our home page and lists page.

2. Move the `<table>` block so it only exists in the lists page.

3. Take all the lists-specific stuff out of the _base.html_ template,
   making it into a more generic page with a header and a placeholder for generic content:

We'll use what's called an 
https://docs.djangoproject.com/en/5.2/ref/templates/builtins/#include[include]
to be able to compose reusable template fragments,
when we don't want to use inheritance.


==== An Early Return so we're Refactoring Against Green


Before we start refactoring, let's put an early return in our FT,
so we're refactoring against green tests:


[role="sourcecode"]
.src/functional_tests/test_my_lists.py (ch24l010-0)
====
[source,python]
----
        # She sees her email is there in the page heading
        self.wait_for(
            lambda: self.assertIn(
                "edith@example.com",
                self.browser.find_element(By.CSS_SELECTOR, "h1").text,
            )
        )
        return # TODO: resume here after templates refactor

        # And she sees that her list is in there,
        # named according to its first list item
        [...]
----
====

Verify the FTs are all green:

----
Ran 8 tests in 19.712s

OK
----

==== Factoring Out Two Template Includes

First let's pull out the form and the script tag from _base.html_:

[role="sourcecode small-code"]
.src/lists/templates/base.html (ch24l010-1)
====
[source,diff]
----
@@ -58,43 +58,19 @@
         <div class="col-lg-6 text-center">
           <h1 class="display-1 mb-4">{% block header_text %}{% endblock %}</h1>
 
-          <form method="POST" action="{% block form_action %}{% endblock %}" >
-            {% csrf_token %}
-            <input
-              id="id_text"
-              name="text"
-              class="form-control
-                     form-control-lg
-                     {% if form.errors %}is-invalid{% endif %}"
-              placeholder="Enter a to-do item"
-              value="{{ form.text.value }}"
-              aria-describedby="id_text_feedback"
-              required
-            />
-            {% if form.errors %}
-              <div id="id_text_feedback" class="invalid-feedback">
-                {{ form.errors.text.0 }}
-              </div>
-            {% endif %}
-          </form>
+          {% block extra_header %}
+          {% endblock %}
+
         </div>
       </div>
 
-      <div class="row justify-content-center">
-        <div class="col-lg-6">
-          {% block table %}
-          {% endblock %}
-        </div>
-      </div>
+      {% block content %}
+      {% endblock %}
 
     </div>
 
-    <script src="/static/lists.js"></script>
-    <script>
-      window.onload = () => {
-        initialize("#id_text");
-      };
-    </script>
+    {% block scripts %}
+    {% endblock %}
 
   </body>
 </html>
----
====

You can see we've replaced all the lists-specific stuff with 3 new blocks:

* `extra_header` for anything we want to put in the big header section
* `content` for the main content of the page
* `scripts` for any javascript we want to include.

Let's paste in the `<form>` tag into a file at
_src/lists/templates/includes/form.html_
(having a subfolder in templates for includes is a common practice).

[role="sourcecode small-code"]
.src/lists/templates/includes/form.html (ch24l010-2)
====
[source,html]
----
<form method="POST" action="{{ form_action }}" >  <1>
  {% csrf_token %}
  <input
    id="id_text"
    name="text"
    class="form-control
           form-control-lg
           {% if form.errors %}is-invalid{% endif %}"
    placeholder="Enter a to-do item"
    value="{{ form.text.value | default:'' }}"
    aria-describedby="id_text_feedback"
    required
  />
  {% if form.errors %}
    <div id="id_text_feedback" class="invalid-feedback">
      {{ form.errors.text.0 }}
    </div>
  {% endif %}
</form>
----
====

<1> This is the only change,
    we've replaced the `{% block form_action %}` with `{{ form_action }}`.


Let's paste the scripts tags verbatim
into a new file at _includes/scripts.html_:

[role="sourcecode"]
.src/lists/templates/includes/scripts.html (ch24l010-3)
====
[source,html]
----
<script src="/static/lists.js"></script>

<script>
  window.onload = () => {
    initialize("#id_text");
  };
</script>
----
====

Now let's look at how to use the include,
and how the `form_action` change plays out,
in the changes to _home.html_:


[role="sourcecode small-code"]
.src/lists/templates/home.html (ch24l010-4)
====
[source,html]
----
{% extends 'base.html' %}

{% block header_text %}Start a new To-Do list{% endblock %}

{% block extra_header %}
  {% url 'new_list' as form_action %}  <1>
  {% include "includes/form.html" with form=form form_action=form_action %}  <2>
{% endblock %}

{% block scripts %}  <3>
  {% include "includes/scripts.html" %}
{% endblock %}
----
====

<1> The `{% url ... as %}` syntax lets us define a template variable in-line

<2> Then we use `{% include ... with key=value... %}`
    to pull in the contents of the `form.html` template,
    with the appropriate context variables passed in--a bit like
    calling a function.footnote:[
    Strictly speaking you could have omitted the `with=` in this case,
    as included templates autmatically get the context of their parent.
    But sometimes you want to pass a context variable under a different name,
    so I like the with, for consistency and explicitness.]

<3> The `scripts` block is just a straightforward `include`
    with no variables.


Now let's see it in _list.html_:

[role="sourcecode"]
.src/lists/templates/list.html (ch24l010-5)
====
[source,diff]
----
@@ -2,12 +2,24 @@

 {% block header_text %}Your To-Do list{% endblock %}

-{% block form_action %}{% url 'view_list' list.id %}{% endblock %}

-{% block table %}
+{% block extra_header %}  <1>
+  {% url 'view_list' list.id as form_action %}
+  {% include "includes/form.html" with form=form form_action=form_action %}
+{% endblock %}
+
+{% block content %}  <2>
+<div class="row justify-content-center">
+  <div class="col-lg-6">
     <table class="table" id="id_list_table">
       {% for item in list.item_set.all %}
         <tr><td>{{ forloop.counter }}: {{ item.text }}</td></tr>
       {% endfor %}
     </table>
+  </div>
+</div>
+{% endblock %}
+
+{% block scripts %}  <3>
+  {% include "includes/scripts.html" %}
 {% endblock %}

----
====

<1> The `block table` becomes an `extra_header` block,
    and we use the `include` to pull in the form.

<2> The `block table` becomes a `content` block,
    with all the html we need for our table.

<3> And the scripts block is the same as the one from _home.html_.


Now a little re-run of all our FTs to make sure we haven't broken anything:

----
Ran 8 tests in 19.712s

OK
----


OK let's remove the early return:


[role="sourcecode"]
.src/functional_tests/test_my_lists.py (ch24l010-6)
====
[source,diff]
----
@@ -44,7 +44,6 @@ class MyListsTest(FunctionalTest):
                 self.browser.find_element(By.CSS_SELECTOR, "h1").text,
             )
         )
-        return # TODO: resume here after templates refactor

         # And she sees that her list is in there,
         # named according to its first list item
----
====


// CSANAD something somewhere broke my styling tests, even though right now I work from the book-example
// commit-to-commit (no manual changes, just `git checkout` the next commit).

// DAVID: For some reason I got an extra failure in test_layout_and_styling. Running it again, it passed.
// Is it possible it's flakey? (I appreciate this is a terribly vague bug report so feel free to ignore.)

And we'll commit that as a nice refactor:

[subs="specialcharacters,quotes"]
----
$ *git add src/lists/templates*
$ *git commit -m "refactor templates to use composition/includes"*
----


Now let's get back to our outside-in process,
and working in our template to drive out the requirements
for our views layer:


==== Designing Our API Using the Template

With the early return removed,
our FT is back to telling us that we need to actually show our lists,
named after their first items, on the new my_lists page:

[subs="specialcharacters,quotes"]
----
$ *./src/manage.py test functional_tests.test_my_lists*
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: Reticulate splines; [...]
----

(If you haven't taken a look around the site recently,
it does look pretty blank, see <<empty-my-lists-page>>.)

[[empty-my-lists-page]]
.Not much to see here
image::images/tdd3_2403.png["A screenshot of the My Lists page, showing the user's email in the page header, but no lists."]


((("templates", "designing APIs using")))
So, in _my_lists.html_ we can now work in the `content` block:

[role="sourcecode"]
.src/lists/templates/my_lists.html (ch24l010-7)
====
[source,html]
----
[...]

{% block content %}
  <h2>{{ owner.email }}'s lists</h2>  <1>
  <ul>
    {% for list in owner.lists.all %}  <2>
      <li><a href="{{ list.get_absolute_url }}">{{ list.name }}</a></li>  <3>
    {% endfor %}
  </ul>
{% endblock %}
----
====

// TODO: look into changing the user.email at the top to owner.email as well
// the trouble is that changing it at this point introduces a regression
// in the FT.

We've made several design decisions in this template
which are going to filter their way down through the code:

<1> We want a variable called `owner` to represent the user in our template.
    This is what will allow one user to view another users's lists.

<2> We want to be able to iterate through the lists created by that user
    using `owner.lists.all`
    (I happen to know how to make this work with the Django ORM).

<3> We want to use `list.name` to print out the "name" of the list,
    which is currently specified as the text of its first element.



.Programming By Wishful Thinking Again, Still
*******************************************************************************

The phrase "programming by wishful thinking" was first popularised by
the amazing, mind-expanding textbook
https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs[SICP], which I _cannot_ recommend highly enough.

In it, the authors use it as a way to think about and write code
at a higher level of abstraction,
without worrying about the details of a lower level,
that might not even exist yet.
For them, it's a key tool for designing programs,
and managing complexity.

We've been doing a lot of "programming by wishful thinking" in this book.
We've talked about how TDD itself is a form of wishful thinking,
our tests express that we _wish_ we had code that worked in such-and-such a way.

Outside-In TDD is very much an extension of this philosophy.
We start writing code at the higher levels
based on what we _wish_ we had at the lower levels,
even though it doesn't exist yet...

YAGNI also comes into it.  By driving our development from the outside in,
each piece of code we write is only there because we know it's actually needed
by a higher layer, and, ultimately, by the user.

*******************************************************************************


We can rerun our FTs, to check that we didn't break anything,
and to see whether we've got any further:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test functional_tests*]
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: Reticulate splines; [...]

 ---------------------------------------------------------------------
Ran 8 tests in 77.613s

FAILED (errors=1)
----

Well, no further, but at least we didn't break anything. Time for a commit:

[subs="specialcharacters,quotes"]
----
$ *git add src/lists*
$ *git diff --staged*   # urls+views.py, templates
$ *git commit -m "url, placeholder view, and first-cut templates for my_lists"*
----


==== Moving Down to the Next Layer: What the View Passes to the Template

((("templates", "views layer and")))
Now our views layer needs to respond to the requirements we've laid out in the template layer,
by giving it the objects it needs.
In this case, the list owner:

[role="sourcecode"]
.src/lists/tests/test_views.py (ch24l011)
====
[source,python]
----
from accounts.models import User
[...]


class MyListsTest(TestCase):
    def test_my_lists_url_renders_my_lists_template(self):
        [...]

    def test_passes_correct_owner_to_template(self):
        User.objects.create(email="wrong@owner.com")
        correct_user = User.objects.create(email="a@b.com")
        response = self.client.get("/lists/users/a@b.com/")
        self.assertEqual(response.context["owner"], correct_user)
----
====

Gives:

----
KeyError: 'owner'
----


So:

[role="sourcecode"]
.src/lists/views.py (ch24l012)
====
[source,python]
----
from accounts.models import User
[...]


def my_lists(request, email):
    owner = User.objects.get(email=email)
    return render(request, "my_lists.html", {"owner": owner})
----
====


That gets our new test passing, but we'll also see an error from the previous test.
We just need to add a user for it as well:


[role="sourcecode"]
.src/lists/tests/test_views.py (ch24l013)
====
[source,python]
----
    def test_my_lists_url_renders_my_lists_template(self):
        User.objects.create(email="a@b.com")
        [...]
----
====

And we get to an OK:
((("", startref="OITDDft22")))


----
OK
----


=== The Next "Requirement" from the Views Layer: New Lists Should Record Owner

((("Outside-In TDD", "views layer")))
Before we move down to the model layer,
there's another part of the code at the views layer that will need to use our model:
we need some way for newly created lists to be assigned to an owner,
if the current user is logged in to the site.

Here's a first crack at writing the test:


[role="sourcecode"]
.src/lists/tests/test_views.py (ch24l014)
====
[source,python]
----
class NewListTest(TestCase):
    [...]

    def test_list_owner_is_saved_if_user_is_authenticated(self):
        user = User.objects.create(email="a@b.com")
        self.client.force_login(user)  #<1>
        self.client.post("/lists/new", data={"text": "new item"})
        new_list = List.objects.get()
        self.assertEqual(new_list.owner, user)
----
====

<1> `force_login()` is the way you get the test client to make requests
    with a logged-in user.

The test fails as follows:

----
AttributeError: 'List' object has no attribute 'owner'
----

To fix it, let's first try writing code like this:


[role="sourcecode"]
.src/lists/views.py (ch24l015)
====
[source,python]
----
def new_list(request):
    form = ItemForm(data=request.POST)
    if form.is_valid():
        nulist = List.objects.create()
        nulist.owner = request.user  <1>
        nulist.save()  <2>
        form.save(for_list=nulist)
        return redirect(nulist)
    else:
        return render(request, "home.html", {"form": form})
----
====

<1> We'll set the `.owner` attribute on our new list
<2> And we'll try and save it to the datababase.


But it won't actually work, because we don't know _how_ to save a list owner yet:


----
    self.assertEqual(new_list.owner, user)
                     ^^^^^^^^^^^^^^
AttributeError: 'List' object has no attribute 'owner'
----


==== A Decision Point: Whether to Proceed to the Next Layer with a Failing Test

((("Outside-In TDD", "model layer", id="OITDDmodel21")))
In order to get this test passing, as it's written now,
we have to move down to the model layer.
However, it means doing more work with a failing test, which is not ideal.

((("mocks", "isolating tests using")))
The alternative is to rewrite the test
to make it more _isolated_ from the level below, using mocks.

On the one hand, it's a lot more effort to use mocks,
and it can lead to tests that are harder to read.
On the other hand, advocates of what's known as "London School" TDD
are very keen on the approach.
You can read an exploration of this approach in 
https://www.obeythetestinggoat.com/book/appendix_purist_unit_tests.html[Online Appendix: Test Isolation and "Listening to Your Tests"].

For now we'll accept the tradeoff, moving down one layer with failing tests,
but avoiding the extra mocks.

[[revisit_this_point_with_isolated_tests]]
Let's do a commit, and then _tag_ the commit as a way of remembering our
position if we want to revisit this decision later.

[subs="specialcharacters,quotes"]
----
$ *git commit -am "new_list view tries to assign owner but cant"*
$ *git tag revisit_this_point_with_isolated_tests*
----


=== Moving Down to the Model Layer

Our outside-in design has driven out two requirements for the model layer:
we want to be able to assign an owner to a list using the attribute `.owner`,
and we want to be able to access the list's owner with the API `owner.lists.all()`.


Let's write a test for that:


[role="sourcecode"]
.src/lists/tests/test_models.py (ch24l018)
====
[source,python]
----
from accounts.models import User
[...]


class ListModelTest(TestCase):
    def test_get_absolute_url(self):
        [...]
    def test_list_items_order(self):
        [...]

    def test_lists_can_have_owners(self):
        user = User.objects.create(email="a@b.com")
        mylist = List.objects.create(owner=user)
        self.assertIn(mylist, user.lists.all())
----
====

And that gives us a new unit test failure:

----
    mylist = List.objects.create(owner=user)
    [...]
TypeError: List() got unexpected keyword arguments: 'owner'
----

The naive implementation would be this:

[role="skipme"]
[source,python]
----
from django.conf import settings
[...]

class List(models.Model):
    owner = models.ForeignKey(settings.AUTH_USER_MODEL)
----

But we want to make sure the list owner is optional.  Explicit
is better than implicit, and tests are documentation, so let's have a test for
that too:


[role="sourcecode"]
.src/lists/tests/test_models.py (ch24l020)
====
[source,python]
----
    def test_list_owner_is_optional(self):
        List.objects.create()  # should not raise
----
====

The correct implementation is this:

[role="sourcecode"]
.src/lists/models.py (ch24l021)
====
[source,python]
----

class List(models.Model):
    owner = models.ForeignKey(
        "accounts.User",
        related_name="lists",
        blank=True,
        null=True,
        on_delete=models.CASCADE,
    )

    def get_absolute_url(self):
        return reverse("view_list", args=[self.id])
----
====

Now running the tests gives the usual database error:

----
    return super().execute(query, params)
           ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
django.db.utils.OperationalError: table lists_list has no column named owner_id
----


Because we need to make some migrations:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py makemigrations*]
Migrations for 'lists':
  src/lists/migrations/0007_list_owner.py
    + Add field owner to list
----
//22

We're almost there; a couple more failures in some of our old tests:

----
ERROR: test_can_save_a_POST_request
[...]
ValueError: Cannot assign "<SimpleLazyObject:
<django.contrib.auth.models.AnonymousUser object at 0x1069852e>>": "List.owner" must
be a "User" instance.
[...]

ERROR: test_redirects_after_POST
[...]
ValueError: Cannot assign "<SimpleLazyObject:
<django.contrib.auth.models.AnonymousUser object at 0x106a1b440>>": "List.owner" must
be a "User" instance.
----

We're moving back up to the views layer now, just doing a little tidying up.
Notice that these are in the existing test for the `new_list` view,
when we haven't got a logged-in user.

The tests are reminding us to think of this use case too:
we should only save the list owner when the user is actually logged in.
The `.is_authenticated` attribute we came across in <<chapter_19_spiking_custom_auth>>
comes in useful now
(when they're not logged in,
Django represents users using a class called `AnonymousUser`,
whose `.is_authenticated` is always `False`):


[role="sourcecode"]
.src/lists/views.py (ch24l023)
====
[source,python]
----
    if form.is_valid():
        nulist = List.objects.create()
        if request.user.is_authenticated:
            nulist.owner = request.user
            nulist.save()
        form.save(for_list=nulist)
        return redirect(nulist)
        [...]
----
====

And that gets us passing!

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test lists*]
[...]

Ran 36 tests in 0.237s

OK
----

This is a good time for a commit:

[subs="specialcharacters,quotes"]
----
$ *git add src/lists*
$ *git commit -m "lists can have owners, which are saved on creation."*
----



=== Final Step: Feeding Through the .name API from the Template

The last thing our outside-in design wanted came from the templates,
which wanted to be able to access a list "name" based on the text of
its first item:

[role="sourcecode"]
.src/lists/tests/test_models.py (ch24l024)
====
[source,python]
----
    def test_list_name_is_first_item_text(self):
        list_ = List.objects.create()
        Item.objects.create(list=list_, text="first item")
        Item.objects.create(list=list_, text="second item")
        self.assertEqual(list_.name, "first item")
----
====


[role="sourcecode"]
.src/lists/models.py (ch24l025)
====
[source,python]
----
    @property
    def name(self):
        return self.item_set.first().text
----
====

And that, believe it or not, actually gets us a passing test,
and a working "My Lists" page (<<my-lists-page>>)!

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test functional_tests*]
[...]
Ran 8 tests in 93.819s

OK
----

[[my-lists-page]]
.The "My Lists" page, in all its glory (and proof I did test on Windows)
image::images/tdd3_2404.png["Screenshot of new My Lists page"]

// DAVID: At the moment it's possible to see other users' list pages. (That's by design, right?)
// But then - I hate to say it - we probably shouldn't call it the 'My Lists' page, except in
// the link to the page.

.The @property Decorator in Python
*******************************************************************************

((("@property decorator")))
((("decorators", "property decorator")))
((("Python 3", "@property decorator")))
If you haven't seen it before, the `@property` decorator transforms a method
on a class to make it appear to the outside world like an attribute.

((("duck typing")))
This is a powerful feature of the language, because it makes it easy to
implement "duck typing", to change the implementation of a property without
changing the interface of the class.  In other words, if we decide to change
`.name` into being a "real" attribute on the model, which is stored as text in
the database, then we will be able to do so entirely transparently--as far as
the rest of our code is concerned, they will still be able to just access
`.name` and get the list name, without needing to know about the
implementation. Raymond Hettinger gave a
https://www.youtube.com/watch?v=HTLu2DFOdTg[classic, beginner-friendly talk on
this topic at Pycon back in 2013], which I enthusiastically recommend (it
covers about a million good practices for Pythonic class design besides).
Of course, in the Django template language, `.name` would still call the method
even if it didn't have `@property`, but that's a particularity of Django, and
doesn't apply to Python in general...
*******************************************************************************

// SEBASTIAN: While @property indeed is a helpful gimmick, I consider
// @property doing DB operations or causing other side-effects an anti-pattern.
// I wonder if readers of the book are also not already knowing that.
// What I suggest is to consider whether to keep it in this chapter or not.
// It seems to be a bit off. Might be as "quick hack" we're doing constantly to make
// tests pass but I wouldn't settle on leaving it as it is.

((("", startref="OITDDmodel21")))
In the next chapter, it's time to recruit some computers
to do more of the work for us.  Let's talk about Continuous Integration (CI).

// RITA: Later, let's check to make sure the end-of-chapter sidebars are consistent throughout the book. Some of them are called "Lessons Learned," others "Lessons Learned in X," and others are called just the topic name.

.Outside-In TDD
*******************************************************************************

Outside-In TDD::
    A methodology for building code, driven by tests,
    which proceeds by starting from the "outside" layers (presentation, GUI),
    and moving "inwards" step by step, via view/controller layers,
    down towards the model layer.
    The idea is to drive the design of your code from how it will be used,
    rather than trying to anticipate requirements from the bottom up.
    ((("Outside-In TDD", "defined")))

// SEBASTIAN: Might be worth mentioning that outside-in plays nicely with API-first
// or, at the very least, that it may also mean writing test at the API level
// if we have a SPA


Programming by wishful thinking::
    The outside-in process is sometimes called "programming by wishful thinking".
    Actually, any kind of TDD involves some wishful thinking.
    We're always writing tests for things that don't exist yet.
    ((("programming by wishful thinking")))


The pitfalls of outside-in::
    Outside-in isn't a silver bullet.
    It encourages us to focus on things that are immediately visible to the user,
    but it won't automatically remind us to write other critical tests
    that are less user-visible--things like security, for example.
    You'll need to remember them yourself.
    ((("", startref="TTDoutside22")))
    ((("Outside-In TDD", "drawbacks of")))


*******************************************************************************

