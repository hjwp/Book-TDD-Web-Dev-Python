[[chapter_27_hot_lava]]
== Fast Tests, Slow Tests, and Hot Lava

[quote, 'https://www.youtube.com/watch?v=bsmFVb8guMU[Casey Kinsey]']
______________________________________________________________
The database is Hot Lava!
______________________________________________________________


((("integration tests", "vs. unit tests", secondary-sortas="unit tests")))
((("unit tests", "vs. integration tests", secondary-sortas="integration tests")))
Unless you've been through <<appendix_purist_unit_tests>>,
almost all of the "unit" tests in the book
should arguably have been called _integration_ tests,
because they rely on the database.
A "real" unit test should only engage with the unit of code under test,
and not with any external systems like databases.

If you start reading around in the world of testing and TDD,
you'll soon come across people talking about the need to have more unit tests,
and fewer integration tests and functional tests.

This is often expressed as the "Test Pyramid",
whereby your test coverage is achieved with a large base of unit tests,
a smaller number of integration tests in the middle,
and a tiny number of functional tests at the top: <<test_pyramid>>.

[[test_pyramid]]
.The Test Pyramid
image::images/test_pyramid.png["A Pyramid shape, with a large bottom layer of unit tests, a medium layer of integration tests, and a small peak of FTs"]

Let's talk about why people say this,
and the trade-offs between different types of tests.


////
PLAN:
- unit tests vs integration tests
- the problem with django
- slow tests + hot lava
- the test pyramid
- do an analysis of our app
- talk about the django sweet spot
- what do we want from tests
- pros and cons table
- advertise my book
////

=== The Problem With Integration Tests

As we've seen, Django tends to encourage us towards writing integration tests.
The Django test runner sets up a clean database for each test,
and tools like the Django test client make it easy to interact with our application
from top layer in, thus engaging with all the layers of the stack.

The trouble is that once an application starts to grow beyond a certain size,
involving the database in every single test starts to carry an unacceptable cost,
in terms of the speed of execution if nothing else;
The database is hot lava, as Casey Kinsey put it in a memorable DjangoCon talk.
Casey's company was struggling with test suites that took several hours.
At PythonAnywhere, we had a functional test suite, at one point, that we only ran overnight.
At Kraken, the full test suite does only take about 45 minutes,
but that's only thanks to a quite frankly ridiculous level of parallelisation
and associated expenditure on CI.
But running even a single integration test takes a minimum of 25 seconds,
because of the size and complexity of the project (and its database).

Does that mean we've been doing it wrong all along, as we go through the book?
Not necessarily.

// instagram still runs on django


=== On the Benefits of a Fast Test Suite

Let's talk for a minute about the benefits of fast tests.


==== Faster Tests Mean Faster Development

Other things being equal, the faster your unit tests run, the better.
To a lesser extent, the faster _all_ your tests run, the better.

I've outlined the TDD test/code cycle in this book.
You've started to get a feel for the TDD workflow,
the way you flick between writing tiny amounts of code and running your tests.
You end up running your unit tests several times a minute,
and your functional tests several times a day.

So, on a very basic level, the longer they take, the more time you spend waiting
for your tests, and that will slow down your development.
But there's more to it than that.


==== The Holy Flow State

Thinking sociology for a moment, we programmers have our own culture,
and our own tribal religion in a way.
It has many congregations within it
such as the cult of TDD to which you are now initiated.
There are the followers of vi and the heretics of emacs.
But one thing we all agree on, one particular spiritual practice,
our own transcendental meditation, is the holy flow state.
That feeling of pure focus, of concentration,
where hours pass like no time at all,
where code flows naturally from our fingers,
where problems are just tricky enough to be interesting
but not so hard that they defeat us...

There is absolutely no hope of achieving flow
if you spend your time waiting for a slow test suite to run.
Anything longer than a few seconds and you're going to let your attention wander,
you context-switch, and the flow state is gone.
And the flow state is a fragile dream.
Once it's gone, it takes a while to get it back.


==== Slow Tests Means Slower Feedback, Which Causes Bad Code

If your test suite is slow and ruins your concentration,
the danger is that you'll start to avoid running your tests,
which means your feedback cycle gets even slower,
as you have to wait for CI to catch any accidental bugs or regressions
you might have introduced.

In addition, it can lead to becoming shy of refactoring our code,
since we know that any refactor will mean having to wait for ages while all the tests run.

In either case, bad code can be the result.


==== Don't Take It from Me

Gary Bernhardt, who has been in the testing game much longer that I have,
put these points eloquently in a talk called
https://www.youtube.com/watch?v=RAxiiRPHS9k[Fast Test, Slow Test].
I encourage you to watch it.



////
adfas

/////

==== And Unit Tests Drive Good Design

But perhaps more importantly than any of this,
remember the lesson from <<appendix_purist_unit_tests>>.
Going through the process of writing good, isolated unit tests
can help us drive out better designs for our code,
by forcing us to identify dependencies,
and encouraging us towards a decoupled architecture,
in a way that integrated tests don't.


=== The Problems with "Pure" Unit Tests

((("unit tests", "drawbacks of &#x201c;pure&#x201d;")))
All of this comes with a huge "but".
Writing isolated unit tests comes with its own pitfalls,
and avoiding them is a skill that takes time to develop.


==== Mocky Tests Can Be Harder to Read and Write

Cast your mind back to the first isolated unit test we wrote.  Wasn't it ugly?
Admittedly, things improved when we refactored things out into the forms,
but imagine if we hadn't followed through?
We'd have been left with a rather unreadable test in our codebase.
And even the final version of the tests we ended up with
contain some pretty mind-bending bits.


==== Isolated Tests Don't Automatically Test Integration

As we saw a little later on, isolated tests by their nature only test the
unit under test, in isolation.  They won't test the integration between
your units.

This problem is well known, and there are ways of mitigating it. But, as
we saw, those mitigations involve a fair bit of hard work on the part of
the programmer--you need to remember to keep track of the interfaces
between your units, to identify the implicit contract that each component
needs to honour, and to write tests for those contracts as well
as for the internal functionality of your unit.


==== Unit Tests Seldom Catch Unexpected Bugs

Unit tests will help you catch off-by-one errors and logic snafus, which are
the kinds of bugs we know we introduce all the time, so in a way we are
expecting them. But they don't warn you about some of the more unexpected
bugs.  They won't remind you when you forgot to create a database migration.
They won't tell you when the middleware layer is doing some clever HTML-entity
escaping that's interfering with the way your data is rendered...something
like Donald Rumsfeld's unknown unknowns?


==== Mocky Tests Can Become Closely Tied to Implementation

And finally, mocky tests can become very tightly coupled with the implementation.
If you choose to use `List.objects.create()` to build your objects but your
mocks are expecting you to use `List()` and `.save()`, you'll get failing tests
even though the actual effect of the code would be the same.   If you're not
careful, this can start to work against one of the supposed benefits of having
tests, which was to encourage refactoring.  You can find yourself having to
change dozens of mocky tests and contract tests when you want to change an
internal API.

Notice that this may be more of a problem when you're dealing with an API
you don't control.  You may remember the contortions we had to go through
to test our form, mocking out two Django model classes and using `side_effect`
to check on the state of the world.  If you're writing code that's totally
under your own control, you're likely to design your internal APIs so that
they are cleaner and require fewer contortions to test.
////



==== But All These Problems Can Be Overcome

But, isolation advocates will come back and say, all that stuff can be
mitigated; you just need to get better at writing isolated tests, and, remember
the holy flow state?  The holy flow state!

So do we have to choose one side or the other?
(((range="endofrange", startref="ix_unittestproscons")))


=== Synthesis: What Do We Want from Our Tests, Anyway?

((("testing best practices")))
((("Test-Driven Development (TDD)", "test goals")))
Let's step back and have a think about what benefits we want our tests to
deliver.  Why are we writing them in the first place?


==== Correctness

We want our application to be free of bugs--both low-level logic errors,
like off-by-one errors, and high-level bugs like the software not ultimately delivering what our users want.  We want to find out if we ever introduce
regressions which break something that used to work, and we want to find
that out before our users see something broken.  We expect our tests to
tell us our application is correct.


==== Clean, Maintainable Code

We want our code to obey rules like YAGNI and DRY.
We want code that clearly expresses its intentions,
which is broken up into sensible components
that have well-defined responsibilities and are easily understood.
We want to keep complexity at bay, and cognitive load to a minimum.
We expect our tests to give us the confidence to refactor our application constantly,
so that we're never scared to try to improve its design,
and we would also like it if they would actively help us to find the right design.


==== Productive Workflow

Finally, we want our tests to help enable a fast and productive workflow.
We want them to help take some of the stress out of development,
and we want them to protect us from stupid mistakes.
We want them to help keep us in the "flow" state not just because we enjoy it,
but because it's highly productive.
We want our tests to give us feedback about our work as quickly as possible,
so that we can try out new ideas and evolve them quickly.
And we don't want to feel like our tests are more of a hindrance than a help
when it comes to evolving our codebase.


==== Evaluate Your Tests Against the Benefits You Want from Them

I don't think there are any universal rules about how many tests you should
write and what the correct balance between functional, integrated, and isolated
tests should be.  Circumstances vary between projects.  But, by thinking about
all of your tests and asking whether they are delivering the benefits you want,
you can make some [keep-together]#decisions#.


[[test-types-tradeoffs]]
[options="header"]
.How do different types of test help us achieve our objectives?
|================
|Objective|Some considerations

|_Correctness_
a|
* Do I have enough functional tests to reassure myself that my application _really_ works,
  from the point of view of the user?
* Am I testing all the edge cases thoroughly?
  This feels like a job for low-level, isolated tests.
* Do I have tests that check whether all my components fit together properly?
  Could some integrations tests do this, or are functional tests enough?

|_Clean, maintainable code_
a|
* Are my tests giving me the confidence to refactor my code, fearlessly and frequently?
* Are my tests helping me to drive out a good design?
  If I have a lot of integration tests and few isolated tests,
  are there any parts of my application where putting in the effort
  to write more isolated tests would give me better feedback about my design?

|_Productive workflow_
a|
* Are my feedback cycles as fast as I would like them?
  When do I get warned about bugs,
  and is there any practical way to make that happen sooner?
* If I have a lot of high-level, functional tests that take a long time to run,
  and I have to wait overnight to get feedback about accidental regressions,
  is there some way I could write some faster tests that would get me feedback quicker?
* Can I run a subset of the full test suite when I need to?
* Am I spending too much time waiting for tests to run,
  and thus less time in a productive flow state?

|================



=== Architectural Solutions


((("architectural solutions")))
((("integrated tests", "architectural considerations")))
There are also some architectural solutions
that can help to get the most out of your test suite,
and particularly that help avoid some of the disadvantages of isolated tests.

Mainly these involve trying to identify the boundaries of your system--the
points at which your code interacts with external systems,
like the database or the filesystem, or the internet, or the UI--and
trying to keep them separate from the core business logic of your application.


==== Ports and Adapters/Hexagonal/Clean Architecture

Integrated tests are most useful at the 'boundaries' of a system--at
the points where our code integrates with external systems, like a
database, filesystem, or UI components.

Similarly, it's at the boundaries that the downsides of test isolation and
mocks are at their worst, because it's at the boundaries that you're most
likely to be annoyed if your tests are tightly coupled to an implementation,
or to need more reassurance that things are integrated properly.

Conversely, code at the 'core' of our application--code that's purely
concerned with our business domain and business rules, code that's
entirely under our control--has less need for integrated
tests, since we control and understand all of it.

So one way of getting what we want is to try to minimise the amount
of our code that has to deal with boundaries. Then we test our core business
logic with isolated tests and test our integration points with integrated
tests.

Steve Freeman and Nat Pryce, in their book
<<GOOSGBT, _Growing Object-Oriented Software, Guided by Tests_>>,
call this approach "Ports and Adapters" (see <<ports-and-adapters>>).

We actually started moving towards a ports and adapters architecture in <<appendix_purist_unit_tests>>,
when we found that writing isolated unit tests was encouraging us
to push ORM code out of the main application,
and hide it in helper functions from the model layer.

This pattern is also sometimes known as the "clean architecture" or "hexagonal architecture".
See <<ch26_furtherreading>> for more info.


[[ports-and-adapters]]
.Ports and Adapters (diagram by Nat Pryce)
image::images/twp2_2601.png["Illustration of ports and adapaters architecture, with isolated core and integration points"]


==== Functional Core, Imperative Shell

Gary Bernhardt pushes this further, recommending an architecture he calls
"Functional Core, Imperative Shell", whereby the "shell" of the application,
the place where interaction with boundaries happens, follows the imperative
programming paradigm, and can be tested by integrated tests, acceptance tests,
or even (gasp!) not at all, if it's kept minimal enough. But the core of the
application is actually written following the functional programming paradigm
(complete with the "no side effects" corollary), which actually allows fully
isolated, "pure" unit tests, 'entirely without mocks'.

Check out Gary's presentation titled
https://www.youtube.com/watch?v=eOYal8elnZk["Boundaries"] for more on this
approach.



=== Conclusion

I've tried to give an overview of some of the more advanced considerations
that come into the TDD process. Mastery of these topics is something
that comes from long years of practice, and I'm not there yet, by any means. So
I heartily encourage you to take everything I've said with a pinch of salt, to
go out there, try various approaches, listen to what other people have to say
too, and find out what works for you.

Here are some places to go for further reading.
((("Test-Driven Development (TDD)", "additional resources")))

[[ch26_furtherreading]]
==== Further Reading

Fast Test, Slow Test and Boundaries::
    Gary Bernhardt's talks from Pycon
    https://www.youtube.com/watch?v=RAxiiRPHS9k[2012] and
    https://www.youtube.com/watch?v=eOYal8elnZk[2013].  His
    http://www.destroyallsoftware.com[screencasts] are also well worth a look.

Ports and Adapters::
    Steve Freeman and Nat Pryce wrote about this in <<GOOSGBT, their book>>.
    You can also catch a good discussion in
    http://vimeo.com/83960706[this talk]. See also
    http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html[Uncle
    Bob's description of the clean architecture], and
    http://alistair.cockburn.us/Hexagonal+architecture[Alistair Cockburn
    coining the term "hexagonal architecture"].

Hot Lava::
    https://www.youtube.com/watch?v=bsmFVb8guMU[Casey Kinsey's memorable
    phrase] encouraging you to avoid touching the database, whenever you can.

Inverting the Pyramid::
    The idea that projects end up with too great a ratio of slow, high-level
    tests to unit tests, and a
    http://watirmelon.com/tag/testing-pyramid/[visual metaphor for the effort
    to invert that ratio].

Integrated tests are a scam::
    J.B. Rainsberger has a
    http://blog.thecodewhisperer.com/2010/10/16/integrated-tests-are-a-scam/[famous rant]
    about the way integrated tests will ruin your life.
    Then check out a couple of follow-up posts, particularly
    http://www.jbrains.ca/permalink/using-integration-tests-mindfully-a-case-study[this
    defence of acceptance tests] (what I call functional tests), and
    http://www.jbrains.ca/permalink/part-2-some-hidden-costs-of-integration-tests[this
    analysis of how slow tests kill productivity].
    ((("integrated tests", "benefits and drawbacks of")))

The Test-Double testing wiki::
    Justin Searls's online resource is a great source of definitions
    and discussions of testing pros and cons,
    and arrives at its own conclusions of the right way to do things:
    https://github.com/testdouble/contributing-tests/wiki/Test-Driven-Development[testing wiki].

A pragmatic view::
    Martin Fowler (author of 'Refactoring') presents a
    http://martinfowler.com/bliki/UnitTest.html[reasonably balanced, pragmatic approach].


.On Getting the Balance Right Between Different Types of Test
******************************************************************************
Start out by being pragmatic::
    Spending a long time agonising about what kinds of test to write
    is a great way to prevaricate.
    Better to start by writing whichever type of test occurs to you first,
    and change it later if you need to.
    Learn by doing.

Focus on what you want from your tests::
    Your objectives are 'correctness', 'good design', and 'fast feedback cycles'.
    Different types of test will help you achieve each of these in different measures.
    <<test-types-tradeoffs>> has some good questions to ask yourself.

Architecture matters::
    Your architecture to some extent dictates the types of tests that you need.
    The more you can separate your business logic from your external dependencies,
    and the more modular your code, the closer you'll get to a nice balance
    between unit tests, integration tests and end-to-end tests.
******************************************************************************

