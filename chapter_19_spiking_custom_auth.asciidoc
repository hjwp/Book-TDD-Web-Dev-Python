[[chapter_19_spiking_custom_auth]]
== User Authentication, Spiking, [keep-together]#and De-Spiking#

((("authentication", id="AuthSpike18")))
Our beautiful lists site has been live for a few days,
and our users are starting to come back to us with feedback.
"We love the site", they say, "but we keep losing our lists.
Manually remembering URLs is hard.
It'd be great if it could remember what lists we'd started."

Remember Henry Ford and faster horses. Whenever you hear a user requirement,
it's important to dig a little deeper
and think--what is the real requirement here?
And how can I make it involve a cool new technology I've been wanting to try out?

Clearly the requirement here
is that people want to have some kind of user account on the site.
So, without further ado, let's dive into authentication.

((("passwords")))
Naturally we're not going to mess about
with remembering passwords ourselves--besides being _so_ '90s,
secure storage of user passwords is a security nightmare
we'd rather leave to someone else.
We'll use something fun called "passwordless authentication" instead.footnote:[If you _insist_ on storing your own passwords, Django's default authentication module is ready and waiting for you. It's nice and straightforward, and I'll leave it to you to discover on your own.]

=== Passwordless Auth with "Magic Links"

((("authentication", "passwordless")))
((("magic links")))
((("OAuth")))
((("Openid")))
What authentication system could we use to avoid storing passwords ourselves?
OAuth?  OpenID?  "Sign in with Facebook"? Ugh.((("passwords", "passwordless authentication with magic links")))
For me, those all have unacceptable creepy overtones;
why should Google or Facebook know what sites you're logging in to and when?

Instead, for the second edition,footnote:[
In the first edition, I used an experimental project called "Persona",
cooked up by some of the wonderful techno-hippie-idealists at Mozilla,
but sadly that project was abandoned.]
I found a fun approach to authentication
that now goes by the name of "Magic Links",
but you might call it "just use email".

The system was invented (or at least popularised) back in 2014((("emails", "using to verify identity")))
by someone annoyed at having to create new passwords for so many websites.
They found themselves just using random, throwaway passwords,
not even trying to remember them, and using the "forgot my password" feature
whenever they needed to log in again.
You can https://oreil.ly/je14i[read
all about it on Medium].

The concept is:  just use email to verify someone's identity.
If you're going to have a "forgot my password" feature,
then you're trusting email anyway, so why not just go the whole hog?
Whenever someone wants to log in,
we generate a unique URL for them to use, email it to them,
and they then click through that to get into the site.

It's by no means a perfect system,
and in fact there are lots of subtleties to be thought through
before it would really make a good login solution for a production website,
but this is just a fun toy project so let's give it a go.


=== A Somewhat Larger Spike

NOTE: Reminder: a spike is a phase of exploratory coding,
  where we can code without tests,
  in order to explore a new tool or experiment with a new idea.
  We will come back and redo the code "properly" with TDD later.((("spiking and de-spiking", "spiking magic links authentication", id="ix_spkauth")))

((("django-allauth")))
((("python-social-auth")))
To get this Magic Links project set up, the first thing I did was take a look at existing Python and Django authentication
packages, like https://docs.allauth.org[django-allauth],
but both of them looked overcomplicated for this stage
(and besides, it'll be more fun to code our own!).


So instead, I dived in and hacked about, and after a few dead ends and wrong turns,
I had something that just about works.
I'll take you on a tour,
and then we'll go through and "de-spike" the implementation--that is,
replace the prototype with tested, production-ready code.

You should go ahead and add this code to your own site too,
and then you can have a play with it.
Try logging in with your own email address,
and convince yourself that it really does work.



==== Starting a Branch for the Spike

((("spiking and de-spiking", "branching your VCS")))
((("Git", "creating branches")))
This spike is going to be a bit more involved than the last one,
so we'll be a little more rigorous with our version control. Before embarking on a spike it's a good idea to start a new branch,
so you can still use your VCS without worrying about
your spike commits getting mixed up with your production code:

[subs="specialcharacters,quotes"]
----
$ *git switch -c passwordless-spike*
----

Let's keep track of some of the things we're hoping to learn from the
spike:

[role="scratchpad"]
*****
* _How to send emails_
* _Generating and recognising unique tokens_
* _How to authenticate someone in Django_
*****


==== Frontend Login UI


((("authentication", "frontend login UI")))
Let's start with the frontend by adding in
an actual form to enter your email address into the navbar,
along with a logout link for users who are already authenticated:

[role="sourcecode"]
.src/lists/templates/base.html (ch19l001)
====
[source,html]
----
  <body>
    <div class="container">

      <div class="navbar">
        {% if user.is_authenticated %}
          <p>Logged in as {{ user.email }}</p>
          <form method="POST" action="/accounts/logout">
            {% csrf_token %}
            <button id="id_logout" type="submit">Log out</button>
          </form>
        {% else %}
          <form method="POST" action ="accounts/send_login_email">
            Enter email to log in: <input name="email" type="text" />
            {% csrf_token %}
          </form>
        {% endif %}
      </div>

      <div class="row justify-content-center p-5 bg-body-tertiary rounded-3">
      [...]
----
====


==== Sending Emails from Django

((("authentication", "sending emails from Django", id="SDemail18")))
((("Django framework", "sending emails", id="DFemail18")))
((("send_mail function", id="sendmail18")))
((("emails", "sending from Django", id="ix_emlDj")))
The login will be something like <<magic-links-diagram>>.

[[magic-links-diagram]]
.Overview of the Magic Links login process
image::images/tdd3_1901.png["A diagram showing the interaction between user and server.  First the user fills in a login form and gives their email.  the server creates a token associated with that email, and then sends them an email containg a magic link, which includes the token.  the user waits for the email.  they click the link in the email, which goes to another endpoint on the server. it then checks if the token is valid, and if so, logs the user in."]

1. When someone wants to log in, we generate a unique secret token for them,
  link it to their email, store it in the database, and send it to them.

2. The user then checks their email,
  which will have a link for a URL that includes that token.

3. When they click that link, we check whether the token exists in the database
  and, if so, they are logged in as the associated user.

// https://docs.djangoproject.com/en/5.2/topics/auth/customizing/


First, let's prep an app for our accounts stuff:


[subs="specialcharacters,quotes"]
----
$ *cd src && python manage.py startapp accounts && cd ..*
$ *ls src/accounts*
__init__.py admin.py    apps.py     migrations  models.py   tests.py    views.py
----

// DAVID: Worth discussing why you chose to make this an app?

And we'll wire up _urls.py_ with at least one URL.
In the top-level _superlists/urls.py_...

[role="sourcecode"]
.src/superlists/urls.py (ch19l003)
====
[source,python]
----
from django.urls import include, path
from lists import views as list_views

urlpatterns = [
    path("", list_views.home_page, name="home"),
    path("lists/", include("lists.urls")),
    path("accounts/", include("accounts.urls")),
]
----
====

[role="pagebreak-before"]
And we give the accounts module its own _urls.py_:


[role="sourcecode"]
.src/accounts/urls.py (ch19l004)
====
[source,python]
----
from django.urls import path

from accounts import views

urlpatterns = [
    path("send_login_email", views.send_login_email, name="send_login_email"),
]
----
====

Here's the view that's in charge of((("tokens", "creating, view for"))) creating a token
associated with the email address that the user puts in our login form:

[role="sourcecode"]
.src/accounts/views.py (ch19l005)
====
[source,python]
----
import sys
import uuid

from django.core.mail import send_mail
from django.shortcuts import render

from accounts.models import Token


def send_login_email(request):
    email = request.POST["email"]
    uid = str(uuid.uuid4())
    Token.objects.create(email=email, uid=uid)
    print("saving uid", uid, "for email", email, file=sys.stderr)
    url = request.build_absolute_uri(f"/accounts/login?uid={uid}")
    send_mail(
        "Your login link for Superlists",
        f"Use this link to log in:\n\n{url}",
        "noreply@superlists",
        [email],
    )
    return render(request, "login_email_sent.html")
----
====


For that to work, we'll need((("templates", "messaging confirming login email sent"))) a template with a placeholder message confirming the email was
sent:

[role="sourcecode"]
.src/accounts/templates/login_email_sent.html (ch19l006)
====
[source,html]
----
<html>
<h1>Email sent</h1>

<p>Check your email, you'll find a message with a link that will log you into
the site.</p>

</html>
----
====

(You can see how hacky this code is--we'd want to integrate this template
with our 'base.html' in the real version.)

==== Email Server Config for Django

The https://docs.djangoproject.com/en/5.2/topics/email[django docs on email]
explain how `send_mail()` works, as well as how you configure it
by telling Django what email server to use,
and how to authenticate with it.
Here, I'm just using my Gmailfootnote:[
Didn't I just spend a whole intro banging on about the privacy implications
of using Google for login, only to go on and use Gmail?
Yes, it's a contradiction (honest, I will move off Gmail one day!).((("SMTP (Simple Mail Transfer Protocol)")))
But in this case I'm just using it for testing,
and the important thing is that I'm not forcing Google on my users.]
account for now—but you can use any email provider you like, as long as they support SMTP (Simple Mail Transfer Protocol):

[role="sourcecode"]
.src/superlists/settings.py (ch19l007)
====
[source,python]
----
EMAIL_HOST = "smtp.gmail.com"
EMAIL_HOST_USER = "obeythetestinggoat@gmail.com"
EMAIL_HOST_PASSWORD = os.environ.get("EMAIL_PASSWORD")
EMAIL_PORT = 587
EMAIL_USE_TLS = True
----
====

TIP: If you want to use Gmail as well,
    you'll probably have to visit your Google account security settings page.
    If you're using two-factor authentication, you'll want to set up an
    https://myaccount.google.com/apppasswords[app-specific password].
    If you're not, you will probably still need to
    https://www.google.com/settings/security/lesssecureapps[allow access for less secure apps].
    You might want to consider creating a new Google account for this purpose,
    rather than using one containing sensitive data.
    ((("Gmail")))
((("emails", "sending from Django", startref="ix_emlDj")))
((("", startref="sendmail18")))
((("", startref="DFemail18")))
((("", startref="SDemail18")))


==== Another Secret, Another Environment Variable

((("authentication", "avoiding secrets in source code")))
((("environment variables")))((("secrets", "storing in environment variables")))
Once again, we have a "secret"
that we want to avoid keeping directly in our source code or on GitHub,
so another environment variable is used in the `os.environ.get`. To get this to work,
we need to set it in the shell that's running my dev server:

[subs="specialcharacters,quotes"]
----
$ *export EMAIL_PASSWORD="ur-email-server-password-here"*
----

Later, we'll see about adding that to the env file
on the staging server as well.

[role="pagebreak-before less_space"]
==== Storing Tokens in the Database

// CSANAD (transcribed) you should probably hash the tokens

((("authentication", "storing tokens in databases")))
((("tokens", "storing in the database")))
How are we doing? Let's review where we're at in the process:

[role="scratchpad"]
*****
* _[strikethrough line-through]#How to send emails#_
* _Generating and recognising unique tokens_
* _How to authenticate someone in Django_
*****

// DAVID: In practice would we really cross something off the list like this before giving it a try?
// Might be better to gradually build things up, e.g. write a function to send an email (and check it works).
// Could even use as an excuse to introduce manage.py shell and do it from there?
// Equally with the user interface stuff, maybe starting up the application and having a look at what it looks like?
// Or maybe start with the model and then layer things on top of that.

We'll need a model to store our tokens in the database--they
link an email address with a unique ID.
It's pretty simple:


[role="sourcecode"]
.src/accounts/models.py (ch19l008)
====
[source,python]
----
from django.db import models


class Token(models.Model):
    email = models.EmailField()
    uid = models.CharField(max_length=255) <1>
----
====

<1> Django does have a specific UID (universally unique identifier) fields type for many databases,
but I just want to keep things simple for now.

The point of this spike is about authentication and emails,
not optimising database storage.
We've got enough things we need to learn as it is!


Let's switch on our new accounts app in _settings.py_:

[role="sourcecode"]
.src/superlists/settings.py (ch19l008-1)
====
[source,python]
----
INSTALLED_APPS = [
    # "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "lists",
    "accounts",
]
----
====

[role="pagebreak-before"]
We can then do a quick ((("database migrations", "adding token model to database")))migrations dance to add the token model to the database:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py makemigrations*]
Migrations for 'accounts':
  src/accounts/migrations/0001_initial.py
    + Create model Token
$ pass:quotes[*python src/manage.py migrate*]
Operations to perform:
  Apply all migrations: accounts, auth, contenttypes, lists, sessions
Running migrations:
  Applying accounts.0001_initial... OK
----
//ch19l008-2


And at this point, if you actually try the email form in your browser,
you'll see it really does send an actual real email—to your real email address hopefully (best not spam someone else now!). See Figures <<spike-email-sent, 19-2>> and <<spike-email-received, 19-3>>.


[[spike-email-sent]]
.Looks like we might have sent an email
image::images/tdd3_1902.png["The email sent confirmation page, indicating the server at least thinks it sent an email successfully"]

[[spike-email-received]]
.Yep, looks like we received it
image::images/tdd3_1903.png["Screenshot of my email client showing the email from the server, saying 'your login link for superlist' and including a token url"]

[role="pagebreak-before less_space"]
==== Custom Authentication Models

((("authentication", "custom authentication models")))
OK, so we've done the first half of "Generating and recognising unique tokens":

[role="scratchpad"]
*****
* '[strikethrough line-through]#How to send emails#'
* '[strikethrough line-through]#Generating# and recognising unique tokens'
* 'How to authenticate someone in Django'
*****

But, before we can move on to recognising them and making the login work end-to-end though,
we need to explore Django's authentication system.((("Django framework", "authentication system")))((("user models", "Django authentication user model"))) The first thing we'll need is a user model.
I took a dive into the https://docs.djangoproject.com/en/5.2/topics/auth/customizing[Django
auth documentation] and tried to hack in the simplest possible one:

[role="sourcecode"]
.src/accounts/models.py (ch19l009)
====
[source,python]
----
from django.contrib.auth.models import (
    AbstractBaseUser,
    BaseUserManager,
)
[...]


class ListUser(AbstractBaseUser):
    email = models.EmailField(primary_key=True)
    USERNAME_FIELD = "email"
    # REQUIRED_FIELDS = ['email', 'height']

    objects = ListUserManager()

    @property
    def is_staff(self):
        return self.email == "harry.percival@example.com"

    @property
    def is_active(self):
        return True
----
====
// DAVID: Maybe better include the ListUserManager() here too? Or leave it out until we create it?


[role="pagebreak-before"]
That's what I call a minimal user model!
One field, none of this first name/last name/username nonsense,
and—pointedly—no password! That's somebody else's problem!

But, again, you can see that this code isn't ready for production—from the commented-out lines to the hardcoded Harry email address.
We'll neaten this up quite a lot when we de-spike.


To get it to work, I needed to add a model manager for the user,
for some reason:

[role="sourcecode small-code"]
.src/accounts/models.py (ch19l010)
====
[source,python]
----
[...]
class ListUserManager(BaseUserManager):
    def create_user(self, email):
        ListUser.objects.create(email=email)

    def create_superuser(self, email, password):
        self.create_user(email)
----
====

// CSANAD: ListUserManager has to be defined before ListUser, since its
// reference to ListUser isn't evaluated until `create_user` is called. This is
// not the case the other way around, ListUser's reference to ListUserManager
// is instantiated in the class definition. Maybe we could leave a note about
// this?


No need to worry about what a model manager is at this stage;
for now, we just need it because we need it, and it works.
When we de-spike, we'll examine each bit of code that actually ends up in production
and make sure we understand it fully.

We'll need to run `makemigrations` and `migrate` again to make the user model real:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py makemigrations*]
Migrations for 'accounts':
  src/accounts/migrations/0002_listuser.py
    + Create model ListUser
$ pass:quotes[*python src/manage.py migrate*]
[...]
Running migrations:
  Applying accounts.0002_listuser... OK
----
//ch19l009-1


==== Finishing the Custom Django Auth

Let's review our scratchpad:

[role="scratchpad"]
*****
* _[strikethrough line-through]#How to send emails#_
* _[strikethrough line-through]#Generating# and recognising unique tokens_
* _How to authenticate someone in Django_
*****

[role="pagebreak-before"]
((("Django framework", "custom authentication system", id="ix_Djcusauth")))((("authentication", "custom Django authentication", id="SDcustom18")))
Hmm, we can't quite cross off anything yet.
Turns out the steps we _thought_ we'd go through
aren't quite the same as the steps we're _actually_ going through
(this is not uncommon, as I'm sure you know).
// CSANAD: I find it vague like this. Maybe it would be helpful to clarify what
// it is that "we are actually going through" and what it was that
// "we thought we'd go through".

Still, we're almost there--our last step will combine recognising the token
and then actually logging the user in.
Once we've done this,
we'll be able to pretty much strike off all the items on our scratchpad.


So here's the view that actually handles the click-through from the link in the
email:

[role="sourcecode small-code"]
.src/accounts/views.py (ch19l011)
====
[source,python]
----
import sys
import uuid

from django.contrib.auth import authenticate
from django.contrib.auth import login as auth_login
from django.core.mail import send_mail
from django.shortcuts import redirect, render

from accounts.models import Token


def send_login_email(request):
    [...]


def login(request):
    print("login view", file=sys.stderr)
    uid = request.GET.get("uid")
    user = authenticate(request, uid=uid)
    if user is not None:
        auth_login(request, user)
    return redirect("/")
----
====

The `authenticate()` function invokes Django's authentication framework,
which we configure using a custom "authentication backend,"
whose job it is to validate the UID (unique identifier) and return a user with the right email.

[role="pagebreak-before"]
We could have done this stuff directly in the view,
but we may as well structure things the way Django expects.
It makes for a reasonably neat separation of concerns:


[role="sourcecode"]
.src/accounts/authentication.py (ch19l012)
====
[source,python]
----
import sys

from accounts.models import ListUser, Token

from django.contrib.auth.backends import BaseBackend


class PasswordlessAuthenticationBackend(BaseBackend):
    def authenticate(self, request, uid):
        print("uid", uid, file=sys.stderr)
        if not Token.objects.filter(uid=uid).exists():
            print("no token found", file=sys.stderr)
            return None
        token = Token.objects.get(uid=uid)
        print("got token", file=sys.stderr)
        try:
            user = ListUser.objects.get(email=token.email)
            print("got user", file=sys.stderr)
            return user
        except ListUser.DoesNotExist:
            print("new user", file=sys.stderr)
            return ListUser.objects.create(email=token.email)

    def get_user(self, email):
        return ListUser.objects.get(email=email)
----
====


Again, lots of debug prints in there, and some duplicated code—not something we'd want in production, but it works...as long as we add it to _settings.py_ (it doesn't matter where):

[role="sourcecode"]
.src/superlists/settings.py (ch19l012-1)
====
[source,python]
----
AUTH_USER_MODEL = "accounts.ListUser"
AUTHENTICATION_BACKENDS = [
    "accounts.authentication.PasswordlessAuthenticationBackend",
]
----
====

[role="pagebreak-before"]
And finally, a logout view:


[role="sourcecode"]
.src/accounts/views.py (ch19l013)
====
[source,python]
----
from django.contrib.auth import authenticate
from django.contrib.auth import login as auth_login
from django.contrib.auth import logout as auth_logout
[...]


def logout(request):
    auth_logout(request)
    return redirect("/")
----
====


Add login and logout to our _urls.py_...

[role="sourcecode"]
.src/accounts/urls.py (ch19l014)
====
[source,python]
----
urlpatterns = [
    path("send_login_email", views.send_login_email, name="send_login_email"),
    path("login", views.login, name="login"),
    path("logout", views.logout, name="logout"),
]
----
====



And we should be all done! Spin up a dev server with `runserver` and try it--believe it or not, it _actually_ works (see <<spike-login-worked>>).

[[spike-login-worked]]
.It works! It works!
image::images/tdd3_1904.png["screenshot of several windows including gmail and terminals but in the foreground our site showing us as being logged in."]

TIP: If you get an `SMTPSenderRefused` error message, don't forget to set
    the `EMAIL_PASSWORD` environment variable in the shell that's running
    `runserver`.
    ((("SMTPSenderRefused error message")))Also, if you see a message saying "Application-specific password required",
    that's a Gmail security policy.  Follow the link in the error message.

That's pretty much it!
Along the way, I had to fight pretty hard,
including clicking around the Gmail account security UI for a while,
stumbling over several missing attributes on my custom user model
(because I didn't read the docs properly),
and even at one point switching to the dev version of Django to overcome a bug,
which thankfully turned out to be a red herring.
((("Django framework", "custom authentication system", startref="ix_Djcusauth")))((("", startref="SDcustom18")))


But we now have a working solution!  Let's commit it on our spike branch:

[subs="specialcharacters,quotes"]
----
$ *git status*
$ *git add src/accounts*
$ *git commit -am "spiked in custom passwordless auth backend"*
----

[role="scratchpad"]
*****
* _[strikethrough line-through]#How to send emails#_
* _[strikethrough line-through]#Generating and recognising unique tokens#_
* _[strikethrough line-through]#_How to authenticate someone in Django#_
*****



Time to de-spike!

[role="pagebreak-before less_space"]
=== De-spiking

((("spiking and de-spiking", "spiking magic links authentication", startref="ix_spkauth")))((("spiking and de-spiking", "de-spiking authentication code", id="SDde18")))((("authentication", "de-spiking authentication code", id="ix_authdes")))
De-spiking means rewriting your prototype code using TDD. De-spiking means rewriting your prototype code using TDD.  In this section, we’ll work through how to do that in a safe and methodical way. We’ll take the knowledge we’ve acquired during the spiking process—whether that’s in our heads, in our notes, or in our branch in Git—and apply it as we re-implement gradually in a test-first way. And the hope is that our code will turn out a bit nicer the second time around!

[role="pagebreak-before less_space"]
==== Making a Plan

While it's fresh in our minds,
let's make a few notes based on what we've learned
about what we know we're probably going to need to build during our de-spike:

[role="scratchpad"]
*****
* _Token model with email and UID_
* _View to create token and send login email incl. url w/ token UID_
* _Custom user model with USERNAME_FIELD=email_
* _Authentication backend with authenticate() and get_user() functions_
* _Registering auth backend in settings.py_
* _Login view calls authenticate() and login() from django.contrib.auth_
* _Logout view calls django.contrib.auth.logout_
*****


==== Wring an FT Against the Spiked Code

We now have enough information to "do it properly".
So, what's the first step?  An FT, of course! We'll stay on the spike branch for now
to see our FT pass against our spiked code.
Then we'll go back to our main branch and commit just the FT.

[role="pagebreak-before"]
Here's a first, simple version of the FT:

[role="sourcecode small-code"]
.src/functional_tests/test_login.py (ch19l018)
====
[source,python]
----
import re

from django.core import mail
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys

from .base import FunctionalTest

TEST_EMAIL = "edith@example.com"  # <1>
SUBJECT = "Your login link for Superlists"


class LoginTest(FunctionalTest):
    def test_login_using_magic_link(self):
        # Edith goes to the awesome superlists site
        # and notices a "Log in" section in the navbar for the first time
        # It's telling her to enter her email address, so she does
        self.browser.get(self.live_server_url)
        self.browser.find_element(By.CSS_SELECTOR, "input[name=email]").send_keys(
            TEST_EMAIL, Keys.ENTER
        )

        # A message appears telling her an email has been sent
        self.wait_for(
            lambda: self.assertIn(
                "Check your email",
                self.browser.find_element(By.CSS_SELECTOR, "body").text,
            )
        )

        # She checks her email and finds a message
        email = mail.outbox.pop()  # <2>
        self.assertIn(TEST_EMAIL, email.to)
        self.assertEqual(email.subject, SUBJECT)

        # It has a URL link in it
        self.assertIn("Use this link to log in", email.body)
        url_search = re.search(r"http://.+/.+$", email.body)
        if not url_search:
            self.fail(f"Could not find url in email body:\n{email.body}")
        url = url_search.group(0)
        self.assertIn(self.live_server_url, url)

        # she clicks it
        self.browser.get(url)

        # she is logged in!
        self.wait_for(
            lambda: self.browser.find_element(By.CSS_SELECTOR, "#id_logout"),
        )
        navbar = self.browser.find_element(By.CSS_SELECTOR, ".navbar")
        self.assertIn(TEST_EMAIL, navbar.text)
----
====

<1> Whenever you're testing against something that can send real emails,
    you don't want to use a real address.
    It's best practice to use a special domain like `@example.com`,
    which has been reserved for exactly this sort of thing,
    to avoid accidentally spamming anyone!

<2> Were you worried about how we were going to handle retrieving emails
    in our tests?
    Thankfully, we can cheat for now!
    When running tests, Django gives us access to any emails that
    the server tries to send via the `mail.outbox` attribute.
    We'll discuss checking "real" emails in <<chapter_23_debugging_prod>>.


And if we run the FT, it works!

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test functional_tests.test_login*]
[...]
Not Found: /favicon.ico
saving uid [...]
login view
uid [...]
got token
new user

.
 ---------------------------------------------------------------------
Ran 1 test in 2.729s

OK
----

You can even see some of the debug output I left in my spiked view implementations.
Now it's time to revert all of our temporary changes,
and reintroduce them one by one in a test-driven way.


==== Reverting Our Spiked Code

We can revert our spike using our version ((("Git", "reverting spiked code")))control system:

[subs="specialcharacters,quotes"]
----
$ *git switch main* # switch back to main branch
$ *rm -rf src/accounts* # remove any trace of spiked code
$ *git add src/functional_tests/test_login.py*
$ *git commit -m "FT for login via email"*
----

Now we rerun the FT and let it be the main driver of our development,
referring back to our scratchpad from time to time when we need to:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test functional_tests.test_login*]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: input[name=email]; [...]
[...]
----

TIP: If you see an exception saying "No module named accounts",
    you may have missed a step in the de-spiking process—maybe a commit or the change of branch.


The first thing it wants us to do is add an email input element.
Bootstrap has some built-in classes for navigation bars,
so we'll use them, and include a form for the login email:footnote:[
We are now introducing a conceptual dependency from the base template
to the `accounts` app because its URL is in the form.
I didn't want to spend time on this in the book,
but this might be a good time to consider moving the template
out of _lists/templates_ and into _superlists/templates_.
By convention, that's the place for templates
whose scope is wider than a single app.]

[role="sourcecode"]
.src/lists/templates/base.html (ch19l020)
====
[source,html]
----
<body>
  <div class="container">

    <nav class="navbar">
      <div class="container-fluid">
        <a class="navbar-brand" href="/">Superlists</a>
        <form method="POST" action="/accounts/send_login_email">
          <div class="input-group">
            <label class="navbar-text me-2" for="id_email_input">
              Enter your email to log in
            </label>
            <input
              id="id_email_input"
              name="email"
              class="form-control"
              placeholder="your@email.com"
            />
            {% csrf_token %}
          </div>
        </form>
      </div>
    </nav>


    <div class="row justify-content-center p-5 bg-body-tertiary rounded-3">
      <div class="col-lg-6 text-center">
        <h1 class="display-1 mb-4">{% block header_text %}{% endblock %}</h1>
        [...]
----
====



At this point, you'll find that the unit tests start to fail:

----
ERROR: test_renders_input_form
[...]
    [form] = parsed.cssselect("form[method=POST]")
    ^^^^^^
ValueError: too many values to unpack (expected 1)

ERROR: test_renders_input_form
    [form] = parsed.cssselect("form[method=POST]")
    ^^^^^^
ValueError: too many values to unpack (expected 1)
----

It's because these unit tests had a hard assumption
that there's only one POST form on the page. Let's change them to be more resilient.
Here's how you might change the first one:


[role="sourcecode small-code"]
.src/lists/tests/test_views.py (ch19l020-1)
====
[source,python]
----
    def test_renders_input_form(self):
        response = self.client.get("/")
        parsed = lxml.html.fromstring(response.content)
        forms = parsed.cssselect("form[method=POST]")  # <1>
        self.assertIn("/lists/new", [form.get("action") for form in forms])  # <2>
        [form] = [form for form in forms if form.get("action") == "/lists/new"]  # <3>
        inputs = form.cssselect("input")  # <4>
        self.assertIn("text", [input.get("name") for input in inputs])  # <4>
----
====

<1> We get all forms, rather than using the clever `[form] =` syntax.

<2> We check that at least _one_ of the forms has the right `action=` URL.
    I'm using `assertIn()`, so we get a nice error message. If we can't find the right URL,
    we'll see the list of URLs that _do_ exist on the page.

<3> Now we can feel free to go back to unpacking,
    and get the right form, based on its `action` attribute.

<4> The rest of the test is as before.


Here's a similar set of changes in the second test:


[role="sourcecode"]
.src/lists/tests/test_views.py (ch19l020-2)
====
[source,diff]
----
@@ -65,10 +65,12 @@ class ListViewTest(TestCase):

     def test_renders_input_form(self):
         mylist = List.objects.create()
-        response = self.client.get(f"/lists/{mylist.id}/")
+        url = f"/lists/{mylist.id}/"
+        response = self.client.get(url)
         parsed = lxml.html.fromstring(response.content)
-        [form] = parsed.cssselect("form[method=POST]")
-        self.assertEqual(form.get("action"), f"/lists/{mylist.id}/")
+        forms = parsed.cssselect("form[method=POST]")
+        self.assertIn(url, [form.get("action") for form in forms])
+        [form] = [form for form in forms if form.get("action") == url]
         inputs = form.cssselect("input")
         self.assertIn("text", [input.get("name") for input in inputs])

----
====

It's pretty much the same edit,
except this time I decided to have a `url` variable,
to remove the duplication of using `/lists/{mylist.id}/` three times. That gets our unit tests passing again:

----
OK
----


If we try our FT again, we'll see it fails because the login form
doesn't send us to a real URL yet--you'll
see the `Not found:` message in the server output,
as well as the assertion reporting the content of the default 404 page:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test functional_tests.test_login*]
[...]
Not Found: /accounts/send_login_email
[...]
AssertionError: 'Check your email' not found in 'Not Found\nThe requested
resource was not found on this server.'
----

Time to start writing some Django code.
We begin, like in the spike, by creating an app called `accounts`
to hold all the files related to login:

[subs="specialcharacters,quotes"]
----
$ *cd src && python manage.py startapp accounts && cd ..*
$ *ls src/accounts*
__init__.py admin.py    apps.py     migrations  models.py   tests.py    views.py
----
//ch19l021

You could even do a commit just for that, to be able to distinguish the
placeholder app files from our modifications.
((("authentication", "de-spiking authentication code", startref="ix_authdes")))((("spiking and de-spiking", "de-spiking authentication code", startref="ix_spikdeauth")))


=== A Minimal Custom User Model

// IDEA: consider starting with a test for the login view instead.

((("user models", "minimum custom user model for authentication", id="ix_usrmdcus")))((("authentication", "minimal custom user model", id="SDminimal18")))
Let's turn to the models layer:footnote:[
In this chapter, we're building things in a "bottom-up" way,
starting with the models, and then building the layers on top—the views and templates that depend on them.
This is a common approach, but it's not the only one!
In <<chapter_24_outside_in>> we'll explore building software from the outside in,
which has all sorts of advantages too.]

[role="scratchpad"]
*****
* _Token model with email and UID_
* _View to create token and send login email incl. url w/ token UID_
* _Custom user model with USERNAME_FIELD=email_
* _Authentication backend with authenticate() and get_user() functions_
* _Registering auth backend in settings.py_
* _Login view calls authenticate() and login() from django.contrib.auth_
* _Logout view calls django.contrib.auth.logout_
*****

We know we have to build a token model and a custom user model,
and the user model was the messiest part in our spike.
So, let's have a go at redoing that test-first, to see if it comes out nicer.

Django's built-in user model makes all sorts of assumptions about
what information you want to track about users—from explicitly requiring a first name and last namefootnote:[
This is a decision that even some prominent Django maintainers
have said they now regret—not everyone has a first and last name.]
to forcing you to use a username.
I'm a great believer in not storing information about users
unless you absolutely must,
so a user model that records an email address and nothing else
sounds good to me!

Let's start straight away with a tests folder instead of _tests.py_
in this app:

[subs=""]
----
$ <strong>rm src/accounts/tests.py</strong>
$ <strong>mkdir src/accounts/tests</strong>
$ <strong>touch src/accounts/tests/__init__.py</strong>
----

And now, let's add a _test_models.py_ to say:


[role="sourcecode"]
.src/accounts/tests/test_models.py (ch19l023)
====
[source,python]
----
from django.test import TestCase

from accounts.models import User


class UserModelTest(TestCase):
    def test_user_is_valid_with_email_only(self):
        user = User(email="a@b.com")
        user.full_clean()  # should not raise
----
====


That gives us the expected failure:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test accounts*]
[...]
ImportError: cannot import name 'User' from 'accounts.models'
(...goat-book/src/accounts/models.py)
----


OK, let's try the absolute minimum then:


[role="sourcecode"]
.src/accounts/models.py (ch19l024)
====
[source,python]
----
from django.db import models


class User(models.Model):
    email = models.EmailField()
----
====

That gives us an error because Django won't recognise models
unless they're in `INSTALLED_APPS`:

[subs="specialcharacters,macros"]
----
RuntimeError: Model class accounts.models.User doesn't declare an explicit
app_label and isn't in an application in INSTALLED_APPS.
----

So, let's add it to _settings.py_:


[role="sourcecode"]
.src/superlists/settings.py (ch19l025)
====
[source,python]
----
INSTALLED_APPS = [
    # "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "accounts",
    "lists",
]

----
====


And that gets our tests passing!


----
OK
----

Now let's see if we've built a user model that Django can actually work with.
There's a built-in function in `django.contrib.auth` called `get_user_model()`—which retrieves the currently active user model and, as we'll see, also performs some checks on it.
Let's use it in our tests:



[role="sourcecode"]
.src/accounts/tests/test_models.py (ch19l026-1)
====
[source,python]
----
from django.contrib import auth
from django.test import TestCase

from accounts.models import User


class UserModelTest(TestCase):
    def test_model_is_configured_for_django_auth(self):
        self.assertEqual(auth.get_user_model(), User)

    def test_user_is_valid_with_email_only(self):
        [...]
----
====

That gives:

----
AssertionError: <class 'django.contrib.auth.models.User'> != <class
'accounts.models.User'>
----


OK, so let's try wiring up our model inside _settings.py_,
in a variable called `AUTH_USER_MODEL`:

[role="sourcecode"]
.src/superlists/settings.py (ch19l026-2)
====
[source,python]
----
AUTH_USER_MODEL = "accounts.User"
----
====


Now when we run our tests, Django complains
that our custom user model is missing a couple of bits of metadata.
In fact, it's so unhappy that it won't even run the tests:


[role="ignore-errors"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test accounts*]
Traceback (most recent call last):
[...]
  File ".../django/contrib/auth/checks.py", line 46, in check_user_model
    if not isinstance(cls.REQUIRED_FIELDS, (list, tuple)):
                      ^^^^^^^^^^^^^^^^^^^
AttributeError: type object 'User' has no attribute 'REQUIRED_FIELDS'
----


Sigh.  Come on, Django; it's only got one field,
so you should be able to figure out the answers to these questions for yourself.
Here you go:

[role="sourcecode"]
.src/accounts/models.py (ch19l027)
====
[source,python]
----
class User(models.Model):
    email = models.EmailField()

    REQUIRED_FIELDS = []
----
====

Next silly question?footnote:[
You might ask, if I think Django is so silly,
why don't I submit a pull request to fix it?
It should be quite a simple fix.
Well, I promise I will, as soon as I've finished updating the book.
For now, snarky comments will have to suffice.]

[subs="specialcharacters,macros"]
----
AttributeError: type object 'User' has no attribute 'USERNAME_FIELD'
----

We'll go through a few more of these, until we get to:

[role="sourcecode"]
.src/accounts/models.py (ch19l029)
====
[source,python]
----
class User(models.Model):
    email = models.EmailField()

    REQUIRED_FIELDS = []
    USERNAME_FIELD = "email"
    is_anonymous = False
    is_authenticated = True
----
====


And now we get a slightly different error:


[role="ignore-errors"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test accounts*]
[...]
SystemCheckError: System check identified some issues:

ERRORS:
accounts.User: (auth.E003) 'User.email' must be unique because it is named as
the 'USERNAME_FIELD'.
----

Well, the simple way to fix that would be like this:


[role="sourcecode"]
.src/accounts/models.py (ch19l030)
====
[source,python]
----
    email = models.EmailField(unique=True)
----
====

And now we get a different error again, slightly more familiar this time!
Django is a bit happier with the structure of our custom user model,
but it's unhappy about the database:

----
django.db.utils.OperationalError: no such table: accounts_user
----


In other words, we need to create a migration:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py makemigrations*]
Migrations for 'accounts':
  src/accounts/migrations/0001_initial.py
    + Create model User
----
//ch19l031


And our tests pass:

[subs="specialcharacters,quotes"]
----
$ *python src/manage.py test accounts*
[...]
Ran 2 tests in 0.001s
OK
----


But our model isn't quite as simple as it could be.
It has the email field, and also an autogenerated "ID" field as its primary key.
We could make it even simpler!
// DAVID: Maybe spell this out more clearly to the reader that there are actually two fields,
// they might not realise this.


==== Tests as Documentation


((("tests", "as documentation", secondary-sortas="documentation")))
((("documentation, tests as")))
Let's go all the way and make the email field the primary key,footnote:[
Emails may not be the perfect primary key in real life.
One reader—clearly deeply scarred—wrote me an emotional email about how much they've suffered for over a decade
from trying to deal with the consquences of using email as a primary key,
particularly how it makes multiuser account management nearly impossible.
So, as ever, YMMV.]
and thus implicitly remove the autogenerated `id` column. Although we could just _do it_ and our test would still pass,
and conceivably claim it was "just a refactor",
it would be better to have a specific test:

[role="sourcecode"]
.src/accounts/tests/test_models.py (ch19l032)
====
[source,python]
----
class UserModelTest(TestCase):
    def test_model_is_configured_for_django_auth(self):
        [...]
    def test_user_is_valid_with_email_only(self):
        [...]

    def test_email_is_primary_key(self):
        user = User(email="a@b.com")
        self.assertEqual(user.pk, "a@b.com")
----
====

It'll help us remember if we ever come back and look at the code again
in future:

----
    self.assertEqual(user.pk, "a@b.com")
AssertionError: None != 'a@b.com'
----

TIP: Your tests can be a form of documentation for your code--they
    express the requirements for a particular class or function.
    Sometimes, if you forget why you've done something a particular way,
    going back and looking at the tests will give you the answer.
    That's why it's important to make your tests readable,
    including giving them explicit, verbose method names.

Here's the implementation (`primary_key` makes the `unique=True` obsolete):

[role="sourcecode"]
.src/accounts/models.py (ch19l033)
====
[source,python]
----
    email = models.EmailField(primary_key=True)
----
====


And we mustn't forget to adjust our migrations:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*rm src/accounts/migrations/0001_initial.py*]
$ pass:quotes[*python src/manage.py makemigrations*]
Migrations for 'accounts':
  src/accounts/migrations/0001_initial.py
    + Create model User
----
//ch19l034

// DAVID: Deleting migrations can get readers in a pickle if they have already run migrations locally.
// Might be worth saying we're only doing this because we've just created it, and advise them to delete
// their database if they happen to have run the migration they've just deleted? (Or you can get them
// to run `migrate accounts zero` I think.)

((("user models", "minimum custom user model for authentication", startref="ix_usrmdcus")))((("", startref="SDminimal18")))
Now both our tests pass:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test accounts*]
[...]
Ran 3 tests in 0.001s
OK
----

It's probably a good time for a commit, too:

[subs="specialcharacters,quotes"]
----
$ *git add src/accounts*
$ *git commit -m "custom user model with email as primary key"*
----

And we can cross off one item from our de-spiking list.  Hooray!

[role="scratchpad"]
*****
* _Token model with email and UID_
* _View to create token and send login email incl. url w/ token UID_
* _[strikethrough line-through]#Custom user model with USERNAME_FIELD=email#_
* _Authentication backend with authenticate() and get_user() functions_
* _Registering auth backend in settings.py_
* _Login view calls authenticate() and login() from django.contrib.auth_
* _Logout view calls django.contrib.auth.logout_
*****


=== A Token Model to Link Emails with a Unique ID

((("emails", "token model linking with unique ID", id="ix_emltkn")))((("authentication", "token model to link emails", id="SDtoken18")))((("tokens", "token model linking emails and UID", id="ix_tknmod")))
Next let's build a token model.
Here's a short unit test that captures the essence--you
should be able to link an email to a unique ID,
and that ID shouldn't be the same twice in a row:

[role="sourcecode"]
.src/accounts/tests/test_models.py (ch19l035)
====
[source,python]
----
from accounts.models import Token, User
[...]


class TokenModelTest(TestCase):
    def test_links_user_with_auto_generated_uid(self):
        token1 = Token.objects.create(email="a@b.com")
        token2 = Token.objects.create(email="a@b.com")
        self.assertNotEqual(token1.uid, token2.uid)
----
====

I won't show every single listing for creating the token class in _models.py_;
I'll let you do that yourself instead.
Driving Django models with basic TDD
involves jumping through a few hoops because of the migration,
so you'll see a few iterations like this--minimal code change,
make migrations, get new error, delete migrations,
re-create new migrations, another code change, and so on...


[role="dofirst-ch19l036"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test accounts*]
[...]
TypeError: Token() got unexpected keyword arguments: 'email'
----

I'll trust you to go through these conscientiously--remember,
I may not be able to see you, but the Testing Goat can!

You might go through a hoop like this one, for example, where you find yourself needing to create and then delete a migration for an incomplete solution:

[role="dofirst-ch19l037"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py makemigrations*]
Migrations for 'accounts':
  src/accounts/migrations/0002_token.py
    + Create model Token
$ pass:quotes[*python src/manage.py test accounts*]
AttributeError: 'Token' object has no attribute 'uid'. Did you mean: 'id'?
$ pass:quotes[*rm src/accounts/migrations/0002_token.py*]
----


Eventually, you should get to this code...

[role="sourcecode dofirst-ch19l038-0"]
.src/accounts/models.py (ch19l038)
====
[source,python]
----
class Token(models.Model):
    email = models.EmailField()
    uid = models.CharField(max_length=40)
----
====
// DAVID: could it confuse people that the max_length is 40 here but 255 in the spike?

And this error:

[role="dofirst-ch19l039"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test accounts*]
[...]

    self.assertNotEqual(token1.uid, token2.uid)
AssertionError: '' == ''
----

And here we have to decide how to generate our random unique ID field.
We could use the `random` module, but Python actually comes with another module
specifically designed for generating unique IDs called "UUID"
(for "universally unique ID").
We can use it like this:

// DAVID: It feels like a strange time to introduce it, seeing as we've already used it in the spike earlier.

[role="sourcecode"]
.src/accounts/models.py (ch19l040)
====
[source,python]
----
import uuid
[...]

class Token(models.Model):
    email = models.EmailField()
    uid = models.CharField(default=uuid.uuid4, max_length=40)  # <1>
----
====

<1> The `default=` argument for a field can be either a static value
    or a callable that returns a value at the time the model is created.
    In our case, using a callable means
    we'll get a different unique ID for every model.


And, perhaps with a bit more wrangling of `makemigrations`...

[subs="specialcharacters,macros"]
----
$ pass:quotes[*rm src/accounts/migrations/0002_token.py*]
$ pass:quotes[*python src/manage.py makemigrations*]
Migrations for 'accounts':
  src/accounts/migrations/0002_token.py
    + Create model Token
----

...that should get us to passing tests:


[subs="specialcharacters,quotes"]
----
$ *python src/manage.py test accounts*
[...]
Ran 4 tests in 0.015s

OK
----


So, we are well on our way!

[role="scratchpad"]
*****
* _[strikethrough line-through]#Token model with email and UID#_
* _View to create token and send login email incl. url w/ token UID_
* _[strikethrough line-through]#Custom user model with USERNAME_FIELD=email#_
* _Authentication backend with authenticate() and get_user() functions_
* _Registering auth backend in settings.py_
* _Login view calls authenticate() and login() from django.contrib.auth_
* _Logout view calls django.contrib.auth.logout_
*****


The models layer is done, at least.
In the next chapter, we'll get into mocking—a key technique for testing external dependencies like email.((("tokens", "token model linking emails and UID", startref="ix_tknmod")))((("emails", "token model linking with unique ID", startref="ix_emltkn")))((("", startref="SDtoken18")))


[role="pagebreak-before"]
.Exploratory Coding, Spiking, and De-spiking
*******************************************************************************
Spiking::
    Spiking is exploratory coding to find out about a new API,
    or to explore the feasibility of a new solution.
    Spiking can be done without tests.
    It's a good idea to do your spike on a new branch,
    and go back to your main branch when de-spiking.
    ((("spiking and de-spiking", "defined")))


De-spiking::
    De-spiking means taking the work from a spike and making it part of the production codebase.
    The idea is to throw away the old spike code altogether,
    and start again from scratch, using TDD once again.
    De-spiked code can often come out looking quite different
    from the original spike, and usually much nicer.


Writing your FT against spiked code::
    Whether or not this is a good idea depends on your circumstances.
    The reason it can be useful is because it can help you write the FT
    correctly--figuring out how to test your spike
    can be just as challenging as the spike itself.
    On the other hand, it might constrain you to
    reimplementing a solution very similar to your spiked one;
    something to watch out for.
    ((("functional tests (FTs)", "spiked code and")))
    ((("", startref="AuthSpike18")))
*******************************************************************************
