[[chapter_08_prettification]]
== Prettification: Layout and Styling, [.keep-together]#and What to Test About It#

((("layout", see="CSS; design and layout testing")))
((("style", see="CSS; design and layout testing")))
We're starting to think about releasing the first version of our site,
but we're a bit embarrassed by how unfinished it looks at the moment.
In this chapter, we'll cover some of the basics of styling,
including integrating an HTML/CSS framework called Bootstrap.
We'll learn how static files work in Django,
and what we need to do about testing them.



=== Testing Layout and Style

((("design and layout testing", "selecting test targets", id="DLTtargets08")))
Our site is undeniably a bit unattractive at the moment
(<<homepage-looking-ugly>>).

NOTE: If you spin up your dev server with `manage.py runserver`,
    you may run into a database error, something like this:
    "OperationalError: no such table: lists_list".
    You need to update your local database
    to reflect the changes we made in 'models.py'.((("manage.py file", "migrate")))((("databases", "local dev database out of sync with migrations")))((("IntegrityErrors")))
    Use `manage.py migrate`.
    If it gives you any grief about `IntegrityErrors`,
    just delete the database file.footnote:[
    What? Delete the database?  Have you taken leave of your senses?  Not completely.
    The local dev database often gets out of sync with its migrations
    as we go back and forth in our development,
    and it doesn't have any important data in it,
    so it's OK to blow it away now and again.
    We'll be much more careful once we have a "production" database on the server.]

[role="pagebreak-before"]
We can't be going back to
https://oreil.ly/ruIZz[Python's historical reputation for being ugly],
so let's do a tiny bit of polishing.
Here are a few things we might want:

* A large input field for adding to new and existing lists
* A large, attention-grabbing, centered box to put it in

((("aesthetics, testing", seealso="design and layout testing")))
How do we apply TDD to these things?((("Test-Driven Development (TDD)", "testing behaviour of aesthetics")))
Most people will tell you that you shouldn't test aesthetics, and they're right.
It's a bit like testing a constant, in that tests usually wouldn't add any value.


[[homepage-looking-ugly]]
.Our home page, looking a little ugly...
image::images/tdd3_0801.png["Our home page, looking a little ugly."]


((("static files", "challenges of")))
((("CSS (Cascading Style Sheets)", "challenges of static files")))
But we can test the essential _behaviour_ of our aesthetics
(i.e., that we have any at all).
All we want to do is reassure ourselves that things are working.
For example, we're going to use Cascading Style Sheets (CSS) for our styling,
and they are loaded as static files.
Static files can be a bit tricky to configure
(especially, as we'll see later, when you move off your own computer and onto a server),
so we'll want some kind of simple "smoke test" that the CSS has loaded.
We don't have to test fonts and colours and every single pixel,
but we can do a quick check that the main input box is aligned the way we want it on each page,
and that will give us confidence that the rest of the styling for that page is probably loaded too.

[role="pagebreak-before"]
Let's add a new test method inside our functional test (FT):

[role="sourcecode"]
.functional_tests/tests.py (ch08l001)
====
[source,python]
----
class NewVisitorTest(LiveServerTestCase):
    [...]


    def test_layout_and_styling(self):
        # Edith goes to the home page,
        self.browser.get(self.live_server_url)

        # Her browser window is set to a very specific size
        self.browser.set_window_size(1024, 768)

        # She notices the input box is nicely centered
        inputbox = self.browser.find_element(By.ID, "id_new_item")
        self.assertAlmostEqual(
            inputbox.location["x"] + inputbox.size["width"] / 2,
            512,
            delta=10,
        )
----
====

A few new things here.
We start by setting the window size to a fixed size.
We then find the input element,
look at its size and location,
and do a little maths
to check whether it seems to be positioned in the middle of the page.
`assertAlmostEqual` helps us to deal with rounding errors
and the occasional weirdness due to scrollbars and the like,
by letting us specify that we want our arithmetic to work
to within 10 pixels, plus or minus.

If we run the FTs, we get:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests*]
[...]
.F.
======================================================================
FAIL: test_layout_and_styling
(functional_tests.tests.NewVisitorTest.test_layout_and_styling)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "...goat-book/functional_tests/tests.py", line 119, in
test_layout_and_styling
    self.assertAlmostEqual(
[...]
AssertionError: 102.5 != 512 within 10 delta (409.5 difference)

 ---------------------------------------------------------------------
Ran 3 tests in 9.188s

FAILED (failures=1)
----

That's the expected failure.
Still, this kind of FT is easy to get wrong,
so let's use a quick-and-dirty "cheat" solution,
to check that the FT definitely passes when the input box is centered.
We'll delete this code again almost as soon as we've used it
to check the FT:

[role="sourcecode small-code"]
.lists/templates/home.html (ch08l002)
====
[source,html]
----
<form method="POST" action="/lists/new">
  <p style="text-align: center;">
    <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
  </p>
  {% csrf_token %}
</form>
----
====

That passes, which means the FT works.
Let's extend it to make sure that the input box is also
center-aligned on the page for a new list:

[role="sourcecode"]
.functional_tests/tests.py (ch08l003)
====
[source,python]
----
    # She starts a new list and sees the input is nicely
    # centered there too
    inputbox.send_keys("testing")
    inputbox.send_keys(Keys.ENTER)
    self.wait_for_row_in_list_table("1: testing")
    inputbox = self.browser.find_element(By.ID, "id_new_item")
    self.assertAlmostEqual(
        inputbox.location["x"] + inputbox.size["width"] / 2,
        512,
        delta=10,
    )
----
====

That gives us another test failure:

----
  File "...goat-book/functional_tests/tests.py", line 131, in
test_layout_and_styling
    self.assertAlmostEqual(
AssertionError: 102.5 != 512 within 10 delta (409.5 difference)
----

Let's commit just the FT:

[subs="specialcharacters,quotes"]
----
$ *git add functional_tests/tests.py*
$ *git commit -m "first steps of FT for layout + styling"*
----

[role="pagebreak-before"]
Now it feels like we're justified in finding a "proper" solution
to improve the styling for our site.
We can back out our hacky `text-align: center`:


[subs="specialcharacters,quotes"]
----
$ *git reset --hard*
----


WARNING: `git reset --hard`
    is the "take off and nuke the site from orbit"
    Git command, so be careful with it--it
    blows away all your un-committed changes.
    Unlike almost everything else you can do with Git,
    there's no way of going back after this one.((("Git", "reset --hard")))((("", startref="DLTtargets08")))



=== Prettification: Using a CSS Framework

((("design and layout testing", "CSS frameworks", id="DLTcssframe08")))
((("CSS (Cascading Style Sheets)", "CSS frameworks", id="CSSframe08")))
((("Bootstrap", "downloading")))
UI design is hard,
and doubly so now that we have to deal with mobile, tablets, and so forth.
That's why many programmers, particularly lazy ones like me,
turn to CSS frameworks to solve some of those problems for them.
There are lots of frameworks out there,
but one of the earliest and most popular still, is Bootstrap.
Let's use that.

You can find Bootstrap at https://getbootstrap.com[getbootstrap.com].

We'll download it and put it in a new folder called _static_ inside the `lists`
app:footnote:[On Windows, you may not have `wget` and `unzip`,
but I'm sure you can figure out how to download Bootstrap,
unzip it, and put the contents of the _dist_ folder
into the _lists/static/bootstrap_ folder.]

[subs="specialcharacters,quotes"]
----
$ *wget -O bootstrap.zip https://github.com/twbs/bootstrap/releases/download/\
v5.3.5/bootstrap-5.3.5-dist.zip*
$ *unzip bootstrap.zip*
$ *mkdir lists/static*
$ *mv bootstrap-5.3.5-dist lists/static/bootstrap*
$ *rm bootstrap.zip*
----

Bootstrap comes with a plain, uncustomised installation in the 'dist' folder.
We're going to use that for now,
but you should really never do this for a real site--vanilla
Bootstrap is instantly recognisable,
and a big signal to anyone in the know
that you couldn't be bothered to style your site.
Learn how to use Sass and change the font, if nothing else!
There is info in Bootstrap's docs, or read an
https://www.freecodecamp.org/news/how-to-customize-bootstrap-with-sass[introductory guide].

[role="pagebreak-before"]
Our 'lists' folder will end up looking like this:

[subs="specialcharacters,macros"]
----
[...]
├── lists
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   ├── [...]
│   ├── models.py
│   ├── static
│   │   └── bootstrap
│   │       ├── css
│   │       │   ├── bootstrap-grid.css
│   │       │   ├── bootstrap-grid.css.map
│   │       │   ├── [...]
│   │       │   └── bootstrap.rtl.min.css.map
│   │       └── js
│   │           ├── bootstrap.bundle.js
│   │           ├── bootstrap.bundle.js.map
│   │           ├── [...]
│   │           └── bootstrap.min.js.map
│   ├── templates
│   │   ├── home.html
│   │   └── list.html
│   ├── tests.py
│   ├── urls.py
│   └── views.py
[...]
----


((("Bootstrap", "documentation")))
Look at the "Getting started" section of the
https://getbootstrap.com/docs/5.3/getting-started/introduction[Bootstrap documentation];
you'll see it wants our HTML template to include something like this:


[role="skipme"]
[source,html]
----
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Bootstrap demo</title>
  </head>
  <body>
    <h1>Hello, world!</h1>
  </body>
</html>

----

We already have two HTML templates.
We don't want to be adding a whole load of boilerplate code to each,
so now feels like the right time to apply
the "Don't repeat yourself" rule,
and bring all the common parts together.
Thankfully, the Django template language makes that easy using something
called template inheritance.
((("", startref="DLTcssframe08")))
((("", startref="CSSframe08")))





=== Django Template Inheritance

((("design and layout testing", "Django template inheritance")))
((("templates", "Django template inheritance")))
((("Django framework", "template inheritance")))
Let's have a little review of what the differences are between 'home.html' and
'list.html':

[subs="specialcharacters,macros"]
----
$ pass:quotes[*diff lists/templates/home.html lists/templates/list.html*]
<     <h1>Start a new To-Do list</h1>
<     <form method="POST" action="/lists/new">
---
>     <h1>Your To-Do list</h1>
>     <form method="POST" action="/lists/{{ list.id }}/add_item">
[...]
>     <table id="id_list_table">
>       {% for item in list.item_set.all %}
>         <tr><td>{{ forloop.counter }}: {{ item.text }}</td></tr>
>       {% endfor %}
>     </table>
----

They have different header texts, and their forms use different URLs. On top
of that, 'list.html' has the additional `<table>` element.

//IDEA add a note re downsides of inheritance?
Now that we're clear on what's in common and what's not, we can make the two
templates inherit from a common "superclass" template.  We'll start by
making a copy of 'list.html':

[subs="specialcharacters,quotes"]
----
$ *cp lists/templates/list.html lists/templates/base.html*
----
//006

We make this into a base template, which just contains the common boilerplate,
and mark out the "blocks", places where child templates can customise it:

[role="sourcecode small-code"]
.lists/templates/base.html (ch08l007)
====
[source,html]
----
<html>
  <head>
    <title>To-Do lists</title>
  </head>

  <body>
    <h1>{% block header_text %}{% endblock %}</h1>

    <form method="POST" action="{% block form_action %}{% endblock %}">
      <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
      {% csrf_token %}
    </form>

    {% block table %}
    {% endblock %}
  </body>

</html>
----
====

[role="pagebreak-before"]
Let's see how these blocks are used in practice,
by changing 'home.html' so that it "inherits" from 'base.html':

[role="sourcecode"]
.lists/templates/home.html (ch08l008)
====
[source,html]
----
{% extends 'base.html' %}

{% block header_text %}Start a new To-Do list{% endblock %}

{% block form_action %}/lists/new{% endblock %}
----
====

You can see that lots of the boilerplate HTML disappears,
and we just concentrate on the bits we want to customise.
We do the same for 'list.html':

[role="sourcecode"]
.lists/templates/list.html (ch08l009)
====
[source,html]
----
{% extends 'base.html' %}

{% block header_text %}Your To-Do list{% endblock %}

{% block form_action %}/lists/{{ list.id }}/add_item{% endblock %}

{% block table %}
  <table id="id_list_table">
    {% for item in list.item_set.all %}
      <tr><td>{{ forloop.counter }}: {{ item.text }}</td></tr>
    {% endfor %}
  </table>
{% endblock %}
----
====


That's a refactor of the way our templates work.
We rerun the FTs to make sure we haven't broken anything:

----
AssertionError: 102.5 != 512 within 10 delta (409.5 difference)
----

Sure enough, they're still getting to exactly where they were before.


That's worthy of a commit:
((("Git", "diff -w")))

[subs="specialcharacters,quotes"]
----
$ *git diff -w*
# the -w means ignore whitespace, useful since we've changed some html indenting
$ *git status*
$ *git add lists/templates* # leave static, for now
$ *git commit -m "refactor templates to use a base template"*
----


=== Integrating Bootstrap

((("design and layout testing", "Bootstrap integration")))
((("Bootstrap", "integrating")))
Now it's much easier to integrate the boilerplate code that Bootstrap wants--we
won't add the JavaScript yet, just the CSS:

[role="sourcecode"]
.lists/templates/base.html (ch08l010)
====
[source,html]
----
<!doctype html>
<html lang="en">

  <head>
    <title>To-Do lists</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="css/bootstrap.min.css" rel="stylesheet">
  </head>
[...]
----
====


==== Rows and Columns

Finally, let's actually use some of the Bootstrap magic!
You'll have to read the documentation yourself,
but we should be able to use a combination
of the grid system and the `justify-content-center` class to get what we want:

[role="sourcecode"]
.lists/templates/base.html (ch08l011)
====
[source,html]
----
  <body>
    <div class="container">

      <div class="row justify-content-center">
        <div class="col-lg-6 text-center">
          <h1>{% block header_text %}{% endblock %}</h1>

          <form method="POST" action="{% block form_action %}{% endblock %}">
            <input
              name="item_text"
              id="id_new_item"
              placeholder="Enter a to-do item"
            />
            {% csrf_token %}
          </form>
        </div>
      </div>

      <div class="row justify-content-center">
        <div class="col-lg-6">
          {% block table %}
          {% endblock %}
        </div>
      </div>

    </div>
  </body>
----
====

(If you've never seen an HTML tag broken up over several lines,
that `<input>` may be a little shocking.
It is definitely valid,
but you don't have to use it if you find it offensive.)

TIP: Take the time to browse through the
    https://getbootstrap.com/docs/5.3/getting-started/introduction/[Bootstrap documentation],
    if you've never seen it before.
    It's a shopping trolley brimming full of useful tools
    to use in your site.

Does that work?  Whoops—no, we have an error in our unit tests:

----
FAIL: test_renders_input_form
(lists.tests.ListViewTest.test_renders_input_form)
[...]
AssertionError: False is not true : Couldn't find '<input name="item_text"' in
the following response
[...]
----

Ah, it's because our unit tests are currently a little
brittle with respect to whitespace changes in our `<input>` tag,
which actually don't matter semantically.

Django does provide the `html=True` argument to `assertContains()`,
which does help a bit, but it requires exhaustively
specifying every attribute of the element we want to check on,
like this:

[role="sourcecode small-code"]
.lists/tests.py (ch08l011-1)
====
[source,python]
----
class HomePageTest(TestCase):
    def test_uses_home_template(self):
        [...]

    def test_renders_input_form(self):
        response = self.client.get("/")
        self.assertContains(response, '<form method="POST" action="/lists/new">')
        self.assertContains(
            response,
            '<input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />',
            html=True,
        )
[...]


class ListViewTest(TestCase):
    def test_uses_list_template(self):
        [...]

    def test_renders_input_form(self):
        mylist = List.objects.create()
        response = self.client.get(f"/lists/{mylist.id}/")
        self.assertContains(
            response,
            f'<form method="POST" action="/lists/{mylist.id}/add_item">',
        )
        self.assertContains(
            response,
            '<input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />',
            html=True,
        )
----
====

That's not entirely satisfactory,
because all those extra attributes like `id` and `placeholder`
aren't really things we want to nail down in unit tests;
we'd rather have the freedom to change them in the template
without needing to change the tests as well.
They're more of a presentation concern than a true part of the contract
between backend and frontend.

But it does get the tests to pass:

----
OK
----

[role="pagebreak-before"]
So, for now, let's make a note to come back to it:

[role="scratchpad"]
*****
* _Find a better way to unit test form &amp; input elements._
*****


So, the unit tests are happy. What about the FTs?

----
AssertionError: 102.5 != 512 within 10 delta (409.5 difference)
----

Hmm. No.  Why isn't our CSS loading?
If you try it manually with `runserver` and look around in DevTools,
you'll see the browser 404ing when it tries to fetch _bootstrap.min.css_.
If you watch the `runserver` terminal session, you'll also see the 404s there,
as in <<bootstrap_css_404_devtools>>.

[[bootstrap_css_404_devtools]]
.That's a nope on bootstrap.css
image::images/tdd3_0802.png["Browser DevTools showing a 404 for css/bootstrap.min.css, but also at the bottom of the screenshot, the terminal window showing the same URL returing a 404 in the runserver session."]

To figure out what's happening,
let's talk a bit about how Django deals with static files.

[role="pagebreak-before less_space"]
=== Static Files in Django

((("Django framework", "static files in", id="DJFstatic08")))
Django, and indeed any web server,
needs to know two things to deal with static files:

1. How to tell when a URL request is for a static file,
   as opposed to for some HTML
   that's going to be served via a view function
2. Where to find the static file that the user wants

In other words, static files ((("URL mappings", "for static files", secondary-sortas="static")))are a mapping from URLs to files on disk.

((("static files", "URL requests for")))
For item 1, Django lets us define a URL "prefix"
to say that any URLs that start with that prefix
should be treated as requests for static files.
By default, the prefix is [keep-together]#'/static/'#.
It's already defined in _settings.py_:

[role="sourcecode currentcontents"]
.superlists/settings.py
====
[source,python]
----
[...]

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = "static/"
----
====

((("static files", "finding")))
The rest of the settings that we will add to this section
all have to do with item 2:
finding the actual static files on disk.

While we're using the Django development server (`manage.py runserver`),
we can rely on Django to magically find static files for us--it'll
just look in any subfolder of one of our apps called _static_.

You now see why we put all the Bootstrap static files into _lists/static_.
So, why are they not working at the moment?
It's because we're not using the `/static/` URL prefix.
Have another look at the link to the CSS in _base.html_:

[role="sourcecode currentcontents"]
.lists/templates/base.html
[source,html]
----
    <link href="css/bootstrap.min.css" rel="stylesheet">
----

That `href` is just what happened to be in the Bootstrap docs.
To get it to work, we need to change it to:


[role="sourcecode small-code"]
.lists/templates/base.html (ch08l012)
====
[source,html]
----
    <link href="/static/bootstrap/css/bootstrap.min.css" rel="stylesheet">
----
====

// DAVID: Django best practice would be to use the static tag instead.
// https://docs.djangoproject.com/en/5.2/howto/static-files/#configuring-static-files

Now when `runserver` sees the request,
it knows that it's for a static file because it begins with `/static/`.
It then tries to find a file called _bootstrap/css/bootstrap.min.css_,
looking in each of our app folders for subfolders called _static_,
and it should find it at _lists/static/bootstrap/css/bootstrap.min.css_.

So if you take a look manually, you should see it works,
as in <<list-page-centered>>.


[[list-page-centered]]
.Our site starts to look a little better...
image::images/tdd3_0803.png["The list page with centered header."]



==== Switching to StaticLiveServerTestCase


((("StaticLiveServerTestCase")))
If you run the FT though, annoyingly, it still won't pass:

----
AssertionError: 102.5 != 512 within 10 delta (409.5 difference)
----

That's because, although `runserver` automagically finds static files,
+Live&#x2060;S&#x2060;e&#x2060;r&#x2060;v&#x2060;e&#x2060;r&#x200b;T&#x2060;e&#x2060;s&#x2060;t&#x2060;Case+ doesn't.
Never fear, though:
the Django developers have made an even more magical test class
called `StaticLiveServerTestCase`
(see https://oreil.ly/mh-iO[the docs]).

// JAN: Maybe you could mention that StaticLiveServerTestCase inherits from LiveServerTestCase - so all previous should work + static files. After reading the name, I imagined StaticLiveServerTestCase as some special test class for testing only static-related stuff

Let's switch to that:

[role="sourcecode"]
.functional_tests/tests.py (ch08l013)
====
[source,diff]
----
@@ -1,14 +1,14 @@
-from django.test import LiveServerTestCase
+from django.contrib.staticfiles.testing import StaticLiveServerTestCase
 from selenium import webdriver
 from selenium.common.exceptions import WebDriverException
 from selenium.webdriver.common.keys import Keys
 import time

 MAX_WAIT = 10


-class NewVisitorTest(LiveServerTestCase):
+class NewVisitorTest(StaticLiveServerTestCase):

     def setUp(self):
----
====
//008

[role="pagebreak-before"]
And now it will find the new CSS, which will get our test to pass:
((("", startref="DJFstatic08")))


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests*]
Creating test database for alias 'default'...
...
 ---------------------------------------------------------------------
Ran 3 tests in 9.764s
----

// (David): Incidentally, when I ran this the first time I got this error
// on the second test case. selenium.common.exceptions.NoSuchElementException:
// Message: Unable to locate element: [id="id_new_item"];
// I ran it again and it worked.

Hooray!


=== Using Bootstrap Components to Improve the Look of the Site

((("design and layout testing", "Bootstrap tools")))Let's
see if we can do even better, using some of the other tools in
Bootstrap's panoply.((("Bootstrap", "using components of to improve looks of site", id="ix_Bootuse")))


==== Jumbotron!

The first version of Bootstrap used to ship with a class called `jumbotron`
for things that are meant to be particularly prominent on the page.
It doesn't exist anymore, but old-timers like me still pine for it,
so they have a specific page in the docs that tells you how to re-create it.((("jumbotron (Bootstrap)")))

Essentially, we massively embiggen the main page header and the input form,
putting it into a grey box with nice rounded corners:

[role="sourcecode"]
.lists/templates/base.html (ch08l014)
====
[source,html]
----
  <body>
    <div class="container">

      <div class="row justify-content-center p-5 bg-body-tertiary rounded-3">
        <div class="col-lg-6 text-center">
          <h1 class="display-1 mb-4">{% block header_text %}{% endblock %}</h1>
          [...]
----
====

That ends up looking something like <<jumbotron-header>>.

[[jumbotron-header]]
.A big grey box at the top of the page
image::images/tdd3_0804.png["The home page with a big grey box surrounding the title and input"]


TIP: When hacking about with design and layout,
    it's best to have a window open that we can refresh frequently.
    Use `python manage.py runserver` to spin up the dev server,
    and then browse to __http://localhost:8000__
    to see your work as we go.

// JAN: You could mention force refresh here (Cmd + Shift + R; Ctrl + F5, ...). It comes handy many times when working with CSS etc.


==== Large Inputs


((("Bootstrap", "large inputs")))
((("form control classes (Bootstrap)")))
The `jumbotron` is a good start,
but now the input box has tiny text compared to everything else.
Thankfully, Bootstrap's form control classes offer an option
to set an input to "large":


[role="sourcecode"]
.lists/templates/base.html (ch08l015)
====
[source,html]
----
    <input
      class="form-control form-control-lg"
      name="item_text"
      id="id_new_item"
      placeholder="Enter a to-do item"
    />
----
====


==== Table Styling


((("Bootstrap", "table styling")))
((("table styling (Bootstrap)")))
The table text also looks too small compared to the rest of the page now.
Adding the Bootstrap `table` class improves things, over in _list.html_:


[role="sourcecode"]
.lists/templates/list.html (ch08l016)
====
[source,html]
----
  <table class="table" id="id_list_table">
----
====

==== Optional: Dark Mode

In contrast to my greybeard nostalgia for `jumbotron`,
here's something relatively new to Bootstrap: dark mode!((("dark mode (Bootstrap)")))((("Bootstrap", "dark mode")))


[role="sourcecode"]
.lists/templates/base.html (ch08l017)
====
[source,html]
----
<!doctype html>
<html lang="en" data-bs-theme="dark">
----
====

Take a look at <<dark-modeee>>.
I think that looks great!

[[dark-modeee]]
.Dark modeeeeeeeeee
image::images/tdd3_0805.png["Screenshot of lists page in dark mode. Cool."]


But it's very much a matter of personal preference,
and my editor will have kittens
if I make all the rest of my screenshots use so much ink,
so I'm going to revert it for now.
You're free to keep dark mode on if you like!

[role="pagebreak-before less_space"]
==== A Semi-Decent Page

Getting it into shape took me a few goes, but I'm reasonably happy with it now
(<<homepage-looking-better>>).

[[homepage-looking-better]]
.The lists page, looking...good enough for now
image::images/tdd3_0806.png["Screenshot of lists page in light mode with decent styling."]

If you want to go further with customising Bootstrap,
you need to get into compiling Sass.((("Sass/SCSS")))
I've said it already, but I _definitely_ recommend
taking the time to do that someday.
Sass/SCSS is a great improvement on plain old CSS,
and a useful tool even if you don't use Bootstrap.((("CSS (Cascading Style Sheets)", "Sass/SCSS improvement on")))


A last run of the FTs, to see if everything still works OK:

[role="dofirst-ch08l018"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests*]
[...]
...
 ---------------------------------------------------------------------
Ran 3 tests in 10.084s

OK
----


That's it! Definitely time for a commit:


[subs="specialcharacters,quotes"]
----
$ *git status* # changes tests.py, base.html, list.html, settings.py,
            # and untracked lists/static
$ *git add .*
$ *git status* # will now show all the bootstrap additions
$ *git commit -m "Use Bootstrap to improve layout"*
----


=== Parsing HTML for Less Brittle Tests of Key HTML Content

Oh whoops, we nearly forgot our scratchpad:

[role="scratchpad"]
*****
* _Find a better way to unit test form &amp; input elements._
*****


When working on layout and styling, you expect to spend most of your time
in the browser, in a cycle of tweaking your HTML and refreshing to see
the effects, with occasional runs of your layout FT, if you have one.((("HTML", "parsing for less brittle tests of content")))

You wouldn't expect to test-drive design with unit tests.
And sure enough, we haven't run them in a while.
Because if we had done, we'd have noticed that they're failing:

----
FAIL: test_renders_input_form
(lists.tests.HomePageTest.test_renders_input_form)
[...]
AssertionError: False is not true : Couldn't find '<input name="item_text"
id="id_new_item" placeholder="Enter a to-do item" />' in the following response
b'<!doctype html>\n<html lang="en">\n\n  <head>\n    <title>To-Do
[...]
<input\n              class="form-control form-control-lg"\n
name="item_text"\n              id="id_new_item"\n
placeholder="Enter a to-do item"\n            />\n            <input
[...]
FAIL: test_renders_input_form
(lists.tests.ListViewTest.test_renders_input_form)
[...]
----

It's also annoyingly hard to see from the tests output,
but it happened when we introduced the `class=form-control form-control-lg`.

We really don't want this sort of thing breaking our unit tests.
Using string matching, even whitespace-aware string matching,
is just the wrong tool for the job.footnote:[
As famously explained in a
https://oreil.ly/N-cIc[classic Stack Overflow post].]
Let's switch to using a proper HTML parser, the venerable
https://lxml.de[lxml].


[subs=""]
----
$ <strong>pip install 'lxml[cssselect]'</strong>
Collecting lxml[cssselect]
  [...]
Collecting cssselect>=0.7 (from lxml[cssselect])
  [...]
Installing collected packages: lxml, cssselect
Successfully installed [...]
----

(We need the `cssselect` add-on for the nice CSS selectors.)((("lxml parser")))

And here's how we use it to write a more focused version of our test
that only cares about the two HTML attributes that actually matter
to the integration of frontend and backend:

1. The `<form>` tag's `method` and `action`
2. The `<input>` tag's `name`


[role="sourcecode"]
.lists/tests.py (ch08l019)
====
[source,python]
----
import lxml.html
[...]


class HomePageTest(TestCase):
    def test_uses_home_template(self):
        [...]

    def test_renders_input_form(self):
        response = self.client.get("/")
        parsed = lxml.html.fromstring(response.content)  # <1>
        [form] = parsed.cssselect("form[method=POST]")  # <2><3>
        self.assertEqual(form.get("action"), "/lists/new")
        [input] = form.cssselect("input[name=item_text]")  # <4>
----
====

<1> Here's where we parse the HTML into a structured object
    to represent the DOM (document object model).

<2> Here's where we use a CSS selector to find our form,
    implicitly also checking that it has `method="POST"`.
    The `cssselect()` method returns a list of matching elements.

<3> The `[form] =` is worth a mention.
    What we're using here is a special assignment syntax called "unpacking",
    where the lefthand side is a list of variable names
    and the righthand side is a list of values.((("unpacking")))((("tuple unpacking and multiple assignment")))
    It's a bit like saying `form = parsed.cssselect("form[method=POST]")[0]`,
    but a bit nicer to read, and a bit more strict too.
    By only putting one element on the left,
    we're effectively asserting that there is exactly one element on the right;
    if there isn't, we'll get an error.footnote:[
    Read more about tuple unpacking and multiple assignment
    https://oreil.ly/LMfuB[on Trey Hunner's excellent blog].]

<4> We use the same kind of assignment to assert that the form contains
    exactly one input element with the name `item_text`.
    


Here's the same thing in `ListViewTest`:

[role="sourcecode"]
.lists/tests.py (ch08l020)
====
[source,python]
----
class ListViewTest(TestCase):
    def test_uses_list_template(self):
        [...]

    def test_renders_input_form(self):
        mylist = List.objects.create()
        response = self.client.get(f"/lists/{mylist.id}/")
        parsed = lxml.html.fromstring(response.content)
        [form] = parsed.cssselect("form[method=POST]")
        self.assertEqual(form.get("action"), f"/lists/{mylist.id}/add_item")
        [input] = form.cssselect("input[name=item_text]")
----
====

That works!


----
Ran 10 tests in 0.017s

OK
----

And as always, for any test you've only ever seen green,
it's nice to introduce a deliberate failure:


[role="sourcecode"]
.lists/templates/base.html (ch08l021)
====
[source,python]
----
@@ -18,7 +18,7 @@
           <form method="POST" action="{% block form_action %}{% endblock %}">
             <input
               class="form-control form-control-lg"
-              name="item_text"
+              name="geoff"
               id="id_new_item"
               placeholder="Enter a to-do item"
             />
----
====

[role="pagebreak-before"]
And let's see the error message:

----
    [input] = form.cssselect("input[name=item_text]")
    ^^^^^^^
ValueError: not enough values to unpack (expected 1, got 0)
----


Hmm you know what?  I'm actually not happy with that.
The `[input] =` syntax is probably another example of
me being too clever for my own good.

Let's try something else that will give us a clearer message about
what _is_ on the page and what isn't:


[role="sourcecode"]
.lists/tests.py (ch08l022)
====
[source,python]
----
        inputs = form.cssselect("input")  # <1>
        self.assertIn("item_text", [input.get("name") for input in inputs])  # <2>
----
====

<1> We'll get a list of all the inputs in the form.
<2> And then we'll assert that at least one of them has the right `name=`.

That gives us a more self-explanatory message:

----
    self.assertIn("item_text", [input.get("name") for input in inputs])
    ~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AssertionError: 'item_text' not found in ['geoff', 'csrfmiddlewaretoken']
----

Now I feel good about changing our HTML back:


[role="sourcecode"]
.lists/templates/base.html (ch08l023)
====
[source,diff]
----
@@ -18,7 +18,7 @@
           <form method="POST" action="{% block form_action %}{% endblock %}">
             <input
               class="form-control form-control-lg"
-              name="geoff"
+              name="item_text"
               id="id_new_item"
               placeholder="Enter a to-do item"
             />
----
====

Much better!

[subs="specialcharacters,quotes"]
----
$ *git diff* # tests.py
$ *git commit -am "use lxml for more specific unit test asserts on html content"*
----



[role="pagebreak-before less_space"]
=== What We Glossed Over: collectstatic and Other Static Directories

((("design and layout testing", "collecting static files for deployment", id="DLTcollect08")))
((("static files", "collecting for deployment", id="SFcollect08")))
((("collectstatic command", id="collect08")))
We saw earlier that the Django dev server will magically find all your static files
inside app folders, and serve them for you.
That's fine during development,
but when you're running on a real web server,
you don't want Django serving your static content--using Python
to serve raw files is slow and inefficient,
and a web server like Apache or nginx can do this all for you.

For these reasons, you want to be able to gather all your static files
from inside their various app folders
and copy them into a single location, ready for deployment.
This is what the `collectstatic` command is for.

The destination, the place where the collected static files go,
needs to be defined in _settings.py_ as `STATIC_ROOT`.
In the next chapter, we'll be doing some deployment,
so let's actually experiment with that now.
A common and straightforward place to put it
is in a folder called "static" in the root of our repo:

[role="skipme"]
----
.
├── db.sqlite3
├── functional_tests/
├── lists/
├── manage.py
├── static/
└── superlists/
----

Here's a neat way of specifying that folder,
making it relative to the location of the project base directory:

[role="sourcecode"]
.superlists/settings.py (ch08l024)
====
[source,python]
----
# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = "static/"
STATIC_ROOT = BASE_DIR / "static"
----
====


Take a look at the top of the settings file,
and you'll see how that `BASE_DIR` variable is helpfully defined for us,
using `pathlib.Path` and `__file__`
(both really nice Python built-ins).footnote:[
Notice in the `Pathlib` wrangling of `__file__`
that the `.resolve()` happens before anything else.
Always follow this pattern when working with `__file__`,
otherwise you can see unpredictable behaviours
depending on how the file is imported.
Thanks to https://github.com/CleanCut/green[Green Nathan]
for that tip!]

[role="pagebreak-before"]
Anyway, let's try running `collectstatic`:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py collectstatic*]

171 static files copied to '...goat-book/static'.
----

And if we look in './static', we'll find all our CSS files:

[subs="specialcharacters,quotes"]
----
$ *tree static/*
static/
├── admin
│   ├── css
│   │   ├── autocomplete.css
│   │   ├── [...]
[...]
│               └── xregexp.min.js
└── bootstrap
    ├── css
    │   ├── bootstrap-grid.css
    │   ├── [...]
    │   └── bootstrap.rtl.min.css.map
    └── js
        ├── bootstrap.bundle.js
        ├── [...]
        └── bootstrap.min.js.map

17 directories, 171 files
----

`collectstatic` has also picked up all the CSS for the admin site.
The admin site is one of Django's powerful features,
but we don't need it for our simple site, so let's disable it for now:

[role="sourcecode"]
.superlists/settings.py (ch08l025)
====
[source,python]
----
INSTALLED_APPS = [
    # "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "lists",
]
----
====

And we try again:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*rm -rf static/*]
$ pass:quotes[*python manage.py collectstatic*]

44 static files copied to '...goat-book/static'.
----


Much better.


Now we know how to collect all the static files into a single folder,
where it's easy for a web server to find them.
We'll find out all about that, including how to test it, in the next chapter!


((("", startref="DLTcollect08")))
((("", startref="SFcollect08")))
((("", startref="collect08")))
For now, let's save our changes to _settings.py_.
We'll also add the top-level static folder to our `gitignore`,
because it will only contain copies of files
we actually keep in individual apps' static folders:


[subs="specialcharacters,quotes"]
----
$ *git diff* # should show changes in settings.py
$ *echo /static >> .gitignore*
$ *git commit -am "set STATIC_ROOT in settings and disable admin"*
----


=== A Few Things That Didn't Make It

Inevitably this was only a whirlwind tour of styling and CSS,
and there were several topics that I'd considered covering that didn't make it.
Here are a few candidates for further study:

* The `{% static %}` template tag, for more DRY and fewer hardcoded URLs
* Client-side packaging tools, like `npm` and `bower`
* Customising Bootstrap with Sass

//RITA: Would you want to point readers to any resources, such as a website or another book for example? You don't have to.


.Recap: On Testing Design and Layout
*******************************************************************************

((("design and layout testing", "best practices for")))
The tl;dr is: you shouldn't write tests for design and layout per se.
It's too much like testing a constant,
and the tests you write are often brittle.

With that said,
the _implementation_ of design and layout involves something quite tricky:
CSS and static files.
As a result, it is valuable to have some kind of minimal "smoke test"
that checks that your static files and CSS are working.
As we'll see in the next chapter, it can help pick up problems
when you deploy your code to production.

Similarly, if a particular piece of styling required a lot of client-side JavaScript code
to get it to work
(dynamic resizing is one I've spent a bit of time on),
you'll definitely want some tests for that
(see <<chapter_17_javascript>>).

Try to write the minimal tests that will give you the confidence
that your design and layout is working,
without testing _what_ it actually is.
That includes unit tests!
Avoid asserting on the cosmetic aspects of your HTML in your unit tests.

Aim to leave yourself in a position
where you can freely make changes to the design and layout,
without having to go back and adjust tests all the time.

*******************************************************************************
