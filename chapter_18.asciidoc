Finishing "my lists": Outside-In TDD
------------------------------------

In this chapter I'd like to talk about a technique called "outside-in" TDD.
It's pretty much what we've been doing all along. Our "double-loop" TDD
process, in which we write the functional test first and then the unit tests,
is already a manifestation of outside-in - we design the system from the
outside, and build up our code in layers. Now I'll make it explicit, and talk
about some of the common issues involved.

What do we mean by "Outside-in"?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By "outside-in", I mean that the TDD process which we've been following
generally forces us to tackle things in a certain order. Specifically, when we
add a functional test which, for example, hits a new URL, then the first failure
such a test will encounters will be in the very outermost layer of our
application - missing url routing. When we fix that, subsequent failures will
be in the views and templates. As we implement the feature in response to these
failures, our work progresses through deeper and deeper layers of our
application - until we end up down in the business logic and database access.
The process of TDD, of deciding what to implement next based on the our
functional test's current failure, leads us to work on our application code
from the outside in.

The alternative - "Inside out"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The alternative is to work "inside out". This is perhaps the way people are
generally most used to working before they encounter TDD. After coming up with
a design, one's natural inclination is sometimes to implement it starting with
the innermost, lowest-level components first.

For example, when faced with our current problem, of providing users with a
"My Lists" page, listing all their saved lists, an inside-out approach might
immediately begin by adding an "owner" attribute to the List model object,
reasoning that an attribute like this is "obviously" going to be required.
After that was in place, we would modify the more peripheral layers of code,
such a views and templates, that might use the new attribute, and then finally
add URL routing to point to the new view.

This has intuitive appeal, because it means you're never working on a bit
of code which is dependent on something which haven't yet been implemented.
Each bit of work is a solid foundation, in that sense, upon which to build
subsequent layers.

However, working inside-out like this also has some weaknesses, which is why
we're evangalising the TDD "outside-in" style instead.

Why prefer "outside-in"?
~~~~~~~~~~~~~~~~~~~~~~~~

The most obvious problem with inside-out is that it requires us to stray
from a TDD workflow. Our functional test might be immediately failing on
missing URL routing, but we decide to ignore that and go off adding attributes
to our database model objects instead.

This discontinuity can, at times, cause problems. We might have
ideas in our head about the new desired behaviour of our inner layers like
database models, and often these ideas will be pretty good. But they are a
kind of speculation about what's actually required, because we haven't yet
built the outer layers that will use them.

One problem that can result is to build inner components that are more
general or more capable than we actually need, which is a waste of time,
and an added source of complexity for your project. Another is to create inner
components with an API which is convenient for their own internal design, but
which later turns out to be innappropriate for the calls your outer layers
would like to make. A third is to create inner components that, you later
realise, don't actually solve the problem that your outer layers need solved.

This all contrasts with the continuous thread with which outside-in
leads our thoughts, from specification, through outermost functional test, and
then from one part of our implementation to another. Each step along the way
produces outputs (e.g. test failures) that directly inform what we need to
do in the next step. Because of this, I believe that outside-in empowers me to
tackle larger, or more complex, problems than I otherwise would be able to
bite off without blowing my stack.

Outside-in allows you to write your outer layers of code in a style that is
convenient and natural, for the code you are calling doesn't exist yet, so you
can make up an API that is convenient for your purpose. Your inner layers will
subsequently have to provide this API - their specification has been created by
some real-world usage. This is the natural order of things - your inner layers
only exist to perform services for your outer layers, and should be subordinate
to them in design and in purpose.

The FT for "My Lists"
~~~~~~~~~~~~~~~~~~~~~

As we work through the following functional test, I'll point out how we start
with the most outward-facing (presentation layer), through to the view
functions (or "controllers"), and lastly the innermost layers, which in this
case will be model code.

We know our `create_pre_authenticated_session` code works now, so we can just
write our FT to look for a "My Lists" page:


[role="sourcecode"]
.functional_tests/test_my_lists.py
[source,python]
----
    def test_logged_in_users_lists_are_saved_as_my_lists(self):
        # Edith is a logged-in user
        self.create_pre_authenticated_session(email='edith@email.com')

        # She goes to the home page and starts a list
        self.browser.get(self.server_url)
        self.get_item_input_box().send_keys('Reticulate splines\n')
        self.get_item_input_box().send_keys('Immanentize eschaton\n')
        first_list_url = self.browser.current_url

        # She notices a "My lists" link, for the first time.
        self.browser.find_element_by_link_text('My lists').click()

        # She sees that her list is in there, named according to its
        # first list item
        self.browser.find_element_by_link_text('Reticulate splines').click()
        self.assertEqual(self.browser.current_url, first_list_url)

        # She decides to start another list, just to see
        self.browser.get(self.server_url)
        self.get_item_input_box().send_keys('Click cows\n')
        second_list_url = self.browser.current_url

        # Under "my lists", her new list appears
        self.browser.find_element_by_link_text('My lists').click()
        self.browser.find_element_by_link_text('Click cows').click()
        self.assertEqual(self.browser.current_url, second_list_url)

        # She logs out.  The "My lists" option disappears
        self.browser.find_element_by_id('id_logout').click()
        self.assertEqual(
            self.browser.find_elements_by_link_text('My lists'),
            []
        )
----

If you run it, the first error should look like this:

----
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"link text","selector":"My lists"}' ; Stacktrace: 
----


The outside layer: presentation & templates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The test is currently failing saying that it can't find a link saying "My
Lists". We can address that at the presentation layer, in 'base.html', in
our navigation bar. Here's the minimal code change:

[role="sourcecode"]
.lists/templates/base.html (ch18l002-1)
[source,html]
----
{% if user.email %}
    <ul class="nav navbar-nav">
        <li><a href="#">My lists</a></li>
    </ul>
    <a class="btn navbar-btn navbar-right" id="id_logout" href="{% url 'logout' %}">Log out</a>
[...]
----

Of course, that link doesn't actually go anywhere, but it does get us along to
the next failure:

----
    self.browser.find_element_by_link_text('Reticulate splines').click()
[...]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"link text","selector":"Reticulate splines"}' ; Stacktrace:
----

Which is telling us we're going to have to build a page that lists all of a
user's lists by title.  Let's start with the basics -- a URL and a placeholder
template for it.

Again, we can go outside-in, starting at the presentation layer with just the 
URL and nothing else:


[role="sourcecode"]
.lists/templates/base.html (ch18l002-2)
[source,html]
----
    <ul class="nav navbar-nav">
        <li><a href="{% url 'my_lists' user.email %}">My lists</a></li>
    </ul>
----


Moving down one layer to view functions (the controller)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

That will cause a template error, so we can move in one step, from the
presentation layer down to the controller layer, Django's view functions.

As always, we start with a test:

[role="sourcecode"]
.lists/tests/test_views.py (ch18l003)
[source,python]
----
class MyListsTest(TestCase):

    def test_my_lists_url_renders_my_lists_template(self):
        response = self.client.get('/lists/users/a@b.com/')
        self.assertTemplateUsed(response, 'my_lists.html')
----

That gives:

----
AssertionError: False is not true : Template 'my_lists.html' was not a template
used to render the response. Actual template(s) used: <Unknown Template>
----

And we fix it, still at the views level, in 'urls.py', 'views.py', and by
creating 'my_lists.html':


[role="sourcecode"]
.lists/urls.py
[source,python]
----
urlpatterns = patterns('',
    url(r'^(\d+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^new$', 'lists.views.new_list', name='new_list'),
    url(r'^users/(.+)/$', 'lists.views.my_lists', name='my_lists'),
)
----
//004


Here's a minimal view:

[role="sourcecode"]
.lists/views.py (ch18l005)
[source,python]
----
def my_lists(request, email):
    return render(request, 'my_lists.html')
----

And, a minimal template:

[role="sourcecode"]
.lists/templates/my_lists.html
[source,html]
----
{% extends 'base.html' %}

{% block header_text %}My Lists{% endblock %}
----

That gets our unit tests passing, but our FT is still at the same point,
saying that the "My Lists" page doesn't yet show any lists.  It wants
them to be clickable links named after the first item:

----
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"link text","selector":"Reticulate splines"}' ; Stacktrace: 
----

Another pass, outside-in
~~~~~~~~~~~~~~~~~~~~~~~~

At each stage, we still let the FT drive what development we do.

Starting again at the outside layer, in the template, we can start to
write the template code we'd like to use to get the my lists page to
work the  way we want it to. It forces us to think about the API we
want our code to have, from the point of view of the things that use it, 
rather than trying to work bottom-up.

A quick re-structure of the template inheritance hierarchy
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Currently there's no place in our base template for us to put any new
content.  Also, the my lists page doesn't need the new item form, so
we'll put that into a block too, making it optional:

[role="sourcecode"]
.lists/templates/base.html (ch18l007-1)
[source,html]
----
    <div class="text-center">
        <h1>{% block header_text %}{% endblock %}</h1>

        {% block list_form %}
        <form method="POST" action="{% block form_action %}{% endblock %}">
            {{ form.text }}
            {% csrf_token %}
            {% if form.errors %}
                <div class="form-group has-error">
                    <div class="help-block">{{ form.text.errors }}</div>
                </div>
            {% endif %}
        </form>
        {% endblock %}

    </div>
----

[role="sourcecode"]
.lists/templates/base.html (ch18l007-2)
[source,html]
----
    <div class="row">
        <div class="col-md-6 col-md-offset-3">
            {% block table %}
            {% endblock %}
        </div>
    </div>

    <div class="row">
        <div class="col-md-6 col-md-offset-3">
            {% block extra_content %}
            {% endblock %}
        </div>
    </div>

</div>
<script src="http://code.jquery.com/jquery.min.js"></script>
----

We haven't seen this feature of the Django template language yet: 'list.html'
and 'home.html' now need to explicitly pull down the `list_form` block content
using `{{ block.super }}` 

[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
{% extends 'base.html' %}

{% block list_form %}{{ block.super }}{% endblock %}

{% block header_text %}Start a new To-Do list{% endblock %}

{% block form_action %}{% url 'new_list' %}{% endblock %}
----


[role="sourcecode"]
.lists/templates/list.html
[source,html]
----
{% extends 'base.html' %}

{% block list_form %}{{ block.super }}{% endblock %}

{% block header_text %}Your To-Do list{% endblock %}

{% block form_action %}{% url 'view_list' list.id %}{% endblock %}

{% block table %}
    <table id="id_list_table">
    [...]
----

Designing our API using the template
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Meanwhile, 'my_lists.html' can just work in the new `extra_content` block:

[role="sourcecode"]
.lists/templates/my_lists.html
[source,html]
----
{% extends 'base.html' %}

{% block header_text %}My Lists{% endblock %}

{% block extra_content %}
    <h2>{{ owner.email }}'s lists</h2>
    <ul>
        {% for list in owner.list_set.all %}
            <li><a href="{{ list.get_absolute_url }}">{{ list.name }}</a></li>
        {% endfor %}
    </ul>
{% endblock %}
----

We've made several design decisions in this template which are going
to filter their way down through the code:

* We want a variable called `owner` to represent the user in our template.

* We want to be able to iterate through the lists created by the user using
  `owner.list_set.all` (I happen to know we get this for free from the Django
  ORM)

* We want to use `list.name` to print out the "name" of the list, which is
  currently specified as the text of its first element.

We can re-run our FTs, to check we didn't break anything, and to see whether
we've got any further:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*]
[...]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"link text","selector":"Reticulate splines"}' ; Stacktrace: 

 ---------------------------------------------------------------------
Ran 7 tests in 77.613s

FAILED (errors=1)
----

This is a good time for a commit

[subs="specialcharacters,quotes"]
----
$ *git add lists*
$ *git diff --staged*
$ *git commit -m "url, placeholder view, and first-cut templates for my_lists"
----


Moving down to the next layer: what the view passes to the template
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[role="sourcecode"]
.lists/tests/test_views.py (ch18l011)
[source,python]
----
from django.contrib.auth import get_user_model
User = get_user_model()
[...]

    def test_passes_owner_to_template(self):
        user = User.objects.create(email='a@b.com')
        response = self.client.get('/lists/users/a@b.com/')
        self.assertEqual(response.context['owner'], user)
----

Gives

----
KeyError: 'owner'
----

so

[role="sourcecode"]
.lists/views.py
[source,python]
----
from django.contrib.auth import get_user_model
User = get_user_model()
[...]

def my_lists(request, email):
    owner = User.objects.get(email=email)
    return render(request, 'my_lists.html', {'owner': owner})
----

We'll then get an error which will require adding a user
to our other unit test



[role="sourcecode"]
.lists/tests/test_views.py (ch18l013)
[source,python]
----
    def test_my_lists_url_renders_my_lists_template(self):
        User.objects.create(email='a@b.com')
        [...]
----

And we get to an OK

----
OK
----


The next "requirement" from the views layer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Before we move down to the model layer, there's another part of the code
at the views layer that will need to use our model:  we need some way for
newly created lists to be assigned to an owner, if the current user is 
logged in to the site:


[role="sourcecode"]
.lists/tests/test_views.py (ch18l014)
[source,python]
----
from django.http import HttpRequest
[...]
from lists.views import new_list
[...]

class NewListTest(TestCase):
    [...]

    def test_list_owner_is_saved_if_user_is_authenticated(self):
        request = HttpRequest()
        request.user = User.objects.create(email='a@b.com')
        request.POST['text'] = 'new list item'
        new_list(request)
        list_ = List.objects.all()[0]
        self.assertEqual(list_.owner, request.user)
----

footnote:[I've chosen to use the raw view function, and to manually construct
an `HttpRequest`, rather than using the Django Test Client, because our custom
authentication function module, since it relies on Persona, would need a mock
to get the test to work. I think the non-mocky way is simpler, but, if you're
curious, why not try and write it differently?]

That fails as follows:

----
AttributeError: 'List' object has no attribute 'owner'
----

To fix this, we can try writing code like this:

[role="sourcecode"]
.lists/views.py  
[source,python]
----
def new_list(request):
    form = ItemForm(data=request.POST)
    if form.is_valid():
        list_ = List.objects.create()
        list_.owner = request.user
        list_.save()
        form.save(for_list=list_)
        return redirect(list_)
    else:
        return render(request, 'home.html', {"form": form})
----
//015


But it won't actually work until we go down to the next layer and 
adjust the model.


.A more purist approach involving mocks
*******************************************************************************

Is this "pure" outside-in TDD? No.  A purist approach to outside-in TDD would
want you to use mocks at this point, and have unit tests that are more 
isolated from one level to another.  Something like this:

[role="sourcecode"]
.lists/tests/test_views.py
[source,python]
----
from unittest.mock import Mock, patch
[...]

    @patch('lists.views.ItemForm.save', Mock()) #<3>
    @patch('lists.views.List.objects.create') #<1>
    def test_list_owner_is_saved_mocky(self, mock_List_create):
        request = HttpRequest()
        request.user = Mock()
        request.POST['text'] = 'new list item'
        mock_list = mock_List_create.return_value
        new_list(request)
        self.assertEqual(mock_list.owner, request.user) #<2>
----

<1> We mock out the `List.objects.create` function to be able
    to get access to the list that's going to be created by the view.

<2> Then we can assert about the owner we assign to it

<3> This is needed because otherwise the `form.save()` will complain
    that it's not been passed a real List object.

Try it!  You should find that it will pass, if you've added the
`list_.owner =` bit to the view.  Try removing the owner assignment,
and you'll see it fail:

----
AssertionError: <MagicMock name='create().owner' id='140176904220432'> != <Mock
id='140176904185168'>
----

Actually, 'strictly' speaking, you'd need another check that
the list.owner gets assigned 'before' the save function is called, 
making the test even more complicated:

[role="sourcecode"]
.lists/tests/test_views.py (ch18l016)
[source,python]
----
        mock_list = mock_List_create.return_value
        def check_owner_assigned_before_save():
            self.assertEqual(mock_list.owner, request.user)
        mock_list.save.side_effect = check_owner_assigned_before_save

        new_list(request)
----

So, yes, it's a more purist approach, but it does leave you with much
mockier, and less readable tests.  That's why I prefer a more pragmatic
approach.  I think "purist" Outside-In TDD, sometimes called "London-Style
TDD", isn't worth it when you're dealing with the Django ORM a lot -- it
works better if you have code that has no external dependencies or 
"boundaries". There's more discussion of this in the "Hot Lava" chapter.

*******************************************************************************



Moving down again: to the model layer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Next we move down to the model layer, to get the owner.list_set.all API
working:
 

[role="sourcecode"]
.lists/tests/test_models.py (ch18l018)
[source,python]
----
from django.contrib.auth import get_user_model
User = get_user_model()
[...]

    def test_list_can_have_owners(self):
        user = User.objects.create(email='a@b.com')
        list_ = List.objects.create(owner=user)
        self.assertIn(list_, user.list_set.all())
----

TODO: separate tests out into two test classes, one broadly for lists,
the other broadly for items.

The naive implementation would be this:

[role="skipme"]
[source,python]
----
class List(models.Model):
    owner = models.ForeignKey(settings.AUTH_USER_MODEL)
----

But we want to make sure the list owner is optional.  Explicit
is better than implicit, and tests are documentation, so let's have a test for
that too:


[role="sourcecode"]
.lists/tests/test_models.py (ch18l020)
[source,python]
----
    def test_list_owner_is_optional(self):
        List.objects.create()  # should not raise
----

The correct implementation is this:

[role="sourcecode"]
.lists/models.py
[source,python]
----
from django.conf import settings
[...]

class List(models.Model):
    owner = models.ForeignKey(settings.AUTH_USER_MODEL, blank=True, null=True)

    def get_absolute_url(self):
        return resolve_url('view_list', self.id)
----
//21

Now running the tests gives a database error

----
    return Database.Cursor.execute(self, query, params)
django.db.utils.OperationalError: table lists_list has no column named owner_id
----


Because we need to do a schema migration

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py schemamigration lists --auto
----
//22

We're almost there, a couple more failures:

----
ERROR: test_redirects_after_POST (lists.tests.test_views.NewListTest)
[...]
ValueError: Cannot assign "<SimpleLazyObject:
<django.contrib.auth.models.AnonymousUser object at 0x7f364795ef90>>":
"List.owner" must be a "User" instance.
ERROR: test_saving_a_POST_request (lists.tests.test_views.NewListTest)
[...]
ValueError: Cannot assign "<SimpleLazyObject:
<django.contrib.auth.models.AnonymousUser object at 0x7f364795ef90>>":
"List.owner" must be a "User" instance.
----

Notice that these are in the old test for the new_list view, when we
haven't got a logged-in user.  We should only save the list owner
when the user is actually logged in.  When they're not logged in,
Django represents them using a class called `AnonymousUser`:


[role="sourcecode dofirst-ch18l022"]
.lists/tests.py
[source,python]
----
from django.contrib.auth.models import AnonymousUser
[...]

    if form.is_valid():
        list_ = List.objects.create()
        if not isinstance(request.user, AnonymousUser):
            list_.owner = request.user
            list_.save()
        form.save(for_list=list_)
        [...]
----

And that gets us passing!

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
Creating test database for alias 'default'...
...................................
 ---------------------------------------------------------------------
Ran 35 tests in 0.237s

OK
----

This is a good time for a commit:

[subs="specialcharacters,quotes"]
----
$ *git add lists*
$ *git commit -m"lists can have owners, which are saved on creation."*
----



Final step: feeding through the .name API from the template
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The last thing our outside-in design wanted came from the templates,
which wanted to be able to access a list "name" based on the text of
its first item:

[role="sourcecode"]
.lists/tests/test_models.py (ch18l023)
[source,python]
----
    def test_list_name_is_first_item_text(self):
        list_ = List.objects.create()
        Item.objects.create(list=list_, text='first item')
        Item.objects.create(list=list_, text='second item')
        self.assertEqual(list_.name, 'first item')
----


[role="sourcecode"]
.lists/models.py (ch18l024)
[source,python]
----
    @property
    def name(self):
        return self.item_set.all()[0].text
----

.The @property decorator in Python
*******************************************************************************
If you haven't seen it before, the `@property` decorator transforms a method
on a class to make it appear to the outside world like an attribute.

This is a powerful feature of the language, because it makes it easy to 
implement "duck typing", to change the implementation of a property without
changing the interface of the class.  In other words, if we decide to change
`.name` into being a "real" attribute on the model, which is stored as text in
the database, then we will be able to do so entirely transparently -- as far as
the rest of our code is concerned, they will still be able to just access
`.name` and get the list name, without needing to know about the
implementation.

Of course, in the Django template language, `.name` would still call the method
even if it didn't have `@property`, but that's a particularity of Django, and
doesn't apply to Python in general...
*******************************************************************************


And that, believe it or not, actually gets us a passing test, 
and a working "My Lists" page!

.The "My Lists" page, in all its glory
image::images/my_lists_screenshot.png[Screenshot of new My Lists page]


----
$ python3 manage.py test functional_tests
Creating test database for alias 'default'...
.......
 ---------------------------------------------------------------------
Ran 7 tests in 93.819s

OK
----

I'll tell you what though, those FTs are taking an annoyingly long time to 
run though.  I wonder if there's something we can do about that?

.Outside-In TDD
*******************************************************************************

Outside-in TDD::
    A methodology for building code, driven by tests, which proceeds by
    starting from the "outside" layers (presentation, GUI), and moving
    "inwards" step-by-step, via view/controller layers, down towards 
    the model layer.  The idea is to drive the design of your code from
    the use to which it is going to be put, rather than trying to anticipate
    requirements from the ground up.

Mocks and "London-Style" TDD::
    In the world of Object-Oriented software design, outside-in TDD is 
    associated with the use of Mock objects. At each stage, you're writing
    tests for classes defining how they will collaborate with other
    classes that don't exist yet, at the next level down.  The natural solution
    is to use mocks to represent them.
    +
    In simple Django applications, where our layers are simply
    template/view/model, I find mocks to be overkill.  Once  applications reach
    the next level of complexity, where business logic is represented by
    a set of classes and functions independent of the Django ORM and 
    presentation layer, then the wider use of Mocks may be a better approach.
    It's beyond the scope of this book (and beyond my abilities) to present
    a decent overview of OO mocking techniques, and the pros and cons of what's
    called "London-Style" TDD to distinguish it from the "Chicago School", so
    I leave you to discover that world on your own.  Famous books in the field
    include "Growing Object-Oriented Software, Guided by Tests", by Steve
    Freeman and Nat Pryce

    TODO: add to bibliograpy.

*******************************************************************************

