Finishing "my lists": Outside-In TDD
------------------------------------

In this chapter I'd like to talk about a technique called "outside-in" TDD.
It's pretty much what we've been doing all along, but now I'll make it
explicit, and talk about some of the common issues involved.


The FT for "My Lists"
~~~~~~~~~~~~~~~~~~~~~

We know our `create_pre_authenticated_session` code works now, so we can just
write our FT to look for a "My Lists" page:


[role="sourcecode"]
.functional_tests/test_my_lists.py
[source,python]
----
    def test_logged_in_users_lists_are_saved_as_my_lists(self):
        # Edith is a logged-in user
        self.create_pre_authenticated_session()

        # She goes to the home page and starts a list
        self.browser.get(self.server_url)
        self.get_item_input_box().send_keys('Reticulate splines\n')
        self.get_item_input_box().send_keys('Immanentize eschaton\n')
        first_list_url = self.browser.current_url

        # She notices a "My lists" link, for the first time.
        self.browser.find_element_by_link_text('My lists').click()

        # She sees that her list is in there, named according to its
        # first list item
        self.browser.find_element_by_link_text('Reticulate splines').click()
        self.assertEqual(self.browser.current_url, first_list_url)

        # She decides to start another list, just to see
        self.browser.get(self.server_url)
        self.get_item_input_box().send_keys('Click cows\n')
        second_list_url = self.browser.current_url

        # Under "my lists", her new list appears
        self.browser.find_element_by_link_text('My lists').click()
        self.browser.find_element_by_link_text('Click cows').click()
        self.assertEqual(self.browser.current_url, second_list_url)

        # She logs out.  The "My lists" option disappears
        self.browser.find_element_by_id('id_logout').click()
        self.assertEqual(
            self.browser.find_elements_by_link_text('My lists'),
            []
        )
----

If you run it, the first error should look like this:

----
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"link text","selector":"My lists"}' ; Stacktrace: 
----


Outside-in TDD
~~~~~~~~~~~~~~

Our "double-loop" TDD process, in which we write the functional test first and
then the unit tests, is already a manifestation of outside-in TDD - we design
the system from the outside, and build up our code in layers. I'll point out
how we start with the most outward-facing (presentation layer), through to the
view functions (or "controllers"), and lastly the innermost layers, which in
this case will be model code.


The outside layer: presentation & templates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The test is currently failing saying that it can't find a link saying "My
Lists". We can address that at the presentation layer, in 'home.html', in
our navigation bar. Here's the minimal code change:

[role="sourcecode"]
.lists/templates/home.html (ch18002-1)
[source,html]
----
{% if user.email %}
    <ul class="nav navbar-nav">
        <li><a href="#">My lists</a></li>
    </ul>
    <a class="btn navbar-btn navbar-right" id="id_logout" href="{% url 'logout' %}">Log out</a>
[...]
----

Of course, that link doesn't actually go anywhere, but it does get us along to
the next failure:

----
    self.browser.find_element_by_link_text('Reticulate splines').click()
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"link text","selector":"Reticulate splines"}' ; Stacktrace: 
----

Which is telling us we're going to have to build a page that lists all of a
user's lists by title.  Let's start with the basics -- a URL and a placeholder
template for it.

Again, we can go outside-in, starting at the presentation layer with just the 
URL and nothing else:


[role="sourcecode"]
.lists/templates/home.html (ch18002-2)
[source,html]
----
    <ul class="nav navbar-nav">
        <li><a href="{% url 'my_lists' user.email %}">My lists</a></li>
    </ul>
----


Moving down one layer to view functions (the controller)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

That will cause a template error, so we can move in one step, from the
presentation layer down to the controller layer, Django's view functions.

As always, we start with a test:

[role="sourcecode"]
.lists/test_views.py (ch18l003)
[source,python]
----
class MyListsTest(TestCase):

    def test_my_lists_url_renders_my_lists_template(self):
        response = self.client.get('/lists/users/a@b.com/')
        self.assertTemplateUsed(response, 'my_lists.html')
----

That gives:

----
AssertionError: False is not true : Template 'my_lists.html' was not a template
used to render the response. Actual template(s) used: <Unknown Template>
----

And we fix it, still at the views level, in 'urls.py', 'views.py', and by
creating 'my_lists.html':


[role="sourcecode"]
.lists/urls.py
[source,python]
----
urlpatterns = patterns('',
    url(r'^(\d+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^new$', 'lists.views.new_list', name='new_list'),
    url(r'^users/(.+)/$', 'lists.views.my_lists', name='my_lists'),
)
----
//004


Here's a minimal view:

[role="sourcecode"]
.lists/views.py (ch18l005)
[source,python]
----
def my_lists(request, email):
    return render(request, 'my_lists.html')
----

And, a minimal template:

[role="sourcecode"]
.lists/templates/my_lists.html
[source,html]
----
{% extends 'base.html' %}

{% block header_text %}My Lists{% endblock %}
----

That gets our unit tests passing, but our FT is still at the same point,
saying that the "My Lists" page doesn't yet show any lists.  It wants
them to be clickable links named after the first item:

----
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate element: {"method":"link text","selector":"Reticulate splines"}' ; Stacktrace: 
----

Another pass, outside-in
~~~~~~~~~~~~~~~~~~~~~~~~

At each stage, we still let the FT drive what development we do.

Starting again at the outside layer, in the template, we can start to
write the template code we'd like to use to get the my lists page to
work the  way we want it to. It forces us to think about the API we
want our code to have, from the point of view of the things that use it, 
rather than trying to work bottom-up.

A quick re-structure of the template inheritance hierarchy
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Currently there's no place in our base template for us to put any new
content.  Also, the my lists page doesn't need the new item form, so
we'll put that into a block too, making it optional:

[role="sourcecode"]
.lists/templates/base.html (ch18l007-1)
[source,html]
----
    <div class="text-center">
        <h1>{% block header_text %}{% endblock %}</h1>

        {% block list_form %}
        <form method="POST" action="{% block form_action %}{% endblock %}">
            {{ form.text }}
            {% csrf_token %}
            {% if form.errors %}
                <div class="form-group has-error">
                    <div class="help-block">{{ form.text.errors }}</div>
                </div>
            {% endif %}
        </form>
        {% endblock %}

    </div>
----

[role="sourcecode"]
.lists/templates/base.html (ch18l007-2)
[source,html]
----
    <div class="row">
        <div class="col-md-6 col-md-offset-3">
            {% block table %}
            {% endblock %}
        </div>
    </div>

    <div class="row">
        <div class="col-md-6 col-md-offset-3">
            {% block extra_content %}
            {% endblock %}
        </div>
    </div>

</div>
<script src="http://code.jquery.com/jquery.min.js"></script>
----

We haven't seen this feature of the Django template language yet: 'list.html'
and 'home.html' now need to explicitly pull down the `list_form` block content
using `{{ block.super }}` 

[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
{% extends 'base.html' %}

{% block list_form %}{{ block.super }}{% endblock %}

{% block header_text %}Start a new To-Do list{% endblock %}

{% block form_action %}{% url 'new_list' %}{% endblock %}
----


[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
{% extends 'base.html' %}

{% block list_form %}{{ block.super }}{% endblock %}

{% block header_text %}Your To-Do list{% endblock %}

{% block form_action %}{% url 'view_list' list.id %}{% endblock %}

{% block table %}
    <table id="id_list_table">
    [...]
----

Designing our API using the template
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Meanwhile, 'my_lists.html' can just work in the new `extra_content` block:

[role="sourcecode"]
.lists/templates/my_lists.html
[source,html]
----
{% extends 'base.html' %}

{% block header_text %}My Lists{% endblock %}

{% block extra_content %}
    <h2>{{ owner.email }}'s lists</h2>
    <ul>
        {% for list in owner.list_set.all %}
            <li><a href="{{ list.get_absolute_url }}">{{ list.name }}</a></li>
        {% endfor %}
    </ul>
{% endblock %}
----

We've made several design decisions in this template which are going
to filter their way down through the code:

* We want a variable called `owner` to represent the user in our template.

* We want to be able to iterate through the lists created by the user using
  `owner.list_set.all` (I happen to know we get this for free from the Django
  ORM)

* We want to use `list.name` to print out the "name" of the list, which is
  currently specified as the text of its first element.

We can re-run our FTs, to check we didn't break anything, and to see whether
we've got any further:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*]
[...]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"link text","selector":"Reticulate splines"}' ; Stacktrace: 

 ---------------------------------------------------------------------
Ran 7 tests in 77.613s

FAILED (errors=1)
----

This is a good time for a commit

[subs="specialcharacters,quotes"]
----
$ *git add lists*
$ *git diff --staged*
$ *git commit -m "url, placeholder view, and first-cut templates for my_lists"
----


Moving down to the next layer: what the view passes to the template
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[role="sourcecode"]
.lists/tests/test_views.py (ch18l011)
[source,python]
----
from django.contrib.auth import get_user_model
User = get_user_model()
[...]

    def test_passes_owner_to_template(self):
        user = User.objects.create(email='a@b.com')
        response = self.client.get('/lists/users/a@b.com/')
        self.assertEqual(response.context['owner'], user)
----

Gives

----
KeyError: 'owner'
----

so

[role="sourcecode"]
.lists/views.py
[source,python]
----
from django.contrib.auth import get_user_model
User = get_user_model()
[...]

def my_lists(request, email):
    owner = User.objects.get(email=email)
    return render(request, 'my_lists.html', {'owner': owner})
----

We'll then get an error which will require adding a user
to our other unit test



[role="sourcecode"]
.lists/tests/test_views.py (ch18l013)
[source,python]
----
    def test_my_lists_url_renders_my_lists_template(self):
        User.objects.create(email='a@b.com')
        [...]
----

And we get to an OK

----
OK
----


The next "requirement" from the views layer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Before we move down to the model layer, there's another part of the code
at the views layer that will need to use our model:  we need some way for
newly created lists to be assigned to an owner, if the current user is 
logged in to the site:


[role="sourcecode"]
.lists/tests.py (ch18l014)
[source,python]
----
from django.http import HttpRequest
[...]
from lists.views import new_list
[...]

class NewListTest(TestCase):
    [...]

    def test_list_owner_is_saved_if_user_is_authenticated(self):
        request = HttpRequest()
        request.user = User.objects.create(email='a@b.com')
        request.POST['text'] = 'new list item'
        new_list(request)
        list_ = List.objects.all()[0]
        self.assertEqual(list_.owner, request.user)
----

footnote:[I've chosen to user the raw view function, and to manually construct
an `HttpRequest`, rather than using the Django Test Client, because our custom
authentication function module, since it relies on Persona, would need a mock
to get the test to work. I think the non-mocky way is simpler, but, if you're
curious, why not try and write it differently?]

That fails as follows:

----
AttributeError: 'List' object has no attribute 'owner'
----

To fix this, we can try writing code like this:

[role="sourcecode"]
.lists/views.py  
[source,python]
----
def new_list(request):
    form = ItemForm(data=request.POST)
    if form.is_valid():
        list_ = List.objects.create()
        list_.owner = request.user
        list_.save()
        form.save(for_list=list_)
        return redirect(list_)
    else:
        return render(request, 'home.html', {"form": form})
----
//015


But it won't actually work until we go down to the next layer and 
adjust the model.


.A more purist approach involving mocks
*******************************************************************************

Is this "pure" outside-in TDD? No.  A purist approach to outside-in TDD would
want you to use mocks at this point, and have unit tests that are more 
isolated from one level to another.  Something like this:

[role="sourcecode"]
.lists/tests/test_views.py
[source,python]
----
from unittest.mock import Mock, patch
[...]

    @patch('lists.views.ItemForm.save', Mock()) #<3>
    @patch('lists.views.List.objects.create') #<1>
    def test_list_owner_is_saved_mocky(self, mock_List_create):
        request = HttpRequest()
        request.user = Mock()
        request.POST['text'] = 'new list item'
        mock_list = mock_List_create.return_value
        new_list(request)
        self.assertEqual(mock_list.owner, request.user) #<2>
----

<1> We mock out the `List.objects.create` function to be able
    to get access to the list that's going to be created by the view.

<2> Then we can assert about the owner we assign to it

<3> This is needed because otherwise the `form.save()` will complain
    that it's not been passed a real List object.

Try it!  You should find that it will pass, if you've added the
`list_.owner =` bit to the view.  Try removing the owner assignment,
and you'll see it fail:

----
AssertionError: <MagicMock name='create().owner' id='140176904220432'> != <Mock
id='140176904185168'>
----

Actually, 'strictly' speaking, you'd need another check that
the list.owner gets assigned 'before' the save function is called, 
making the test even more complicated:

[role="sourcecode"]
.lists/tests/test_views.py (ch18l016)
[source,python]
----
        mock_list = mock_List_create.return_value
        def check_owner_assigned_before_save():
            self.assertEqual(mock_list.owner, request.user)
        mock_list.save.side_effect = check_owner_assigned_before_save

        new_list(request)
----

So, yes, it's a more purist approach, but it does leave you with much
mockier, and less readable tests.  That's why I prefer a more pragmatic
approach.  I think "purist" Outside-In TDD, sometimes called "London-Style
TDD", isn't worth it when you're dealing with the Django ORM a lot -- it
works better if you have code that has no external dependencies or 
"boundaries". There's more discussion of this in the "Hot Lava" chapter.

*******************************************************************************



Moving down again: to the model layer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Next we move down to the model layer, to get the owner.list_set.all API
working:
 

[role="sourcecode"]
.lists/tests/test_models.py (ch18l018)
[source,python]
----
from django.contrib.auth import get_user_model
User = get_user_model()
[...]

    def test_list_can_have_owners(self):
        user = User.objects.create(email='a@b.com')
        list_ = List.objects.create(owner=user)
        self.assertIn(list_, user.list_set.all())
----

TODO: separate tests out into two test classes, one broadly for lists,
the other broadly for items.

The naive implementation would be this:

[role="skipme"]
[source,python]
----
class List(models.Model):
    owner = models.ForeignKey(settings.AUTH_USER_MODEL)
----

But we want to make sure the list owner is optional.  Explicit
is better than implicit, and tests are documentation, so let's have a test for
that too:


[role="sourcecode"]
.lists/tests/test_models.py (ch18l020)
[source,python]
----
    def test_list_owner_is_optional(self):
        List.objects.create()  # should not raise
----

The correct implementation is this:

[role="sourcecode"]
.lists/models.py
[source,python]
----
from django.conf import settings
[...]

class List(models.Model):
    owner = models.ForeignKey(settings.AUTH_USER_MODEL, blank=True, null=True)

    def get_absolute_url(self):
        return resolve_url('view_list', self.id)
----
//21

Now running the tests gives a database error

----
    return Database.Cursor.execute(self, query, params)
django.db.utils.OperationalError: table lists_list has no column named owner_id
----


Because we need to do a schema migration

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py schemamigration lists --auto
----
//22

We're almost there, a couple more failures:

----
ERROR: test_redirects_after_POST (lists.tests.test_views.NewListTest)
[...]
ValueError: Cannot assign "<SimpleLazyObject:
<django.contrib.auth.models.AnonymousUser object at 0x7f364795ef90>>":
"List.owner" must be a "User" instance.
ERROR: test_saving_a_POST_request (lists.tests.test_views.NewListTest)
[...]
ValueError: Cannot assign "<SimpleLazyObject:
<django.contrib.auth.models.AnonymousUser object at 0x7f364795ef90>>":
"List.owner" must be a "User" instance.
----

Notice that these are in the old test for the new_list view, when we
haven't got a logged-in user.  We should only save the list owner
when the user is actually logged in.  When they're not logged in,
Django represents them using a class called `AnonymousUser`:


[role="sourcecode dofirst-ch18l022"]
.lists/tests.py
[source,python]
----
from django.contrib.auth.models import AnonymousUser
[...]

    if form.is_valid():
        list_ = List.objects.create()
        if not isinstance(request.user, AnonymousUser):
            list_.owner = request.user
            list_.save()
        form.save(for_list=list_)
        [...]
----

And that gets us passing!

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
Creating test database for alias 'default'...
...................................
 ---------------------------------------------------------------------
Ran 35 tests in 0.237s

OK
----

This is a good time for a commit:

[subs="specialcharacters,quotes"]
----
$ *git add lists*
$ *git commit -m"lists can have owners, which are saved on creation."*
----



Final step: feeding through the .name API from the template
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The last thing our outside-in design wanted came from the templates,
which wanted to be able to access a list "name" based on the text of
its first item:

[role="sourcecode"]
.lists/tests/test_models.py (ch18l023)
[source,python]
----
    def test_list_name_is_first_item_text(self):
        list_ = List.objects.create()
        Item.objects.create(list=list_, text='first item')
        Item.objects.create(list=list_, text='second item')
        self.assertEqual(list_.name, 'first item')
----


[role="sourcecode"]
.lists/models.py (ch18l024)
[source,python]
----
    @property
    def name(self):
        return self.item_set.all()[0].text
----


And that, believe it or not, actually gets us a passing test, 
and a working "My Lists" page!

.The "My Lists" page, in all its glory
image::images/my_lists_screenshot.png[Screenshot of new My Lists page]


----
$ python3 manage.py test functional_tests
Creating test database for alias 'default'...
.......
 ---------------------------------------------------------------------
Ran 7 tests in 93.819s

OK
----

I'll tell you what though, those FTs are taking an annoyingly long time to 
run though.  I wonder if there's something we can do about that?


TODO: outside-in TDD wrap-up

